(function(window) {


    // Ensure dependencies are loaded
    function ensureDependency(name) {
        if (typeof window[name] === 'undefined') {
            console.error(name + ' is not loaded. Please make sure all required scripts are included.');
            return false;
        }
        return true;
    }

    // Initialize utilities right away
    const utils = {
        async authedFetch(url, options = {}) {
            const token = localStorage.getItem('authToken');
            const headers = new Headers(options.headers || {});
            if (token) {
                headers.set('Authorization', 'Bearer ' + token);
            }
            return fetch(url, Object.assign({}, options, { headers: headers }));
        },
        showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            if (!container) return;
        
            const toast = document.createElement('div');
            toast.className = 'toast ' + type;
            
            const icons = {
                success: '<i class="fas fa-check-circle"></i>',
                error: '<i class="fas fa-exclamation-circle"></i>',
                warning: '<i class="fas fa-exclamation-triangle"></i>',
                info: '<i class="fas fa-info-circle"></i>',
                cancelled: '<i class="fas fa-ban"></i>'
            };

            const titles = {
                success: 'Ù†Ø¬Ø§Ø­',
                error: 'Ø®Ø·Ø£',
                warning: 'ØªÙ†Ø¨ÙŠÙ‡',
                info: 'Ù…Ø¹Ù„ÙˆÙ…Ø©',
                cancelled: 'Ø¥Ù„ØºØ§Ø¡'
            };

            toast.innerHTML = 
                '<div class="toast-icon">' + (icons[type] || icons.info) + '</div>' +
                '<div class="toast-content">' +
                    '<div class="toast-title">' + (titles[type] || 'Ø¥Ø´Ø¹Ø§Ø±') + '</div>' +
                    '<div class="toast-message">' + message + '</div>' +
                '</div>' +
                '<div class="toast-close" onclick="this.parentElement.remove()">&times;</div>';
            
            container.appendChild(toast);
        
            setTimeout(function() {
                toast.remove();
            }, 5000);
        }
    };

    // Make utilities globally available immediately
    window.utils = utils;
    window.authedFetch = utils.authedFetch;  // Direct global access for compatibility
    window.showToast = utils.showToast;      // Direct global access for compatibility

// == taskStore.js ==
ï»¿/**
 * TaskStore: The Single Source of Truth for task state management.
 * This store manages the state, handles updates, and persists data to localStorage.
 * It uses a custom event system to notify components of state changes,
 * mimicking a Redux/Context pattern in vanilla JavaScript.
 */

const { authedFetch } = window.utils;

const taskStore = {
  state: {
    // tasks: { agentId: { dayIndex: { audited: bool, competition_sent: bool } } }
    tasks: {},
  },
  _subscribers: [], // NEW: To hold all callback functions

  /**
   * Initializes the store by loading data from localStorage and fetching initial data.
   * This acts as the "hydration" step.
   */
  async init() {
    // Do not hydrate from localStorage â€” server is source-of-truth
    await this._fetchInitialData();
    // Notify all components that the initial state is ready.
    this._notify();
  },

  /**
   * The main dispatcher function to update task status.
   * This is the equivalent of a reducer action.
   * @param {string} agentId
   * @param {number} dayIndex
   * @param {'audited' | 'competition_sent'} taskType
   * @param {boolean} status
   */
  async updateTaskStatus(agentId, dayIndex, taskType, status) {
    try {
      const response = await authedFetch("/api/tasks", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ agentId, dayIndex, taskType, status }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(
          errorData.message || "Failed to update task on the server."
        );
      }

      // Consume returned saved task from server (backend returns { message, task })
      let savedTask = null;
      try {
        const respBody = await response.json();
        savedTask = respBody.task || null;
      } catch (_) {
        // ignore parse errors, fallback to using current time below
      }

      // Ensure the agent and day objects exist
      if (!this.state.tasks[agentId]) {
        this.state.tasks[agentId] = {};
      }
      if (
        !Object.prototype.hasOwnProperty.call(
          this.state.tasks[agentId],
          dayIndex
        )
      ) {
        this.state.tasks[agentId][dayIndex] = {
          audited: false,
          competition_sent: false,
        };
      }

      // Update the state and set a reliable _updatedAt value from server when available
      this.state.tasks[agentId][dayIndex][taskType] = status;
      this.state.tasks[agentId][dayIndex]._updatedAt =
        savedTask && savedTask.updatedAt
          ? savedTask.updatedAt
          : new Date().toISOString();

      // Notify UI subscribers (do not persist locally; server is authoritative)
      this._notify();
    } catch (error) {
      // console.error("Error updating task status:", error);
      // Re-throw the error to be caught by the calling UI component
      throw error;
    }
  },

  async resetAllTasks() {
    try {
      // Perform API call to reset all tasks on the backend
      const response = await authedFetch("/api/tasks/reset-all", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(
          errorData.message || "Failed to reset tasks on server."
        );
      }

      // If API call is successful, reset the in-memory state (server will reflect this)
      this.state.tasks = {};
      this._notify();
    } catch (error) {
      console.error("Error resetting all tasks:", error);
      throw error; // Re-throw for the UI to handle
    }
  },

  /**
   * Fetches the initial data (agents and tasks for the week) from the backend.
   * It merges the backend state with the local state, giving precedence to local changes.
   */
  async _fetchInitialData() {
    try {
      const response = await authedFetch("/api/calendar/data");
      if (!response.ok) throw new Error("Failed to fetch calendar data");
      const { tasks: serverTasks } = await response.json();
      
      // Build authoritative in-memory state based on server tasks only.
      const incoming = {};
      (serverTasks || []).forEach((task) => {
        // --- FIX: Use explicit day_index if available, else fallback to date parsing ---
        let dayIndex;
        if (task.day_index !== undefined && task.day_index !== null) {
            dayIndex = task.day_index;
        } else {
            dayIndex = new Date(task.task_date).getDay();
        }
        
        const agentId = String(
          task.agent_id ?? task.agentId ?? task._id ?? task.agent ?? ""
        );
        if (!agentId) return;
        if (!incoming[agentId]) incoming[agentId] = {};
        incoming[agentId][dayIndex] = {
          audited: !!task.audited,
          competition_sent: !!task.competition_sent,
          _updatedAt: task.updatedAt || task.task_date,
        };
      });

      // Replace in-memory state with server state (server is source-of-truth)
      this.state.tasks = incoming;
    } catch (error) {
      console.error("[TaskStore] âŒ Failed to fetch initial task data:", error);
    }
  },

  /**
   * Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ø­Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ø®Ø§Ø¯Ù… Ù„Ø¶Ù…Ø§Ù† ØªÙˆØ­ÙŠØ¯ Ø§Ù„Ø¹Ø±Ø¶ Ø¨ÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†.
   * Ø§Ù„Ø®Ø§Ø¯Ù… Ù‡Ùˆ Ù…ØµØ¯Ø± Ø§Ù„Ø­Ù‚ÙŠÙ‚Ø©Ø› ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø­Ù„ÙŠØ© Ø¨Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø§Ø¯Ù….
   */
  async syncWithServer() {
    try {
      const response = await authedFetch("/api/calendar/data");
      if (!response.ok) throw new Error("Failed to sync calendar data");
      const { tasks: serverTasks } = await response.json();
      // Rebuild authoritative state from server and replace in-memory state.
      const incoming = {};
      (serverTasks || []).forEach((task) => {
        // --- FIX: Use explicit day_index if available, else fallback to date parsing ---
        let dayIndex;
        if (task.day_index !== undefined && task.day_index !== null) {
            dayIndex = task.day_index;
        } else {
            dayIndex = new Date(task.task_date).getDay();
        }

        const agentId = String(
          task.agent_id ?? task.agentId ?? task._id ?? task.agent ?? ""
        );
        if (!agentId) return;
        if (!incoming[agentId]) incoming[agentId] = {};
        incoming[agentId][dayIndex] = {
          audited: !!task.audited,
          competition_sent: !!task.competition_sent,
          _updatedAt: task.updatedAt || task.task_date,
        };
      });

      this.state.tasks = incoming;
      this._notify();
    } catch (error) {
      console.error("[TaskStore] âŒ Sync failed:", error);
    }
  },

  _loadState() {
    // intentionally noop â€” local persistence removed, server is authoritative
  },

  _saveState() {
    // intentionally noop â€” local persistence removed, server is authoritative
  },

  _notify() {
    // Call all subscribed callbacks with a deep clone of the new state to prevent mutation.
    const stateClone = JSON.parse(JSON.stringify(this.state));
    this._subscribers.forEach((callback) => callback(stateClone));
  },

  /**
   * Subscribes a callback function to state changes.
   * @param {Function} callback
   */
  subscribe(callback) {
    if (!this._subscribers.includes(callback)) {
      this._subscribers.push(callback);
    }
  },

  /**
   * Unsubscribes a callback function from state changes.
   * @param {Function} callback
   */
  unsubscribe(callback) {
    this._subscribers = this._subscribers.filter((cb) => cb !== callback);
  },
};

// Make it globally accessible immediately
window.taskStore = taskStore;

// Initialize the store only after the main document is fully loaded and parsed.
// This ensures that functions from other scripts (like authedFetch) are available.
document.addEventListener("DOMContentLoaded", () => {
  taskStore.init().then(() => {
    // Dispatch storeReady event after initialization is complete.
    window.dispatchEvent(new Event("storeReady"));
    // Start periodic server sync to reflect others' changes
    setInterval(() => taskStore.syncWithServer(), 20000);
  });
});


// == home.js ==
ï»¿async function renderHomePage() {
    // Verify authentication first
    const token = localStorage.getItem('authToken');
    if (!token) {
        window.location.replace('/login.html');
        return;
    }

    // Verify user profile exists or fetch it
    let userProfile = JSON.parse(localStorage.getItem('userProfile'));
    if (!userProfile) {
        try {
            const profileResponse = await fetch('/api/auth/me', {
                headers: { 'Authorization': `Bearer ${token}` }
            });
            if (!profileResponse.ok) {
                throw new Error('Failed to fetch user profile');
            }
            userProfile = await profileResponse.json();
            localStorage.setItem('userProfile', JSON.stringify(userProfile));
        } catch (error) {
        /* logs suppressed: profile fetch failed */
            localStorage.removeItem('authToken');
            window.location.replace('/login.html');
            return;
        }
    }

    const appContent = document.getElementById('app-content');

    // 1. Ø¹Ø±Ø¶ Ù‡ÙŠÙƒÙ„ Ø§Ù„ØµÙØ­Ø© ÙÙˆØ±Ø§Ù‹ Ù…Ø¹ Ù…Ø¤Ø´Ø±Ø§Øª ØªØ­Ù…ÙŠÙ„
    renderHomePageSkeleton();

    // 2. Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Ø³ÙŠØ³ØªØ®Ø¯Ù… Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø®Ø²Ù†Ø© Ù…Ø¤Ù‚ØªØ§Ù‹ Ø¥Ù† ÙˆØ¬Ø¯Øª)
    const stats = await fetchHomePageData();

    // 3. ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø¨Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    if (stats) {
        await updateHomePageUI(stats);
    } else {
        // Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£ ÙÙŠ Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø¥Ø°Ø§ ÙØ´Ù„ ÙƒÙ„ Ø´ÙŠØ¡
        const statsContainer = document.getElementById('home-stats-container');
        if (statsContainer) {
            statsContainer.innerHTML = `<p class="error" style="text-align: center; padding: 20px;">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ….</p>`;
        }
    }

    updateStatus('connected', 'Ù…ØªØµÙ„ ÙˆØ¬Ø§Ù‡Ø²'); // Ensure status is updated on home page load
}

async function fetchHomePageData() {
    try {
        const response = await authedFetch('/api/stats/home');
        if (!response.ok) {
            throw new Error('Failed to fetch home page stats.');
        }
        return await response.json();
    } catch (error) {
    /* logs suppressed: error fetching home page data */
        return null; // Return null to show an error message on the UI
    }
}

function renderHomePageSkeleton() {
    const appContent = document.getElementById('app-content');
    const loaderHtml = '<div class="loader-container small-loader"><div class="spinner"></div></div>';

    appContent.innerHTML = `
        <div class="page-header dashboard-header-card"><h1><i class="fas fa-tachometer-alt"></i> Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</h1><p class="welcome-message" id="welcome-message"></p></div>

        <div id="home-stats-container">${loaderHtml}</div>
        <div class="home-grid">
            <div class="home-main-column">
                <h2>ØªÙ‚Ø¯Ù… Ù…Ù‡Ø§Ù… Ø§Ù„ÙŠÙˆÙ… (<span id="progress-percentage">...</span>%)</h2>
                <div class="progress-bar-container">
                    <div id="tasks-progress-bar" class="progress-bar" style="width: 0%;"></div>
                    <span id="progress-label" class="progress-label">... / ...</span>
                </div>
 
                <h2 style="margin-top: 30px;">Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ø±Ø³Ù„Ø© Ø®Ù„Ø§Ù„ Ø§Ù„ÙŠÙˆÙ…</h2>
                <div id="competitions-chart-container" class="chart-container">${loaderHtml}</div>
            </div>
            <div class="home-side-column">
                <h2>Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ© Ù„Ù„ÙŠÙˆÙ… (<span id="pending-count">...</span>)</h2>
                <div id="pending-tasks-list" class="pending-tasks-list">${loaderHtml}</div>

                <h2 style="margin-top: 30px;">Ù†Ø¸Ø±Ø© Ø³Ø±ÙŠØ¹Ø© Ø¹Ù„Ù‰ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡</h2>
                <div id="agent-quick-stats" class="agent-quick-stats">${loaderHtml}</div>
            </div>
        </div>
 
        <h2 style="margin-top: 40px;">Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø³Ø±ÙŠØ¹Ø©</h2>
        <div class="quick-actions">
            <a href="#add-agent?returnTo=home" class="quick-action-card"><h3><i class="fas fa-user-plus"></i> Ø¥Ø¶Ø§ÙØ© ÙˆÙƒÙŠÙ„ Ø¬Ø¯ÙŠØ¯</h3><p>Ø¥Ø¶Ø§ÙØ© ÙˆÙƒÙŠÙ„ Ø¬Ø¯ÙŠØ¯ Ø¥Ù„Ù‰ Ø§Ù„Ù†Ø¸Ø§Ù… ÙˆØªØ¹ÙŠÙŠÙ† Ø¨ÙŠØ§Ù†Ø§ØªÙ‡.</p></a>            
            <a href="#competition-templates" class="quick-action-card"><h3><i class="fas fa-file-alt"></i> Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ù„Ø¨ Ù…Ø³Ø§Ø¨Ù‚Ø©</h3><p>Ø¥Ø¶Ø§ÙØ© Ø£Ùˆ ØªØ¹Ø¯ÙŠÙ„ Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ø¬Ø§Ù‡Ø²Ø©.</p></a>
        </div>

        <div id="connection-status" class="status-bar status-connecting">
            <span id="status-text">Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„...</span>
            <span id="last-check-time"></span>
        </div>
    `;
}

// --- NEW: Function to render the UI from data (cached or fresh) ---
async function updateHomePageUI(stats) {
    /* logs suppressed */
    
    if (!stats) {
    /* logs suppressed: no stats provided */
        return;
    }

    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù€ RPC
    const { total_agents: totalAgents, active_competitions: activeCompetitions, competitions_today_count: competitionsTodayCount, agents_for_today: agentsForToday, new_agents_this_month: newAgentsThisMonth, agents_by_classification: agentsByClassification, tasks_for_today: tasksForToday, top_agents: topAgents } = stats;

    /* logs suppressed: extracted data */

    // --- NEW: Welcome Message ---
    const welcomeEl = document.getElementById('welcome-message');
    if (welcomeEl && currentUserProfile) {
        const userName = currentUserProfile.full_name || currentUserProfile.email.split('@')[0];
        welcomeEl.textContent = `Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒØŒ ${userName}!`;
    }


        // --- ØªØ­Ø¯ÙŠØ« ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø¹Ø¯ Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ---

        // 1. Update Stat Cards
        const statsContainer = document.getElementById('home-stats-container');
        statsContainer.innerHTML = ` 
            <div class="dashboard-grid-v2">
                <a href="#manage-agents" class="stat-card-v2 color-1">
                    <div class="stat-card-v2-icon-bg"><i class="fas fa-users"></i></div>
                    <p class="stat-card-v2-value">${formatNumber(totalAgents)}</p>
                    <h3 class="stat-card-v2-title">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡</h3>
                </a>
                <a href="#competitions" class="stat-card-v2 color-2">
                    <div class="stat-card-v2-icon-bg"><i class="fas fa-trophy"></i></div>
                    <p class="stat-card-v2-value">${formatNumber(activeCompetitions)}</p>
                    <h3 class="stat-card-v2-title">Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ù†Ø´Ø·Ø©</h3>
                </a>
                <a href="#competitions" class="stat-card-v2 color-3">
                    <div class="stat-card-v2-icon-bg"><i class="fas fa-paper-plane"></i></div>
                    <p class="stat-card-v2-value">${formatNumber(competitionsTodayCount)}</p>
                    <h3 class="stat-card-v2-title">Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ø±Ø³Ù„Ø© Ø§Ù„ÙŠÙˆÙ…</h3>
                </a>
            </div>
        `;

        // 2. Update Tasks Progress
        const currentDayIndex = new Date().getDay();
        console.log('[Home] Debugging Saturday Tasks:', {
            dayIndex: currentDayIndex,
            agentsForTodayCount: agentsForToday?.length,
            agentsForToday: agentsForToday
        });

        // FAILSAFE: Force hide tasks on Saturday (6)
        let effectiveAgentsForToday = agentsForToday;
        if (currentDayIndex === 6) {
            console.warn('[Home] Saturday detected. Forcing empty task list on frontend.');
            effectiveAgentsForToday = [];
        }

        const totalTodayAgents = effectiveAgentsForToday?.length || 0;
        const pendingList = document.getElementById('pending-tasks-list');
        if (!pendingList) return; // Exit if the element is not on the page

        if (totalTodayAgents > 0) {
            /* logs suppressed: starting progress calculation */
            
            // ØªØ¹Ø¯ÙŠÙ„: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„ØªÙŠ ØªÙ… Ø¬Ù„Ø¨Ù‡Ø§ Ù…Ø³Ø¨Ù‚Ø§Ù‹
                // Prefer authoritative task status from /api/tasks/today (returns { tasksMap })
                let tasksMap = {};
                try {
                    /* logs suppressed: fetching tasks */
                    const todayResp = await authedFetch('/api/tasks/today');
                    /* logs suppressed: response status */
                    
                    if (todayResp.ok) {
                        const todayData = await todayResp.json();
                        tasksMap = todayData.tasksMap || {};
                        /* logs suppressed: tasks fetched successfully */
                    } else {
                        /* logs suppressed: failed to fetch tasks */
                    }
                } catch (e) {
                    /* logs suppressed: failed to load /api/tasks/today, will fallback */
                }

                // Fallback: build a map from stats.tasks_for_today shape if needed
                if (!tasksMap || Object.keys(tasksMap).length === 0) {
                    /* logs suppressed: using fallback */
                    tasksMap = (tasksForToday || []).reduce((acc, task) => {
                        const key = String(task.agent_id ?? task.agentId ?? task._id ?? task.agent ?? '');
                        if (key) acc[key] = task;
                        return acc;
                    }, {});
                    /* logs suppressed: fallback map */
                }

                // A daily task for an agent counts as complete when audited only
                const totalTodayActions = totalTodayAgents; // Count auditing only
                let completedActions = 0;

                /* logs suppressed: calculating completed actions */
                effectiveAgentsForToday.forEach(agent => {
                    const task = tasksMap[agent._id] || {};
                    /* logs suppressed: per-agent details */
                    
                    if (task.audited) {
                        completedActions++;
                    }
                    // Competition is not counted in progress anymore
                });

                /* logs suppressed: final calculations */
                
                const pendingAgents = effectiveAgentsForToday.filter(agent => {
                    const task = tasksMap[agent._id];
                    return !task || !task.audited; // Only check audited status
                });
                
                /* logs suppressed: pending count */

                // ØªØ±ØªÙŠØ¨ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø­Ø³Ø¨ Ø§Ù„ØªØµÙ†ÙŠÙ
                pendingAgents.sort((a, b) => {
                    const classOrder = { 'R': 0, 'A': 1, 'B': 2, 'C': 3 };
                    return classOrder[a.classification] - classOrder[b.classification];
                });

                const progressPercent = totalTodayActions > 0 ? Math.round((completedActions / totalTodayActions) * 100) : 0;
                /* logs suppressed: progress percentage */
                
                const progressLabel = `${completedActions} / ${totalTodayActions}`;
                /* logs suppressed: progress label */
                
                // Update UI elements
                const progressPercentEl = document.getElementById('progress-percentage');
                const progressBarEl = document.getElementById('tasks-progress-bar');
                const progressLabelEl = document.getElementById('progress-label');
                const pendingCountEl = document.getElementById('pending-count');
                
                /* logs suppressed: updating UI elements */
                
                if (progressPercentEl) {
                    progressPercentEl.textContent = progressPercent;
                    /* logs suppressed */
                }
                
                if (progressBarEl) {
                    progressBarEl.style.width = `${progressPercent}%`;
                    /* logs suppressed */
                }
                
                if (progressLabelEl) {
                    progressLabelEl.textContent = progressLabel;
                    /* logs suppressed */
                }
                
                if (pendingCountEl) {
                    pendingCountEl.textContent = pendingAgents.length;
                    /* logs suppressed */
                }

                // Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠÙ†
                if (pendingAgents.length > 0) {
                    pendingList.innerHTML = pendingAgents.map(agent => `
                        <a href="#tasks?highlight=${agent._id}" class="pending-task-item ${tasksMap[agent._id]?.competition_sent ? 'partial' : ''}">
                            <div class="pending-task-info">
                                <span class="pending-agent-name">${agent.name}</span>
                                <span class="pending-agent-id">#${agent.agent_id}</span>
                            </div>
                            <span class="classification-badge classification-${agent.classification.toLowerCase()}">${agent.classification}</span>
                        </a>
                    `).join('');
                } else {
                    pendingList.innerHTML = '<p class="no-pending-tasks">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù‡Ø§Ù… Ù…ØªØ¨Ù‚ÙŠØ© Ù„Ù„ÙŠÙˆÙ… ğŸ‰</p>';
                }
                
                let pendingHtml = '';

                if (pendingAgents.length > 0) {
                    // --- ØªØ¹Ø¯ÙŠÙ„: Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© ÙˆØ§Ø­Ø¯Ø© Ù…Ø¨Ø³Ø·Ø© ---
                    pendingHtml = pendingAgents.slice(0, 5).map(agent => {
                        const task = tasksMap[agent._id] || {}; // FIX: Use _id instead of id
                        const needsAudit = !task.audited;
                        const needsCompetition = !task.competition_sent;
                        return `
                        <div class="pending-agent-card-v2" data-agent-id="${agent._id}" style="cursor: pointer;">
                            <div class="pending-agent-info">
                                ${agent.avatar_url ? `<img src="${agent.avatar_url}" alt="Avatar" loading="lazy">` : `<div class="avatar-placeholder"><i class="fas fa-user"></i></div>`}
                                <div class="agent-name-wrapper">
                                    <span class="agent-name-link">${agent.name}</span>
                                    <div class="pending-task-actions">
                                        ${needsAudit ? '<button class="btn-icon-action home-task-action audit" data-task-type="audit" title="ØªÙ…ÙŠÙŠØ² Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ ÙƒÙ…ÙƒØªÙ…Ù„"><i class="fas fa-clipboard-check"></i> <span>ØªØ¯Ù‚ÙŠÙ‚</span></button>' : ''}
                                        ${needsCompetition ? `<button class="btn-icon-action home-task-action competition" data-task-type="competition" data-auditing-enabled="${agent.is_auditing_enabled}" title="ØªÙ…ÙŠÙŠØ² Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© ÙƒÙ…ÙƒØªÙ…Ù„Ø©"><i class="fas fa-pen-alt"></i> <span>Ù…Ø³Ø§Ø¨Ù‚Ø©</span></button>` : ''}
                                    </div>
                                </div>
                            </div>
                            <div class="pending-agent-actions">
                                <span class="classification-badge classification-${agent.classification.toLowerCase()}">${agent.classification}</span>
                                <a href="#tasks?highlight=${agent._id}" class="go-to-task-icon" title="Ø§Ù„Ø°Ù‡Ø§Ø¨ Ù„Ù„Ù…Ù‡Ù…Ø©"><i class="fas fa-chevron-left"></i></a>
                            </div>
                        </div>
                        `;
                    }).join('');

                    if (pendingAgents.length > 5) {
                        pendingHtml += `<div class="view-all-container"><a href="#tasks" class="btn-secondary btn-small"><i class="fas fa-arrow-left"></i> Ø¹Ø±Ø¶ ÙƒÙ„ Ø§Ù„Ù…Ù‡Ø§Ù… (${pendingAgents.length} Ù…Ù‡Ù…Ø©)</a></div>`;
                    }

                } else {
                    pendingHtml = '<p class="no-pending-tasks">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù‡Ø§Ù… Ù…ØªØ¨Ù‚ÙŠØ© Ù„Ù‡Ø°Ø§ Ø§Ù„ÙŠÙˆÙ…. Ø¹Ù…Ù„ Ø±Ø§Ø¦Ø¹!</p>';
                }
                pendingList.innerHTML = pendingHtml;

                // --- NEW: Event Delegation for CSP Compliance ---
                pendingList.addEventListener('click', (e) => {
                    const taskAction = e.target.closest('.home-task-action');
                    if (taskAction) {
                        handleHomeTaskAction(e);
                        return;
                    }
                    const card = e.target.closest('.pending-agent-card-v2');
                    if (card && !e.target.closest('a')) {
                        window.location.hash = `#profile/${card.dataset.agentId}`;
                    }
                });
        } else {
            // NEW: Handle the case where there are no tasks scheduled for today at all
            /* logs suppressed: no agents scheduled */
            pendingList.innerHTML = '<p class="no-pending-tasks">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù‡Ø§Ù… Ù…Ø¬Ø¯ÙˆÙ„Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„ÙŠÙˆÙ….</p>';
            
            const progressPercentEl = document.getElementById('progress-percentage');
            const pendingCountEl = document.getElementById('pending-count');
            const progressLabelEl = document.getElementById('progress-label');
            
            if (progressPercentEl) progressPercentEl.textContent = 0;
            if (pendingCountEl) pendingCountEl.textContent = 0;
            if (progressLabelEl) progressLabelEl.textContent = '0 / 0';
            
            /* logs suppressed: set counters to 0 */
        }

    // 3. Render Competitions Chart
    const chartContainer = document.getElementById('competitions-chart-container');
    if (chartContainer) {
        // Clear loader before rendering chart
        chartContainer.innerHTML = '<canvas id="competitions-chart"></canvas>'; 
        renderCompetitionsChart(stats.competitions_today_hourly || []);
    }

    // 4. Render Agent Quick Stats
    const agentStatsContainer = document.getElementById('agent-quick-stats');
    if (agentStatsContainer) {
        const classificationCounts = agentsByClassification || {};
        agentStatsContainer.innerHTML = `
            <div class="quick-stat-item">
                <div class="stat-info">
                    <h4>ÙˆÙƒÙ„Ø§Ø¡ Ø¬Ø¯Ø¯ Ù‡Ø°Ø§ Ø§Ù„Ø´Ù‡Ø±</h4>
                    <p>${formatNumber(newAgentsThisMonth)}</p>
                </div>
                <div class="stat-icon"><i class="fas fa-user-plus"></i></div>
            </div>
            <div class="classification-chart-container"><canvas id="classification-chart"></canvas></div>
        `;
        
        // Render the new classification chart AFTER the container is in the DOM
        renderClassificationChart(classificationCounts);
    }

    // 5. Removed activity distribution section - moved to analytics page only
}


async function handleHomeTaskAction(event) {
    const button = event.target.closest('.home-task-action');
    if (!button) return;

    const card = button.closest('.pending-agent-card-v2');
    const agentId = card.dataset.agentId;
    const taskType = button.dataset.taskType;

    if (taskType === 'audit') {
        // ØªØ¹Ø¯ÙŠÙ„: Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ ØµÙØ­Ø© Ø§Ù„Ù…Ù‡Ø§Ù… Ù…Ø¹ Ø§Ù„ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ Ø§Ù„ÙˆÙƒÙŠÙ„
        window.location.hash = `tasks?highlight=${agentId}`;
    } else if (taskType === 'competition') {
        const auditingEnabled = button.dataset.auditingEnabled === 'true';
        if (!auditingEnabled) {
             if (typeof window.showToast === 'function') {
                 window.showToast('Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù‚Ø¨Ù„ Ø¥ØªÙ…Ø§Ù… Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„.', 'error');
             } else {
                 alert('Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù‚Ø¨Ù„ Ø¥ØªÙ…Ø§Ù… Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„.');
             }
             return;
        }
        window.location.hash = `competitions/new?agentId=${agentId}`;
    }
}

function renderClassificationChart(classificationData) {
    const ctx = document.getElementById('classification-chart')?.getContext('2d');
    if (!ctx) return;

    const labels = Object.keys(classificationData);
    const data = Object.values(classificationData);

    // ØªØ¹Ø¯ÙŠÙ„: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£Ù„ÙˆØ§Ù† Ø£ÙƒØ«Ø± ØªÙ†Ø§Ø³Ù‚Ø§Ù‹ Ù…Ø¹ Ù‡ÙˆÙŠØ© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
    const backgroundColors = [
        '#4CAF50', // --primary-color
        '#F4A261', // --accent-color
        '#3498db', // Blue
        '#9b59b6', // Purple
    ];

    new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: labels,
            datasets: [{
                label: 'ØªØµÙ†ÙŠÙ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡',
                data: data,
                backgroundColor: backgroundColors,
                borderColor: 'var(--card-bg-color)',
                borderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'right',
                    labels: {
                        color: 'var(--text-color)',
                        font: {
                            weight: 'bold'
                        }
                    },
                    // ØªØ¹Ø¯ÙŠÙ„: Ø¬Ø¹Ù„ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ ØªÙØ§Ø¹Ù„ÙŠØ§Ù‹
                    onClick: (evt, elements) => {
                        if (elements.length > 0) {
                            const clickedIndex = elements[0].index;
                            const classificationLabel = labels[clickedIndex];
                            if (classificationLabel && classificationLabel !== 'N/A') {
                                window.location.hash = `#manage-agents?filter=${classificationLabel}`;
                            }
                        }
                    },
                }
            },
            cutout: '60%'
        }
    });
}

function renderCompetitionsChart(competitions) {
    const ctx = document.getElementById('competitions-chart')?.getContext('2d');
    if (!ctx) return;

    // Group competitions by hour
    const hourlyData = Array(24).fill(0);
    competitions.forEach(comp => {
        const hour = new Date(comp.createdAt).getHours();
        hourlyData[hour]++;
    });

    const chartLabels = Array.from({ length: 24 }, (_, i) => {
        const hour = i % 12 === 0 ? 12 : i % 12;
        const ampm = i < 12 ? 'Øµ' : 'Ù…';
        return `${hour} ${ampm}`;
    });

    new Chart(ctx, {
        type: 'line',
        data: {
            labels: chartLabels,
            datasets: [{
                label: 'Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª',
                data: hourlyData,
                fill: true,
                backgroundColor: (context) => {
                    const chart = context.chart;
                    const {ctx, chartArea} = chart;
                    if (!chartArea) return null;
                    const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
                    gradient.addColorStop(0, 'rgba(76, 175, 80, 0)'); // Green transparent
                    gradient.addColorStop(1, 'rgba(76, 175, 80, 0.4)'); // Green with opacity
                    return gradient;
                },
                borderColor: 'var(--primary-color)', // Use the new green
                borderWidth: 2,
                pointBackgroundColor: 'var(--primary-color)',
                pointRadius: 3,
                pointHoverRadius: 5,
                tension: 0.4 // Makes the line smooth
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    grid: {
                        display: false // Hide vertical grid lines
                    }
                },
                y: {
                    beginAtZero: true,
                    ticks: { stepSize: 1 }, // Ensure y-axis shows whole numbers
                    grid: {
                        color: 'rgba(255, 255, 255, 0.05)' // Lighter grid lines for dark mode
                    }
                }
            },
            plugins: { legend: { display: false } }
        }
    });
}

async function renderTopAgentsSection() {
    const appContent = document.getElementById('app-content');
    
    appContent.innerHTML = `
        <div class="page-header">
            <h1><i class="fas fa-trophy"></i> Ø£Ø¨Ø±Ø² Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡</h1>
        </div>
        
        <div class="top-agents-container">
            <!-- Top 3 Agents Section -->
            <div class="top-3-agents">
                <h2 class="section-title">Ø£ÙØ¶Ù„ 3 ÙˆÙƒÙ„Ø§Ø¡</h2>
                <div class="top-3-grid" id="top-3-agents-grid">
                    <div class="loader-container"><div class="spinner"></div></div>
                </div>
            </div>
            
            <!-- Other Agents Sections -->
            <div class="other-agents">
                <h2 class="section-title">Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ø­ØµØ±ÙŠÙŠÙ†</h2>
                <div class="agents-grid" id="exclusive-agents-grid">
                    <div class="loader-container"><div class="spinner"></div></div>
                </div>
                
                <h2 class="section-title">Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ø§Ø¹ØªÙŠØ§Ø¯ÙŠÙŠÙ†</h2>
                <div class="agents-grid" id="regular-agents-grid">
                    <div class="loader-container"><div class="spinner"></div></div>
                </div>
            </div>
        </div>
    `;

    try {
        const response = await authedFetch('/api/agents?sort=performance');
        if (!response.ok) {
            throw new Error('Failed to fetch agents data');
        }

        const { data: agents } = await response.json();
        
        // Split agents into categories
        const top3Agents = agents.slice(0, 3);
        const exclusiveAgents = agents.filter(agent => 
            agent.is_exclusive && !top3Agents.includes(agent)
        );
        const regularAgents = agents.filter(agent => 
            !agent.is_exclusive && !top3Agents.includes(agent)
        );

        // Render top 3 agents
        document.getElementById('top-3-agents-grid').innerHTML = `
            ${top3Agents.map((agent, index) => `
                <div class="top-agent-card rank-${index + 1}">
                    <div class="rank-badge">${index + 1}</div>
                    <div class="agent-avatar">
                        ${agent.avatar_url ? 
                            `<img src="${agent.avatar_url}" alt="${agent.name}">` : 
                            `<div class="avatar-placeholder"><i class="fas fa-user"></i></div>`
                        }
                    </div>
                    <div class="agent-info">
                        <h3>${agent.name}</h3>
                        <span class="classification-badge classification-${agent.classification.toLowerCase()}">${agent.classification}</span>
                        <div class="stats">
                            <div class="stat"><i class="fas fa-users"></i> ${agent.clients_count} Ø¹Ù…ÙŠÙ„</div>
                            <div class="stat"><i class="fas fa-trophy"></i> ${agent.competitions_count} Ù…Ø³Ø§Ø¨Ù‚Ø©</div>
                        </div>
                    </div>
                </div>
            `).join('')}
        `;

        // Render exclusive agents
        document.getElementById('exclusive-agents-grid').innerHTML = 
            exclusiveAgents.length ? 
            exclusiveAgents.map(agent => generateAgentCard(agent)).join('') :
            '<p class="no-results">Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆÙƒÙ„Ø§Ø¡ Ø­ØµØ±ÙŠÙŠÙ† Ø­Ø§Ù„ÙŠØ§Ù‹</p>';

        // Render regular agents
        document.getElementById('regular-agents-grid').innerHTML = 
            regularAgents.length ?
            regularAgents.map(agent => generateAgentCard(agent)).join('') :
            '<p class="no-results">Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆÙƒÙ„Ø§Ø¡ Ø§Ø¹ØªÙŠØ§Ø¯ÙŠÙŠÙ† Ø­Ø§Ù„ÙŠØ§Ù‹</p>';

    } catch (error) {
    /* logs suppressed: error loading agents */
        showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡', 'error');
    }
}

function generateAgentCard(agent) {
    return `
        <div class="agent-card">
            <div class="agent-avatar">
                ${agent.avatar_url ? 
                    `<img src="${agent.avatar_url}" alt="${agent.name}">` : 
                    `<div class="avatar-placeholder"><i class="fas fa-user"></i></div>`
                }
            </div>
            <div class="agent-info">
                <h3>${agent.name}</h3>
                <span class="classification-badge classification-${agent.classification.toLowerCase()}">${agent.classification}</span>
                <div class="stats">
                    <div class="stat"><i class="fas fa-users"></i> ${agent.clients_count} Ø¹Ù…ÙŠÙ„</div>
                    <div class="stat"><i class="fas fa-trophy"></i> ${agent.competitions_count} Ù…Ø³Ø§Ø¨Ù‚Ø©</div>
                    ${agent.is_exclusive ? '<div class="exclusive-badge"><i class="fas fa-star"></i> Ø­ØµØ±ÙŠ</div>' : ''}
                </div>
            </div>
        </div>
    `;
}

function renderActivityDistributionChart(data, canvasId = 'activityDistributionChart') {
    // data expected as array of { _id: 'TYPE', count: Number }
    const ctx = document.getElementById(canvasId)?.getContext?.('2d');
    if (!ctx) return;

    const labels = (data || []).map(item => item._id || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ');
    const counts = (data || []).map(item => item.count || 0);

    // fallback colors
    const colors = ['#4CAF50', '#2196F3', '#F4A261', '#E91E63', '#9C27B0', '#00BCD4', '#FF9800'];

    // Attempt to use ChartDataLabels if available â€” otherwise, just render a simple pie.
    const config = {
        type: 'pie',
        data: {
            labels: labels,
            datasets: [{
                data: counts,
                backgroundColor: colors,
                borderColor: 'var(--card-bg-color)',
                borderWidth: 2
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' }
            }
        }
    };

    // If ChartDataLabels plugin is present, add a formatter for percentages
    if (window.ChartDataLabels) {
        config.options.plugins.datalabels = {
            color: '#fff',
            font: { weight: 'bold' },
            formatter: (value, ctx) => {
                const sum = ctx.chart.data.datasets[0].data.reduce((a, b) => a + b, 0) || 1;
                const perc = (value / sum) * 100;
                return perc > 5 ? perc.toFixed(0) + '%' : '';
            }
        };
        config.plugins = [ChartDataLabels];
    }

    // eslint-disable-next-line no-new
    new Chart(ctx, config);
}

// == agents.js ==
ï»¿const AGENTS_PER_PAGE = 10;

async function renderManageAgentsPage() {
    // --- NEW: Permission Check ---
    const isSuperAdmin = currentUserProfile?.role === 'super_admin';
    const isAdmin = isSuperAdmin || currentUserProfile?.role === 'admin';

    const appContent = document.getElementById('app-content');
    appContent.innerHTML = `
        <div class="page-header column-header">
            <div class="header-top-row">
                <h1>Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡</h1>
                <div class="header-actions-group">
                    ${isSuperAdmin ? `<button id="delete-all-agents-btn" class="btn-danger"><i class="fas fa-skull-crossbones"></i> Ø­Ø°Ù ÙƒÙ„ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡</button>` : ''}
                    ${isAdmin ? `<button id="bulk-renew-balances-btn" class="btn-renewal"><i class="fas fa-sync-alt"></i> ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø£Ø±ØµØ¯Ø©</button>` : ''}
                    ${isSuperAdmin ? `<button id="bulk-send-balance-btn" class="btn-telegram-bonus"><i class="fas fa-bullhorn"></i> ØªØ¹Ù…ÙŠÙ… Ø§Ù„Ø£Ø±ØµØ¯Ø©</button>` : ''}
                    ${isSuperAdmin ? `<button id="bulk-broadcast-btn" class="btn-telegram-broadcast"><i class="fas fa-microphone-alt"></i> ØªØ¹Ù…ÙŠÙ… Ø¬Ù…Ø§Ø¹ÙŠ</button>` : ''}
                    ${isAdmin ? `<button id="bulk-add-agents-btn" class="btn-secondary"><i class="fas fa-users-cog"></i> Ø¥Ø¶Ø§ÙØ© ÙˆÙƒÙ„Ø§Ø¡ Ø¯ÙØ¹Ø© ÙˆØ§Ø­Ø¯Ø©</button>` : ''}
                    <button id="add-agent-btn" class="btn-primary"><i class="fas fa-plus"></i> Ø¥Ø¶Ø§ÙØ© ÙˆÙƒÙŠÙ„ Ø¬Ø¯ÙŠØ¯</button>
                </div>
            </div>
            <div class="agent-filters">
                <div class="filter-search-container">
                    <input type="search" id="agent-search-input" placeholder="Ø¨Ø­Ø« Ø¨Ø§Ù„Ø§Ø³Ù… Ø£Ùˆ Ø§Ù„Ø±Ù‚Ù…..." autocomplete="off">
                    <i class="fas fa-search"></i>
                    <i class="fas fa-times-circle search-clear-btn" id="agent-search-clear"></i>
                </div>
                <div class="filter-buttons">
                    <button class="filter-btn active" data-filter="all">Ø§Ù„ÙƒÙ„</button>
                    <button class="filter-btn" data-filter="R">R</button>
                    <button class="filter-btn" data-filter="A">A</button>
                    <button class="filter-btn" data-filter="B">B</button>
                    <button class="filter-btn" data-filter="C">C</button>
                </div>
                <div class="sort-container">
                    <label for="agent-sort-select">ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨:</label>
                    <select id="agent-sort-select">
                        <option value="newest">Ø§Ù„Ø£Ø­Ø¯Ø« Ø£ÙˆÙ„Ø§Ù‹</option>
                        <option value="name_asc">Ø£Ø¨Ø¬Ø¯ÙŠ (Ø£ - ÙŠ)</option>
                    </select>
                </div>
            </div>
        </div>
        <div id="agent-table-container"></div>
    `;

    document.getElementById('add-agent-btn').addEventListener('click', () => {
        setActiveNav(null);
        window.location.hash = 'add-agent?returnTo=manage-agents';
    });

    // --- NEW: Add listener for bulk renew balances button ---
    const bulkRenewBtn = document.getElementById('bulk-renew-balances-btn');
    if (bulkRenewBtn) {
        bulkRenewBtn.addEventListener('click', () => {
            handleBulkRenewBalances();
        });
    }

    // --- NEW: Add listener for delete all agents button ---
    const deleteAllBtn = document.getElementById('delete-all-agents-btn');
    if (deleteAllBtn) {
        deleteAllBtn.addEventListener('click', () => {
            handleDeleteAllAgents();
        });
    }
    // ØªØ¹Ø¯ÙŠÙ„: Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ù„Ø¬ Ù„Ø²Ø± Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠ
    const bulkSendBtn = document.getElementById('bulk-send-balance-btn');
    if (bulkSendBtn) {
        bulkSendBtn.addEventListener('click', () => handleBulkSendBalances());
    }

    // --- NEW: Add listener for bulk add agents button ---
    const bulkAddBtn = document.getElementById('bulk-add-agents-btn');
    if (bulkAddBtn) {
        bulkAddBtn.addEventListener('click', renderBulkAddAgentsModal);
    }

    // --- NEW: Add listener for bulk broadcast button ---
    const bulkBroadcastBtn = document.getElementById('bulk-broadcast-btn');
    if (bulkBroadcastBtn) {
        bulkBroadcastBtn.addEventListener('click', handleBulkBroadcast);
    }

    // --- NEW: Attach event listeners once for the entire page ---
    const container = document.getElementById('agent-table-container');
    container.addEventListener('click', (e) => {
        const agentCell = e.target.closest('.table-agent-cell');
        const agentIdText = e.target.closest('.agent-id-text');
        const editBtn = e.target.closest('.edit-btn');
        const deleteBtn = e.target.closest('.delete-btn');
        const link = e.target.closest('a');
        const paginationBtn = e.target.closest('.page-btn');

        // 1. Ù†Ø³Ø® Ø±Ù‚Ù… Ø§Ù„ÙˆÙƒØ§Ù„Ø©
        if (agentIdText) {
            e.stopPropagation();
            const agentIdToCopy = agentIdText.textContent;
            navigator.clipboard.writeText(agentIdToCopy).then(() => showToast(`ØªÙ… Ù†Ø³Ø® Ø§Ù„Ø±Ù‚Ù…: ${agentIdToCopy}`, 'info'));
        }
        // 2. Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø®Ù„ÙŠØ© Ø§Ù„ÙˆÙƒÙŠÙ„ (Ø§Ù„Ø§Ø³Ù…/Ø§Ù„ØµÙˆØ±Ø©)
        else if (agentCell && !editBtn && !deleteBtn && !link) {
            const row = agentCell.closest('tr');
            if (row && row.dataset.agentId) {
                window.location.hash = `profile/${row.dataset.agentId}`;
            }
        }
        // 3. Ø²Ø± Ø§Ù„ØªØ¹Ø¯ÙŠÙ„
        else if (editBtn) {
            const row = editBtn.closest('tr');
            if (row) window.location.hash = `profile/${row.dataset.agentId}/edit`;
        }
        // 4. Ø²Ø± Ø§Ù„Ø­Ø°Ù
        else if (deleteBtn) {
            const row = deleteBtn.closest('tr');
            const agentId = row.dataset.agentId;
            const agentName = row.querySelector('.agent-details')?.textContent || 'ÙˆÙƒÙŠÙ„ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ';
            const currentPage = parseInt(container.querySelector('.page-btn.active')?.dataset.page || '1');

            showConfirmationModal(
                `Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ø§Ù„ÙˆÙƒÙŠÙ„ "<strong>${agentName}</strong>"ØŸ<br><small>Ø³ÙŠØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø¨ÙŠØ§Ù†Ø§ØªÙ‡ Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ø´ÙƒÙ„ Ø¯Ø§Ø¦Ù….</small>`,
                async () => {
                    try {
                        const response = await authedFetch(`/api/agents/${agentId}`, { method: 'DELETE' });
                        if (!response.ok) {
                            const result = await response.json();
                            throw new Error(result.message || 'ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„ÙˆÙƒÙŠÙ„.');
                        }
                        showToast('ØªÙ… Ø­Ø°Ù Ø§Ù„ÙˆÙƒÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                        fetchAndDisplayAgents(currentPage); // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø­Ø°Ù
                    } catch (error) {
                        showToast(`ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„ÙˆÙƒÙŠÙ„: ${error.message}`, 'error');
                    }
                }, { title: 'ØªØ£ÙƒÙŠØ¯ Ø­Ø°Ù Ø§Ù„ÙˆÙƒÙŠÙ„', confirmText: 'Ø­Ø°Ù Ù†Ù‡Ø§Ø¦ÙŠ', confirmClass: 'btn-danger' });
        }
        // 5. Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙ†Ù‚Ù„ Ø¨ÙŠÙ† Ø§Ù„ØµÙØ­Ø§Øª
        else if (paginationBtn && !paginationBtn.disabled) {
            const newPage = paginationBtn.dataset.page;
            if (newPage) fetchAndDisplayAgents(parseInt(newPage));
        }
    });

    setupAgentFilters();
    await fetchAndDisplayAgents(1); // Initial fetch for page 1
}

function setupAgentFilters() {
    const searchInput = document.getElementById('agent-search-input');
    const clearBtn = document.getElementById('agent-search-clear');
    const filterButtons = document.querySelectorAll('.agent-filters .filter-btn');
    const sortSelect = document.getElementById('agent-sort-select');

    if (!searchInput) return;

    const triggerFetch = () => {
        fetchAndDisplayAgents(1); // Always go to page 1 when filters change
    };

    searchInput.addEventListener('input', triggerFetch);

    if (clearBtn) {
        clearBtn.addEventListener('click', () => {
            searchInput.value = '';
            triggerFetch();
            searchInput.focus();
        });
    }

    if (filterButtons.length) {
        filterButtons.forEach(button => {
            button.addEventListener('click', () => {
                filterButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                triggerFetch();
            });
        });
    }

    if (sortSelect) {
        sortSelect.addEventListener('change', triggerFetch);
    }
}

async function fetchAndDisplayAgents(page) {
    const container = document.getElementById('agent-table-container');
    if (!container) return;

    container.innerHTML = '<div class="loader-container"><div class="spinner"></div></div>';

    // Get filter and sort values from the UI
    const searchInput = document.getElementById('agent-search-input');
    const sortSelect = document.getElementById('agent-sort-select');
    const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
    const classificationFilter = document.querySelector('.agent-filters .filter-btn.active')?.dataset.filter || 'all';
    const sortValue = sortSelect ? sortSelect.value : 'newest';

    if (document.getElementById('agent-search-clear')) {
        document.getElementById('agent-search-clear').style.display = searchTerm ? 'block' : 'none';
    }

    try {
        const queryParams = new URLSearchParams({
            page: page,
            limit: AGENTS_PER_PAGE,
            search: searchTerm,
            classification: classificationFilter,
            sort: sortValue
        });

        const response = await authedFetch(`/api/agents?${queryParams.toString()}`);
        if (!response.ok) {
            const errData = await response.json();
            throw new Error(errData.error || 'Failed to fetch data from server.');
        }
        const { data: agents, count } = await response.json();

        displayAgentsPage(agents || [], page, count || 0);
    } catch (error) {
        console.error("Error fetching agents:", error);
        container.innerHTML = `<p class="error">Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡.</p>`;
        return;
    }
}

function displayAgentsPage(paginatedAgents, page, totalCount) {
    const container = document.getElementById('agent-table-container');
    if (!container) return;

    page = parseInt(page);
    const totalPages = Math.ceil(totalCount / AGENTS_PER_PAGE);
    
    const tableHtml = paginatedAgents.length > 0 ? `
        <table class="modern-table">
            <thead>
                <tr>
                    <th>Ø§Ù„ÙˆÙƒÙŠÙ„</th>
                    <th>Ø±Ù‚Ù… Ø§Ù„ÙˆÙƒØ§Ù„Ø©</th>
                    <th>Ø§Ù„ØªØµÙ†ÙŠÙ</th>
                    <th>Ø§Ù„Ù…Ø±ØªØ¨Ø©</th>
                    <th>ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØ¬Ø¯ÙŠØ¯</th>
                    <th>Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØªÙ„Ø¬Ø±Ø§Ù…</th>
                    <th class="actions-column">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</th>
                </tr>
            </thead>
            <tbody>
                ${paginatedAgents.map(agent => {
                    const avatarHtml = agent.avatar_url
                        ? `<img src="${agent.avatar_url}" alt="Avatar" class="avatar-small" loading="lazy">`
                        : `<div class="avatar-placeholder-small"><i class="fas fa-user"></i></div>`;
                    
                    return `
                        <tr data-agent-id="${agent._id}">
                            <td data-label="Ø§Ù„ÙˆÙƒÙŠÙ„">
                                <div class="table-agent-cell" style="cursor: pointer;">
                                    ${avatarHtml}
                                    <div class="agent-details">${agent.name}</div>
                                </div>
                            </td>
                            <td data-label="Ø±Ù‚Ù… Ø§Ù„ÙˆÙƒØ§Ù„Ø©" class="agent-id-text" title="Ù†Ø³Ø® Ø§Ù„Ø±Ù‚Ù…">${agent.agent_id}</td>
                            <td data-label="Ø§Ù„ØªØµÙ†ÙŠÙ"><span class="classification-badge classification-${agent.classification.toLowerCase()}">${agent.classification}</span></td>
                            <td data-label="Ø§Ù„Ù…Ø±ØªØ¨Ø©">${agent.rank || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}</td>
                            <td data-label="ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØ¬Ø¯ÙŠØ¯">${agent.next_renewal_date ? new Date(agent.next_renewal_date).toLocaleDateString('ar-EG-u-nu-latn', { year: 'numeric', month: '2-digit', day: '2-digit' }) : 'Ù„Ø§ ÙŠÙˆØ¬Ø¯'}</td>
                            <td data-label="Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØªÙ„Ø¬Ø±Ø§Ù…">
                                ${agent.telegram_channel_url ? `<a href="${agent.telegram_channel_url}" target="_blank" class="agent-table-link">Ø§Ù„Ù‚Ù†Ø§Ø©</a>` : ''}
                                ${agent.telegram_channel_url && agent.telegram_group_url ? ' | ' : ''}
                                ${agent.telegram_group_url ? `<a href="${agent.telegram_group_url}" target="_blank" class="agent-table-link">Ø§Ù„Ø¬Ø±ÙˆØ¨</a>` : ''}
                            </td>
                            <td class="actions-cell">
                                <button class="btn-secondary edit-btn btn-small"><i class="fas fa-edit"></i> ØªØ¹Ø¯ÙŠÙ„</button>
                                <button class="btn-danger delete-btn btn-small"><i class="fas fa-trash-alt"></i> Ø­Ø°Ù</button>
                            </td>
                        </tr>
                    `;
                }).join('')}
            </tbody>
        </table>
    ` : '<p class="no-results-message">Ù„Ø§ ØªÙˆØ¬Ø¯ ÙˆÙƒÙ„Ø§Ø¡ ØªØ·Ø§Ø¨Ù‚ Ø¨Ø­Ø«Ùƒ Ø£Ùˆ Ø§Ù„ÙÙ„ØªØ± Ø§Ù„Ø­Ø§Ù„ÙŠ.</p>';

    let paginationHtml = '';
    if (totalPages > 1) {
        paginationHtml += '<div class="pagination-container">';
        paginationHtml += `<button class="page-btn" data-page="${page - 1}" ${page === 1 ? 'disabled' : ''}>Ø§Ù„Ø³Ø§Ø¨Ù‚</button>`;
        for (let i = 1; i <= totalPages; i++) {
            paginationHtml += `<button class="page-btn ${i === page ? 'active' : ''}" data-page="${i}">${i}</button>`;
        }
        paginationHtml += `<button class="page-btn" data-page="${page + 1}" ${page >= totalPages ? 'disabled' : ''}>Ø§Ù„ØªØ§Ù„ÙŠ</button>`;
        paginationHtml += '</div>';
    }

    container.innerHTML = `<div class="table-responsive-container">${tableHtml}</div>${paginationHtml}`;

    // The event listener is now attached once in renderManageAgentsPage, so no need to re-attach.
}

// --- NEW: Delete All Agents Feature (Super Admin only) ---
async function handleDeleteAllAgents() {
    // --- ØªØ¹Ø¯ÙŠÙ„: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ ---
    const modalContent = `
        <p class="warning-text" style="font-size: 1.1em;">
            <i class="fas fa-exclamation-triangle"></i> <strong>ØªØ­Ø°ÙŠØ± Ø®Ø·ÙŠØ±!</strong> 
        </p>
        <p>Ø£Ù†Øª Ø¹Ù„Ù‰ ÙˆØ´Ùƒ Ø­Ø°Ù <strong>Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡</strong> Ù…Ù† Ø§Ù„Ù†Ø¸Ø§Ù… Ø¨Ø´ÙƒÙ„ Ù†Ù‡Ø§Ø¦ÙŠ. Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡ ÙˆØ³ÙŠØ²ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø¨ÙŠØ§Ù†Ø§ØªÙ‡Ù… ÙˆÙ…Ø³Ø§Ø¨Ù‚Ø§ØªÙ‡Ù… ÙˆØ³Ø¬Ù„Ø§ØªÙ‡Ù….</p>
        <p style="margin-top: 15px;">Ù„Ù„ØªØ£ÙƒÙŠØ¯ØŒ ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© ÙƒÙ„Ù…Ø© "<strong>Ø­Ø°Ù</strong>" ÙÙŠ Ø§Ù„Ø­Ù‚Ù„ Ø£Ø¯Ù†Ø§Ù‡:</p>
        <div class="form-group" style="margin-top: 10px;">
            <input type="text" id="delete-confirmation-input" class="modal-input" autocomplete="off">
        </div>
    `;
    showConfirmationModal(
        modalContent,
        async () => {
            const response = await authedFetch('/api/agents/delete-all', { method: 'DELETE' });
            if (response.ok) {
                showToast('ØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                await fetchAndDisplayAgents(1);
            } else {
                const result = await response.json();
                showToast(result.message || 'ÙØ´Ù„ Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡.', 'error');
            }
        },
        {
            title: 'ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ',
            confirmText: 'Ù†Ø¹Ù…ØŒ Ø£Ø­Ø°Ù Ø§Ù„ÙƒÙ„',
            confirmClass: 'btn-danger',
            onRender: (modal) => {
                const confirmBtn = modal.querySelector('#confirm-btn');
                const confirmationInput = modal.querySelector('#delete-confirmation-input');
                confirmBtn.disabled = true; // Disable by default

                confirmationInput.addEventListener('input', () => {
                    if (confirmationInput.value.trim() === 'Ø­Ø°Ù') {
                        confirmBtn.disabled = false;
                        confirmBtn.classList.add('pulse-animation');
                    } else {
                        confirmBtn.disabled = true;
                        confirmBtn.classList.remove('pulse-animation');
                    }
                });
            }
        }
    );
}

// --- NEW: Bulk Renew Balances Feature ---
async function handleBulkRenewBalances() {
    try {
        // --- NEW: Fetch all agents first to get a count and show progress ---
        showLoader('Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡...');
        const response = await authedFetch('/api/agents?limit=10000&select=name'); // Fetch all agents
        if (!response.ok) {
            throw new Error('ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ù„Ù„Ø¨Ø¯Ø¡ ÙÙŠ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ¬Ø¯ÙŠØ¯.');
        }
        const { data: agents } = await response.json();
        hideLoader();

        if (!agents || agents.length === 0) {
            showToast('Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆÙƒÙ„Ø§Ø¡ Ù†Ø´Ø·ÙˆÙ† Ù„ØªØ¬Ø¯ÙŠØ¯ Ø£Ø±ØµØ¯ØªÙ‡Ù….', 'info');
            return;
        }

        const agentCount = agents.length;

        showConfirmationModal(
            `Ø³ÙŠØªÙ… ØªØ¬Ø¯ÙŠØ¯ Ø£Ø±ØµØ¯Ø© <strong>${agentCount}</strong> ÙˆÙƒÙŠÙ„. Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù‚Ø¯ ØªØ³ØªØºØ±Ù‚ Ø¨Ø¹Ø¶ Ø§Ù„ÙˆÙ‚Øª. Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŸ`,
            async () => {
                console.log('[Bulk Renew] Starting client-side bulk renewal process.');
                const progressModalOverlay = showProgressModal(
                    'ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠ',
                    `
                    <div class="update-progress-container">
                        <i class="fas fa-sync-alt fa-spin update-icon"></i>
                        <h3 id="bulk-renew-status-text">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©...</h3>
                        <div class="progress-bar-outer">
                            <div id="bulk-renew-progress-bar-inner" class="progress-bar-inner"></div>
                        </div>
                    </div>
                    `
                );

                const statusText = document.getElementById('bulk-renew-status-text');
                const progressBar = document.getElementById('bulk-renew-progress-bar-inner');
                const updateIcon = progressModalOverlay.querySelector('.update-icon');
                let processedCount = 0;
                let errorCount = 0;

                for (let i = 0; i < agents.length; i++) {
                    const agent = agents[i];
                    processedCount++;
                    const progressPercentage = Math.round((processedCount / agentCount) * 100);

                    statusText.innerHTML = `(${processedCount}/${agentCount}) Ø¬Ø§Ø±ÙŠ ØªØ¬Ø¯ÙŠØ¯ Ø±ØµÙŠØ¯: <strong>${agent.name}</strong>`;
                    progressBar.style.width = `${progressPercentage}%`;

                    try {
                        const renewResponse = await authedFetch(`/api/agents/${agent._id}/renew`, { method: 'POST' });
                        if (!renewResponse.ok) {
                            errorCount++;
                            console.error(`Failed to renew balance for agent ${agent.name}`);
                        }
                        // A small delay to prevent overwhelming the server and to make the UI updates visible
                        await new Promise(resolve => setTimeout(resolve, 500));
                    } catch (err) {
                        errorCount++;
                        console.error(`Error renewing balance for agent ${agent.name}:`, err);
                    }
                }

                progressBar.style.width = '100%';
                updateIcon.className = errorCount > 0 ? 'fas fa-exclamation-triangle update-icon' : 'fas fa-check-circle update-icon';
                progressBar.style.backgroundColor = errorCount > 0 ? 'var(--warning-color)' : 'var(--success-color)';
                statusText.innerHTML = `Ø§ÙƒØªÙ…Ù„ Ø§Ù„ØªØ¬Ø¯ÙŠØ¯.<br>ØªÙ…Øª Ù…Ø¹Ø§Ù„Ø¬Ø© <strong>${processedCount}</strong> ÙˆÙƒÙŠÙ„.<br>${errorCount > 0 ? `(Ù…Ø¹ ÙˆØ¬ÙˆØ¯ <strong>${errorCount}</strong> Ø£Ø®Ø·Ø§Ø¡)` : ''}`;

                console.log(`[Bulk Renew] Client-side process finished. Processed: ${processedCount}, Errors: ${errorCount}`);
                await fetchAndDisplayAgents(1); // Refresh the agents list

                setTimeout(() => {
                    if (progressModalOverlay) progressModalOverlay.remove();
                }, 4000);
            },
            { title: 'ØªØ£ÙƒÙŠØ¯ ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø£Ø±ØµØ¯Ø©', confirmText: 'Ù†Ø¹Ù…ØŒ Ø¬Ø¯Ø¯ Ø§Ù„Ø¢Ù†', confirmClass: 'btn-renewal' }
        );

    } catch (error) {
        hideLoader();
        showToast(error.message, 'error');
        console.error('[Bulk Renew] Error setting up bulk renewal:', error);
    }
}

async function handleMarkAllTasksComplete() {
    // 1. Ø¬Ù„Ø¨ ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„ÙŠÙˆÙ…
    // --- ØªØ¹Ø¯ÙŠÙ„: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¬Ù„Ø¨ ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„ÙŠÙˆÙ… ---
    const response = await authedFetch('/api/agents?for_tasks=today&select=_id');
    if (!response.ok) {
        showToast('ÙØ´Ù„ Ø¬Ù„Ø¨ Ù‚Ø§Ø¦Ù…Ø© ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„ÙŠÙˆÙ….', 'error');
        return;
    }
    const { data: agentsForToday } = await response.json();
    
    if (!agentsForToday || agentsForToday.length === 0) {
        showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù‡Ø§Ù… Ù…Ø¬Ø¯ÙˆÙ„Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„ÙŠÙˆÙ….', 'info');
        return;
    }
    // 2. Ø¥Ø¸Ù‡Ø§Ø± Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ£ÙƒÙŠØ¯
    showConfirmationModal(
        `Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† ØªÙ…ÙŠÙŠØ² Ø¬Ù…ÙŠØ¹ Ù…Ù‡Ø§Ù… Ø§Ù„ÙŠÙˆÙ… (${agentsForToday.length} ÙˆÙƒÙŠÙ„) ÙƒÙ…ÙƒØªÙ…Ù„Ø©ØŸ`,
        async () => {
            const todayStr = new Date().toISOString().split('T')[0];
            const agentIds = agentsForToday.map(agent => agent._id);

            // --- ØªØ¹Ø¯ÙŠÙ„: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù‡Ø§Ù… ---
            const completeResponse = await authedFetch('/api/tasks/bulk-complete', {
                method: 'POST',
                body: JSON.stringify({ agentIds, date: todayStr })
            });

            if (!completeResponse.ok) {
                showToast('ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù‡Ø§Ù… Ø¨Ø´ÙƒÙ„ Ø¬Ù…Ø§Ø¹ÙŠ.', 'error');
            } else {
                showToast('ØªÙ… ØªÙ…ÙŠÙŠØ² Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù‡Ø§Ù… ÙƒÙ…ÙƒØªÙ…Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                // The tasks page is not currently rendered, so no need to refresh it.
            }
        }, { title: 'ØªØ£ÙƒÙŠØ¯ Ø¥ÙƒÙ…Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù‡Ø§Ù…', confirmText: 'Ù†Ø¹Ù…ØŒ Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„ÙƒÙ„', confirmClass: 'btn-primary' }
    );
}

async function handleBulkSendBalances() {
    // ØªØ¹Ø¯ÙŠÙ„: Ø¬Ù„Ø¨ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ù…Ø¤Ù‡Ù„ÙŠÙ† Ù…Ù† Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
    const response = await authedFetch('/api/agents?eligibleForBalance=true');
    if (!response.ok) {
        showToast('ÙØ´Ù„ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ù…Ø¤Ù‡Ù„ÙŠÙ†.', 'error');
        return;
    }
    const { data: eligibleAgents, error: fetchError } = await response.json();

    if (fetchError) {
        showToast('ÙØ´Ù„ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ù…Ø¤Ù‡Ù„ÙŠÙ†.', 'error');
        return;
    }

    const agentCount = eligibleAgents.length;

    if (agentCount === 0) {
        showToast('Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆÙƒÙ„Ø§Ø¡ Ù…Ø¤Ù‡Ù„ÙˆÙ† (Ù„Ø¯ÙŠÙ‡Ù… Ù…Ø¹Ø±Ù Ø¯Ø±Ø¯Ø´Ø© ÙˆØ±ØµÙŠØ¯ Ù…ØªØ§Ø­) Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ¹Ù…ÙŠÙ….', 'info');
        return;
    }

    const modalContent = `
        <p>Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ„ÙŠØ´Ø© Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø­ Ø¥Ù„Ù‰ <strong>${agentCount}</strong> ÙˆÙƒÙŠÙ„ Ù…Ø¤Ù‡Ù„.</p>
        <p>Ø³ÙŠØªÙ… ØªØ¬Ù‡ÙŠØ² Ø±Ø³Ø§Ù„Ø© ÙØ±ÙŠØ¯Ø© Ù„ÙƒÙ„ ÙˆÙƒÙŠÙ„ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ØªÙØ§ØµÙŠÙ„ Ø±ØµÙŠØ¯Ù‡ ÙˆØ¨ÙˆÙ†Øµ Ø§Ù„Ø¥ÙŠØ¯Ø§Ø¹ Ø§Ù„Ø®Ø§Øµ Ø¨Ù‡.</p>
        <p class="warning-text" style="margin-top: 15px;"><i class="fas fa-exclamation-triangle"></i> Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŸ</p>
    `;

    showConfirmationModal(
        modalContent,
        async () => {
            showBulkSendProgressModal(agentCount);

            let successCount = 0;
            let errorCount = 0;
            const progressBar = document.getElementById('bulk-send-progress-bar-inner');
            const statusText = document.getElementById('bulk-send-status-text');
            const renewalPeriodMap = {
                'weekly': 'Ø£Ø³Ø¨ÙˆØ¹ÙŠ',
                'biweekly': 'ÙƒÙ„ Ø£Ø³Ø¨ÙˆØ¹ÙŠÙ†',
                'monthly': 'Ø´Ù‡Ø±ÙŠ'
            };

            for (let i = 0; i < eligibleAgents.length; i++) {
                const agent = eligibleAgents[i];
                
                // --- FIX: Improved message construction logic ---
                const renewalValue = (agent.renewal_period && agent.renewal_period !== 'none') 
                    ? (renewalPeriodMap[agent.renewal_period] || '')
                    : '';

                let benefitsText = '';
                if ((agent.remaining_balance || 0) > 0) {
                    benefitsText += `ğŸ’° <b>Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ:</b> <code>${agent.remaining_balance}$</code>\n`;
                }
                if ((agent.remaining_deposit_bonus || 0) > 0) {
                    benefitsText += `ğŸ <b>Ø¨ÙˆÙ†Øµ Ø§ÙŠØ¯Ø§Ø¹:</b> <code>${agent.remaining_deposit_bonus}</code> Ù…Ø±Ø§Øª Ø¨Ù†Ø³Ø¨Ø© <code>${agent.deposit_bonus_percentage || 0}%</code>\n`;
                }

                const clicheText = `<b>Ø¯Ù…Øª Ø¨Ø®ÙŠØ± Ø´Ø±ÙŠÙƒÙ†Ø§ Ø§Ù„Ø¹Ø²ÙŠØ² ${agent.name}</b> ...\n\nÙŠØ³Ø±Ù†Ø§ Ø§Ù† Ù†Ø­ÙŠØ·Ùƒ Ø¹Ù„Ù…Ø§ Ø¨Ø£Ù† Ø­Ø¶Ø±ØªÙƒ ÙƒÙˆÙƒÙŠÙ„ Ù„Ø¯Ù‰ Ø´Ø±ÙƒØ© Ø§Ù†Ø²Ùˆ ØªØªÙ…ØªØ¹ Ø¨Ø±ØµÙŠØ¯ Ù…Ø³Ø§Ø¨Ù‚Ø§Øª:\n${renewalValue ? `(<b>${renewalValue}</b>):\n\n` : ''}${benefitsText.trim()}\n\nØ¨Ø§Ù…ÙƒØ§Ù†Ùƒ Ø§Ù„Ø§Ø³ØªÙØ§Ø¯Ø© Ù…Ù†Ù‡ Ù…Ù† Ø®Ù„Ø§Ù„ Ø§Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ø³Ø¨ÙˆØ¹ÙŠØ© Ù„ØªÙ†Ù…ÙŠØ© ÙˆØªØ·ÙˆÙŠØ± Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø§Ù„ØªØ§Ø¨Ø¹ÙŠÙ† Ù„Ù„ÙˆÙƒØ§Ù„Ø©.\n\nÙ‡Ù„ ØªØ±ØºØ¨ Ø¨Ø§Ø±Ø³Ø§Ù„ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù„Ø­Ø¶Ø±ØªÙƒØŸ`;

                // --- FIX: Use authedFetch for authenticated requests ---
                try {
                    if (!agent.telegram_chat_id) throw new Error('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø¹Ø±Ù Ù…Ø¬Ù…ÙˆØ¹Ø© ØªÙ„Ø¬Ø±Ø§Ù… Ù„Ù„ÙˆÙƒÙŠÙ„.');
                    const response = await authedFetch('/api/post-announcement', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json;charset=UTF-8' },
                        body: JSON.stringify({ message: clicheText, chatId: agent.telegram_chat_id })
                    });

                    if (!response.ok) errorCount++;
                    else successCount++;

                } catch (e) {
                    errorCount++;
                }

                const progress = Math.round(((i + 1) / agentCount) * 100);
                progressBar.style.width = `${progress}%`;
                statusText.innerHTML = `Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ø±ØµØ¯Ø©... (${i + 1} / ${agentCount})<br>Ù†Ø¬Ø­: ${successCount} | ÙØ´Ù„: ${errorCount}`;
                // Ø¥ØµÙ„Ø§Ø­: Ù†Ù‚Ù„ Ø§Ù„ØªØ£Ø®ÙŠØ± Ø§Ù„Ø²Ù…Ù†ÙŠ Ø¥Ù„Ù‰ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø­Ù„Ù‚Ø© Ù„ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
                if (i < eligibleAgents.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 400)); // 400ms delay
                }
            } // Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø­Ù„Ù‚Ø© for

            // Update modal with final result
            statusText.innerHTML = `Ø§ÙƒØªÙ…Ù„ ØªØ¹Ù…ÙŠÙ… Ø§Ù„Ø£Ø±ØµØ¯Ø©.<br><strong>${successCount}</strong> Ø±Ø³Ø§Ù„Ø© Ù†Ø§Ø¬Ø­Ø© | <strong>${errorCount}</strong> Ø±Ø³Ø§Ù„Ø© ÙØ§Ø´Ù„Ø©.`;
            progressBar.style.backgroundColor = errorCount > 0 ? 'var(--danger-color)' : 'var(--success-color)';
            document.querySelector('.modal-no-actions .update-icon').className = 'fas fa-check-circle update-icon';
            await logAgentActivity(null, 'BULK_BALANCE_SENT', `ØªÙ… ØªØ¹Ù…ÙŠÙ… Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø¥Ù„Ù‰ ${successCount} ÙˆÙƒÙŠÙ„ (ÙØ´Ù„ ${errorCount}).`);

            // --- ØªØ¹Ø¯ÙŠÙ„: Ø¥Ø®ÙØ§Ø¡ Ù†Ø§ÙØ°Ø© Ø§Ù„ØªÙ‚Ø¯Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¨Ø¹Ø¯ 3 Ø«ÙˆØ§Ù†Ù ---
            setTimeout(() => {
                // Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ù…Ù†Ø¨Ø«Ù‚Ø© Ø§Ù„Ù†Ø´Ø·Ø© ÙˆÙ‚Ù… Ø¨Ø¥Ø²Ø§Ù„ØªÙ‡Ø§
                const modalOverlay = document.querySelector('.modal-overlay');
                if (modalOverlay) {
                    modalOverlay.remove();
                }
            }, 3000); // Ø¥ØºÙ„Ø§Ù‚ Ø¨Ø¹Ø¯ 3 Ø«ÙˆØ§Ù†Ù
        }, {
            title: 'ØªØ¹Ù…ÙŠÙ… Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø§Ù„Ù…ØªØ§Ø­Ø©',
            confirmText: 'Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¢Ù†',
            confirmClass: 'btn-telegram-bonus',
            cancelText: 'Ø¥Ù„ØºØ§Ø¡',
            modalClass: 'modal-wide'
        }
    );
}

// --- NEW: Bulk Broadcast Feature (Super Admin only) ---
async function handleBulkBroadcast() {
    // Step 1: Show a modal to write the message
    const messageModalContent = `
        <p>Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙŠ ØªÙˆØ¯ Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ù…Ø¤Ù‡Ù„ÙŠÙ†.</p>
        <p><small>Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙÙ‚Ø· Ù„Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ø°ÙŠÙ† Ù„Ø¯ÙŠÙ‡Ù… Ù…Ø¹Ø±Ù Ø¯Ø±Ø¯Ø´Ø© ÙˆØ§Ø³Ù… Ù…Ø¬Ù…ÙˆØ¹Ø© ØµØ­ÙŠØ­ÙŠÙ†.</small></p>
        <div class="form-group" style="margin-top: 15px;">
            <textarea id="broadcast-message-input" class="modal-textarea-preview" rows="10" placeholder="Ø§ÙƒØªØ¨ Ø±Ø³Ø§Ù„ØªÙƒ Ù‡Ù†Ø§..."></textarea>
        </div>
    `;

    showConfirmationModal(
        messageModalContent,
        async () => {
            const message = document.getElementById('broadcast-message-input').value.trim();
            if (!message) {
                showToast('Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ÙØ§Ø±ØºØ©.', 'error');
                return;
            }

            // Step 2: Fetch eligible agents to get the count
            try {
                showLoader();
                const response = await authedFetch('/api/agents?eligibleForBroadcast=true&limit=5000&select=_id name agent_id telegram_chat_id');
                if (!response.ok) throw new Error('ÙØ´Ù„ Ø¬Ù„Ø¨ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡.');
                
                const { data: eligibleAgents } = await response.json();
                hideLoader();

                console.log('Eligible agents for broadcast:', eligibleAgents); // DEBUG

                if (!eligibleAgents || eligibleAgents.length === 0) {
                    showToast('Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆÙƒÙ„Ø§Ø¡ Ù…Ø¤Ù‡Ù„ÙˆÙ† Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ¹Ù…ÙŠÙ… Ù„Ù‡Ù….', 'info');
                    return;
                }

                // Step 3: Show final confirmation and then start sending
                showConfirmationModal(
                    `Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„ØªÙƒ Ø¥Ù„Ù‰ <strong>${eligibleAgents.length}</strong> ÙˆÙƒÙŠÙ„. Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŸ`,
                    async () => {
                        showBulkSendProgressModal(eligibleAgents.length, 'ØªØ¹Ù…ÙŠÙ… Ø¬Ù…Ø§Ø¹ÙŠ');

                        let successCount = 0;
                        let errorCount = 0;
                        const failedAgents = [];
                        const progressBar = document.getElementById('bulk-send-progress-bar-inner');
                        const statusText = document.getElementById('bulk-send-status-text');

                        for (let i = 0; i < eligibleAgents.length; i++) {
                            const agent = eligibleAgents[i];
                            try {
                                if (!agent.telegram_chat_id) throw new Error('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø¹Ø±Ù Ù…Ø¬Ù…ÙˆØ¹Ø© ØªÙ„Ø¬Ø±Ø§Ù… Ù„Ù„ÙˆÙƒÙŠÙ„.');
                                const sendResponse = await authedFetch('/api/post-announcement', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json;charset=UTF-8' },
                                    body: JSON.stringify({ message: message, chatId: agent.telegram_chat_id })
                                });
                                if (!sendResponse.ok) {
                                    const errorData = await sendResponse.json();
                                    const reason = translateTelegramError(errorData.telegram_error || errorData.message);
                                    throw new Error(reason);
                                }
                                successCount++;
                            } catch (e) {
                                errorCount++;
                                const errorMessage = e.message;
                                failedAgents.push({ name: agent.name, reason: errorMessage });
                                console.error(`Failed to send broadcast to agent ${agent.name} (${agent.agent_id}): ${errorMessage}`);
                            }

                            const progress = Math.round(((i + 1) / eligibleAgents.length) * 100);
                            progressBar.style.width = `${progress}%`;
                            statusText.innerHTML = `Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„... (${i + 1} / ${eligibleAgents.length})<br>Ù†Ø¬Ø­: ${successCount} | ÙØ´Ù„: ${errorCount}`;
                            
                            // Add a small delay between messages to avoid rate limiting
                            if (i < eligibleAgents.length - 1) {
                                await new Promise(resolve => setTimeout(resolve, 300)); // 300ms delay
                            }
                        }

                        // Final update to progress modal
                        let finalMessage = `Ø§ÙƒØªÙ…Ù„ Ø§Ù„ØªØ¹Ù…ÙŠÙ….<br><strong>${successCount}</strong> Ø±Ø³Ø§Ù„Ø© Ù†Ø§Ø¬Ø­Ø© | <strong>${errorCount}</strong> Ø±Ø³Ø§Ù„Ø© ÙØ§Ø´Ù„Ø©.`;
                        if (errorCount > 0) {
                            finalMessage += `<br><br><strong>Ø§Ù„Ø£Ø®Ø·Ø§Ø¡:</strong><ul class="error-list">`;
                            failedAgents.forEach(fail => {
                                finalMessage += `<li><strong>${fail.name}:</strong> ${fail.reason}</li>`;
                            });
                            finalMessage += `</ul>`;
                        }
                        statusText.innerHTML = finalMessage;
                        progressBar.style.backgroundColor = errorCount > 0 ? 'var(--danger-color)' : 'var(--success-color)';
                        document.querySelector('.modal-no-actions .update-icon').className = 'fas fa-check-circle update-icon';
                        
                        // Log the activity
                        await logAgentActivity(currentUserProfile?._id, null, 'BULK_BROADCAST', `ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ØªØ¹Ù…ÙŠÙ… Ø¬Ù…Ø§Ø¹ÙŠ Ø¥Ù„Ù‰ ${successCount} ÙˆÙƒÙŠÙ„ (ÙØ´Ù„ ${errorCount}).`);

                        setTimeout(() => {
                            const modalOverlay = document.querySelector('.modal-overlay');
                            if (modalOverlay) modalOverlay.remove();
                        }, 4000 + (errorCount * 500)); // Keep modal open a bit longer if there are errors to read
                    },
                    { title: 'ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠ', confirmText: 'Ù†Ø¹Ù…ØŒ Ø£Ø±Ø³Ù„ Ø§Ù„Ø¢Ù†', confirmClass: 'btn-telegram-broadcast' }
                );
            } catch (error) {
                hideLoader();
                showToast(error.message, 'error');
            }
        },
        {
            title: 'Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø³Ø§Ù„Ø© ØªØ¹Ù…ÙŠÙ… Ø¬Ù…Ø§Ø¹ÙŠ',
            confirmText: 'Ù…ØªØ§Ø¨Ø¹Ø©',
            confirmClass: 'btn-primary',
            modalClass: 'modal-wide'
        }
    );
}

function showBulkSendProgressModal(total) {
    const modalContent = `
        <div class="update-progress-container">
            <i class="fas fa-paper-plane update-icon"></i>
            <h3 id="bulk-send-status-text">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ù„Ø¥Ø±Ø³Ø§Ù„ ${total} Ø±Ø³Ø§Ù„Ø©...</h3>
            <div class="progress-bar-outer">
                <div id="bulk-send-progress-bar-inner" class="progress-bar-inner"></div>
            </div>
        </div>
    `;
    showConfirmationModal(modalContent, null, {
        title: 'Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠ',
        showCancel: false,
        showConfirm: false,
        modalClass: 'modal-no-actions'
    });
}

async function renderMiniCalendar() {
    const wrapper = document.getElementById('tasks-calendar-wrapper');
    if (!wrapper) return;

    wrapper.innerHTML = `
        <div class="page-header" style="padding: 0; border: none;">
            <div class="header-top-row">
                <h2>Ø§Ù„ØªÙ‚ÙˆÙŠÙ…</h2>
            </div>
        </div>
        <div id="mini-calendar-container"></div>
    `;

    const calendarContainer = document.getElementById('mini-calendar-container');
    const today = new Date();
    const month = today.getMonth();


    const year = today.getFullYear();

    const firstDay = new Date(year, month, 1).getDay();
    const daysInMonth = new Date(year, month + 1, 0).getDate();

    let calendarHtml = `
        <div class="mini-calendar-header">
            <span class="month-year">${today.toLocaleDateString('ar-EG', { month: 'long', year: 'numeric' })}</span>
        </div>
        <div class="mini-calendar-grid">
            ${['Ø­', 'Ù†', 'Ø«', 'Ø±', 'Ø®', 'Ø¬', 'Ø³'].map(day => `<div class="day-name">${day}</div>`).join('')}
    `;

    // Add empty cells for the first day of the week
    for (let i = 0; i < firstDay; i++) {
        calendarHtml += '<div></div>';
    }

    // Add days of the month
    for (let day = 1; day <= daysInMonth; day++) {
        const isToday = day === today.getDate();
        calendarHtml += `<div class="day-cell ${isToday ? 'today' : ''}">${day}</div>`;
    }

    calendarHtml += '</div>';
    calendarContainer.innerHTML = calendarHtml;
}

function generateAgentCard(agent) {
    return `
        <div class="agent-card">
            <div class="agent-avatar">
                ${agent.avatar_url ? 
                    `<img src="${agent.avatar_url}" alt="${agent.name}">` : 
                    `<div class="avatar-placeholder"><i class="fas fa-user"></i></div>`
                }
            </div>
            <div class="agent-info">
                <h3>${agent.name}</h3>
                <span class="classification-badge classification-${agent.classification.toLowerCase()}">${agent.classification}</span>
                ${agent.is_exclusive ? '<div class="exclusive-badge"><i class="fas fa-star"></i> Ø­ØµØ±ÙŠ</div>' : ''}
            </div>
        </div>
    `;
}


// == competitions.js ==
// --- Main Router for Competitions/Templates Section ---
const COMPETITIONS_PER_PAGE = 10; // Changed to 10 for consistency
let competitionListCountdownInterval = null; // For the main list countdown
let selectedCompetitionIds = []; // For bulk actions


async function renderCompetitionsPage() {
    const hash = window.location.hash;
    const urlParams = new URLSearchParams(hash.split('?')[1]);
    const agentId = urlParams.get('agentId');

    if (hash.startsWith('#competitions/new')) {
        await renderCompetitionCreatePage(agentId);
    } else if (hash.startsWith('#competitions/edit/')) {
        const compId = hash.split('/')[2];
        await renderCompetitionEditForm(compId);
    } else if (hash.startsWith('#archived-competitions')) {
        await renderArchivedCompetitionsPage();
    } else {
        // Default to #competitions
        await renderCompetitionManagementPage();
    }

    // Cleanup timer when navigating away
    window.addEventListener('hashchange', () => {
        if (competitionListCountdownInterval) clearInterval(competitionListCountdownInterval);
    });
}

// --- 0. All Competitions List Page (New Default) ---
async function renderCompetitionManagementPage() {
    const appContent = document.getElementById('app-content');
    // --- NEW: Permission Check ---
    const isSuperAdmin = currentUserProfile?.role === 'super_admin';
    const isAdmin = isSuperAdmin || currentUserProfile?.role === 'admin';
    const compsPerm = currentUserProfile?.permissions?.competitions?.manage_comps || 'none';
    const canView = isAdmin || compsPerm === 'full' || compsPerm === 'view';
    if (!canView) {
        appContent.innerHTML = `
            <div class="access-denied-container">
                <i class="fas fa-lock"></i>
                <h2>Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© ÙˆØµÙˆÙ„</h2>
                <p>Ø£Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø¯ÙŠØ±.</p>
            </div>`;
        return;
    }

    const canEdit = isAdmin || compsPerm === 'full';
    selectedCompetitionIds = []; // Reset selection on page render
    appContent.innerHTML = `
        <div class="page-header column-header">
            <div class="header-top-row">
                <h1>Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©</h1>
            </div>
            <div class="filters-container">
                <div class="filter-search-container">
                    <input type="search" id="competition-search-input" placeholder="Ø¨Ø­Ø« Ø¨Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø£Ùˆ Ø§Ù„ÙˆÙƒÙŠÙ„..." autocomplete="off">
                    <i class="fas fa-search"></i>
                    <i class="fas fa-times-circle search-clear-btn" id="competition-search-clear"></i>
                </div>
                <div class="filter-controls">
                    <div class="filter-group">
                        <label class="filter-label">ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„Ø­Ø§Ù„Ø©</label>
                        <div class="filter-buttons" data-filter-group="status">
                            <button class="filter-btn active" data-filter="all">Ø§Ù„ÙƒÙ„</button>
                            <button class="filter-btn" data-filter="active">Ù†Ø´Ø·Ø©</button>
                            <button class="filter-btn" data-filter="inactive">ØºÙŠØ± Ù†Ø´Ø·Ø©</button>
                        </div>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„ØªØµÙ†ÙŠÙ</label>
                        <div class="filter-buttons" data-filter-group="classification">
                            <button class="filter-btn active" data-filter="all">Ø§Ù„ÙƒÙ„</button>
                            <button class="filter-btn" data-filter="R">R</button>
                            <button class="filter-btn" data-filter="A">A</button>
                            <button class="filter-btn" data-filter="B">B</button>
                            <button class="filter-btn" data-filter="C">C</button>
                        </div>
                    </div>
                </div>
                <div class="sort-container">
                    <label for="competition-sort-select">ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨:</label>
                    <select id="competition-sort-select">
                        <option value="newest">Ø§Ù„Ø£Ø­Ø¯Ø« Ø£ÙˆÙ„Ø§Ù‹</option>
                        <option value="name_asc">Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© (Ø£ - ÙŠ)</option>
                        <option value="agent_asc">Ø§Ø³Ù… Ø§Ù„ÙˆÙƒÙŠÙ„ (Ø£ - ÙŠ)</option>
                    </select>
                </div>
            </div>
        </div>
        <div id="bulk-action-bar" class="bulk-action-bar">
            <span id="bulk-action-count">0 Ø¹Ù†ØµØ± Ù…Ø­Ø¯Ø¯</span>
            ${canEdit ? `
                <div class="bulk-actions">
                    <button id="bulk-deactivate-btn" class="btn-secondary"><i class="fas fa-power-off"></i> ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ù…Ø­Ø¯Ø¯</button>
                    <button id="bulk-delete-btn" class="btn-danger"><i class="fas fa-trash-alt"></i> Ø­Ø°Ù Ø§Ù„Ù…Ø­Ø¯Ø¯</button>
                </div>
            ` : ''}
        </div>
        <div id="competitions-list-container"></div>
    `;

    const container = document.getElementById('competitions-list-container');

    // Use event delegation for delete buttons
    container.addEventListener('click', async (e) => { // Listen on a parent that persists
        if (!canEdit && (e.target.closest('.delete-competition-btn') || e.target.closest('#bulk-deactivate-btn') || e.target.closest('#bulk-delete-btn'))) {
            showToast('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡.', 'error');
            return;
        }
         const deleteBtn = e.target.closest('.delete-competition-btn');
        if (deleteBtn && canEdit) {
            const id = deleteBtn.dataset.id;
            if (!id) return;
            showConfirmationModal(
                'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©ØŸ<br><small>Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡.</small>',
                async () => {
                    const response = await authedFetch(`/api/competitions/${id}`, { method: 'DELETE' });
                    if (!response.ok) {
                        const result = await response.json();
                        showToast(`ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©: ${result.message}`, 'error');
                    } else {
                        showToast('ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                        await fetchAndDisplayCompetitions(1); // Refetch from server
                    }
                }, {
                    title: 'ØªØ£ÙƒÙŠØ¯ Ø­Ø°Ù Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©',
                    confirmText: 'Ø­Ø°Ù',
                    confirmClass: 'btn-danger'
                });
        }
    });

    // Separate listener for status toggle to avoid complexity
    container.addEventListener('change', async (e) => {
        const statusToggle = e.target.closest('.competition-status-toggle');
        if (statusToggle) {
            if (!canEdit) {
                showToast('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„ØªØºÙŠÙŠØ± Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©.', 'error');
                statusToggle.checked = !statusToggle.checked; // Revert UI
                return;
            }
            const id = statusToggle.dataset.id;
            const isActive = statusToggle.checked;

            const response = await authedFetch(`/api/competitions/${id}`, {
                method: 'PUT',
                body: JSON.stringify({ is_active: isActive })
            });
            if (!response.ok) {
                showToast('ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©.', 'error');
                statusToggle.checked = !isActive; // Revert UI on error
            } else {
                showToast(`ØªÙ… ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¥Ù„Ù‰ "${isActive ? 'Ù†Ø´Ø·Ø©' : 'ØºÙŠØ± Ù†Ø´Ø·Ø©'}".`, 'success');
                // No need to refetch, UI is already updated.
            }
        }
    });
    // --- NEW: Attach bulk action listeners separately ---
    const bulkDeactivateBtn = document.getElementById('bulk-deactivate-btn');
    if (bulkDeactivateBtn && canEdit) {
        bulkDeactivateBtn.addEventListener('click', () => {
            showConfirmationModal(
                `Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† ØªØ¹Ø·ÙŠÙ„ ${selectedCompetitionIds.length} Ù…Ø³Ø§Ø¨Ù‚Ø©ØŸ`,
                async () => {
                    const response = await authedFetch('/api/competitions/bulk-update', {
                        method: 'PUT',
                        body: JSON.stringify({ ids: selectedCompetitionIds, data: { is_active: false } })
                    });
                    if (!response.ok) {
                        const result = await response.json();
                        showToast(result.message || 'ÙØ´Ù„ ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©.', 'error');
                    } else {
                        showToast('ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                        await fetchAndDisplayCompetitions(1);
                    }
                }, { title: 'ØªØ£ÙƒÙŠØ¯ Ø§Ù„ØªØ¹Ø·ÙŠÙ„' }
            );
        });
    }

    const bulkDeleteBtn = document.getElementById('bulk-delete-btn');
    if (bulkDeleteBtn && canEdit) {
        bulkDeleteBtn.addEventListener('click', () => {
            showConfirmationModal(
                `Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù ${selectedCompetitionIds.length} Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¨Ø´ÙƒÙ„ Ù†Ù‡Ø§Ø¦ÙŠØŸ`,
                async () => {
                    const response = await authedFetch('/api/competitions/bulk-delete', {
                        method: 'DELETE',
                        body: JSON.stringify({ ids: selectedCompetitionIds })
                    });
                    if (!response.ok) {
                        const result = await response.json();
                        showToast(result.message || 'ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©.', 'error');
                    } else {
                        showToast('ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                        await fetchAndDisplayCompetitions(1);
                    }
                }, {
                    title: 'ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù',
                    confirmText: 'Ø­Ø°Ù',
                    confirmClass: 'btn-danger'
                }
            );
        });
    }

    // Initial fetch and setup
    setupCompetitionFilters();
    await fetchAndDisplayCompetitions(1);

    // FIX: Setup one-time global listener for this page
    setupCompetitionListGlobalListeners();
}

async function fetchAndDisplayCompetitions(page) {
    const container = document.getElementById('competitions-list-container');
    if (!container) return;
    container.innerHTML = '<div class="loader-container"><div class="spinner"></div></div>';

    // Get filter and sort values from the UI
    const searchInput = document.getElementById('competition-search-input');
    const sortSelect = document.getElementById('competition-sort-select');
    const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
    const statusFilter = document.querySelector('.filter-buttons[data-filter-group="status"] .filter-btn.active')?.dataset.filter || 'all';
    const classificationFilter = document.querySelector('.filter-buttons[data-filter-group="classification"] .filter-btn.active')?.dataset.filter || 'all';
    const sortValue = sortSelect ? sortSelect.value : 'newest';

    if (document.getElementById('competition-search-clear')) {
        document.getElementById('competition-search-clear').style.display = searchTerm ? 'block' : 'none';
    }

    const queryParams = new URLSearchParams({
        page: page,
        limit: COMPETITIONS_PER_PAGE,
        search: searchTerm,
        status: statusFilter,
        classification: classificationFilter,
        sort: sortValue,
        excludeStatus: 'completed' // Always exclude completed competitions
    });

    const response = await authedFetch(`/api/competitions?${queryParams.toString()}`);

    if (!response.ok) {
        console.error("Error fetching competitions:", await response.text());
        container.innerHTML = `<p class="error">Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª.</p>`;
        return;
    }

    const { data: competitions, count } = await response.json();

    displayCompetitionsPage(competitions || [], page, count || 0);
}

function displayCompetitionsPage(paginatedCompetitions, page, totalCount) {
    const container = document.getElementById('competitions-list-container');
    if (!container) return;

    page = parseInt(page);
    const totalPages = Math.ceil(totalCount / COMPETITIONS_PER_PAGE);

    const gridHtml = generateCompetitionGridHtml(paginatedCompetitions);

    let paginationHtml = '';
    if (totalPages > 1) {
        paginationHtml += '<div class="pagination-container">';
        paginationHtml += `<button class="page-btn" data-page="${page - 1}" ${page === 1 ? 'disabled' : ''}>Ø§Ù„Ø³Ø§Ø¨Ù‚</button>`;
        for (let i = 1; i <= totalPages; i++) {
            paginationHtml += `<button class="page-btn ${i === page ? 'active' : ''}" data-page="${i}">${i}</button>`;
        }
        paginationHtml += `<button class="page-btn" data-page="${page + 1}" ${page >= totalPages ? 'disabled' : ''}>Ø§Ù„ØªØ§Ù„ÙŠ</button>`;
        paginationHtml += '</div>';
    }

    // Improved empty state
    let finalHtml;
    if (paginatedCompetitions.length > 0) {
        const selectAllChecked = selectedCompetitionIds.length > 0 && paginatedCompetitions.every(c => selectedCompetitionIds.includes(c.id));
        const listHeader = `
            <div class="list-view-header">
                <label class="custom-checkbox">
                    <input type="checkbox" id="select-all-competitions" ${selectAllChecked ? 'checked' : ''}>
                    <span class="checkmark"></span>
                </label>
                <span class="header-name">Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</span>
                <span class="header-status">Ø§Ù„Ø­Ø§Ù„Ø©</span>
                <span class="header-agent">Ø§Ù„ÙˆÙƒÙŠÙ„</span>
                <span class="header-actions">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</span>
            </div>
        `;
        finalHtml = `${listHeader}<div class="competitions-list-view">${gridHtml}</div>${paginationHtml}`;
    } else {
        finalHtml = '<p class="no-results-message">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ ØªØ·Ø§Ø¨Ù‚ Ø¨Ø­Ø«Ùƒ Ø£Ùˆ Ø§Ù„ÙÙ„ØªØ± Ø§Ù„Ø­Ø§Ù„ÙŠ.</p>';
    }
    container.innerHTML = finalHtml;

    // Attach event listeners for checkboxes and pagination
    attachCompetitionListListeners(paginatedCompetitions, totalCount);

    // Start the countdown timers for the newly rendered list
    startCompetitionListCountdowns();
}
function startCompetitionListCountdowns() {
    if (competitionListCountdownInterval) clearInterval(competitionListCountdownInterval);

    const updateTimers = () => {
        document.querySelectorAll('.competition-list-countdown').forEach(el => {
            updateCountdownTimer(el);
        });
    };
    updateTimers(); // Run once immediately
    competitionListCountdownInterval = setInterval(updateTimers, 1000);
}

function setupCompetitionListGlobalListeners() {
    const container = document.getElementById('app-content');
    container.addEventListener('click', (e) => { // Handle edit button clicks using event delegation
        const agentCell = e.target.closest('.table-agent-cell');
        if (agentCell) {
            const agentId = agentCell.dataset.agentId;
            if (agentId) window.location.hash = `#profile/${agentId}`;
        }
    });
}

function generateCompetitionGridHtml(competitions) {
    const isSuperAdmin = currentUserProfile?.role === 'super_admin';
    const compsPerm = currentUserProfile?.permissions?.competitions?.manage_comps;
    const canEdit = isSuperAdmin || compsPerm === 'full';

    if (competitions.length === 0) return ''; // Let displayCompetitionsPage handle the empty message
    return competitions.map(comp => { // The agent object is now nested under 'agent' not 'agents'
        const isSelected = selectedCompetitionIds.includes(comp.id);
        const agent = comp.agents;
        const agentInfoHtml = agent
            ? `<a href="#profile/${agent._id}" class="table-agent-cell" data-agent-id="${agent._id}">
                    ${agent.avatar_url ? `<img src="${agent.avatar_url}" alt="Agent Avatar" class="avatar-small" loading="lazy">` : `<div class="avatar-placeholder-small"><i class="fas fa-user"></i></div>`}
                    <div class="agent-details">
                        <span>${agent.name}</span>
                        ${agent.classification ? `<span class="classification-badge classification-${agent.classification.toLowerCase()}">${agent.classification}</span>` : ''}
                    </div>
               </a>`
            : `<div class="table-agent-cell"><span>(ÙˆÙƒÙŠÙ„ Ù…Ø­Ø°ÙˆÙ Ø£Ùˆ ØºÙŠØ± Ù…Ø±ØªØ¨Ø·)</span></div>`;

        let countdownHtml = '';
        if (comp.ends_at && comp.status !== 'completed' && comp.status !== 'awaiting_winners') {
            const endDate = new Date(comp.ends_at);
            const formattedDate = endDate.toLocaleString('ar-EG', { day: 'numeric', month: 'short', hour: 'numeric', minute: 'numeric' });
            countdownHtml = `
                <div class="competition-timing-info">
                    <div class="competition-list-countdown" data-end-date="${comp.ends_at}"><i class="fas fa-hourglass-half"></i> <span>Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­Ø³Ø§Ø¨...</span></div>
                    <div class="competition-end-date"><i class="fas fa-calendar-check"></i> <span>ØªÙ†ØªÙ‡ÙŠ ÙÙŠ: ${formattedDate}</span></div>
                </div>
            `;
        }

        return `
        <div class="competition-card ${isSelected ? 'selected' : ''}" data-id="${comp.id}">
            <label class="custom-checkbox row-checkbox">
                <input type="checkbox" class="competition-select-checkbox" data-id="${comp.id}" ${isSelected ? 'checked' : ''}>
                <span class="checkmark"></span>
            </label>
            <div class="competition-card-name">
                <div class="competition-info-wrapper">
                    <h3>${comp.name}</h3>
                    ${comp.description ? `<div class="competition-question-text" title="${comp.description}"><i class="fas fa-question-circle"></i> <span>${comp.description}</span></div>` : ''}
                </div>
                ${countdownHtml}
            </div>
            <div class="competition-card-status">
                <label class="custom-checkbox toggle-switch small-toggle" title="${comp.is_active ? 'ØªØ¹Ø·ÙŠÙ„' : 'ØªÙØ¹ÙŠÙ„'}" ${!canEdit ? 'style="cursor:not-allowed;"' : ''}>
                    <input type="checkbox" class="competition-status-toggle" data-id="${comp.id}" ${comp.is_active ? 'checked' : ''} ${!canEdit ? 'disabled' : ''}>
                    <span class="slider round"></span>
                </label>
            </div>
            ${agentInfoHtml}
            <div class="competition-card-footer">
                <button class="btn-danger delete-competition-btn" title="Ø­Ø°Ù" data-id="${comp.id}"><i class="fas fa-trash-alt"></i></button>
            </div>
        </div>
        `;
    }).join('');
}

function setupCompetitionFilters() {
    const searchInput = document.getElementById('competition-search-input');
    const clearBtn = document.getElementById('competition-search-clear');
    const sortSelect = document.getElementById('competition-sort-select');

    const triggerFetch = () => {
        fetchAndDisplayCompetitions(1); // Always go to page 1 when filters change
    };

    if (searchInput) {
        // Use a debounce to avoid fetching on every keystroke
        let searchTimeout;
        searchInput.addEventListener('input', () => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(triggerFetch, 300); // 300ms delay
        });
    }
    if (clearBtn) {
        clearBtn.addEventListener('click', () => {
            if (searchInput.value) {
                searchInput.value = '';
                triggerFetch();
                searchInput.focus();
            }
        });
    }

    if (sortSelect) {
        sortSelect.addEventListener('change', triggerFetch);
    }

    document.querySelectorAll('.filter-buttons').forEach(group => {
        group.addEventListener('click', (e) => {
            if (e.target.classList.contains('filter-btn')) {
                group.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                triggerFetch();
            }
        });
    });
}

// New helper functions for bulk actions
function attachCompetitionListListeners(paginatedList, totalCount) {
    const container = document.getElementById('competitions-list-container');
    if (!container) return;

    // Pagination
    container.querySelectorAll('.page-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const newPage = parseInt(e.currentTarget.dataset.page);
            if (newPage) fetchAndDisplayCompetitions(newPage);
        });
    });

    // Individual checkboxes
    container.querySelectorAll('.competition-select-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
            const id = parseInt(e.target.dataset.id);
            if (e.target.checked) {
                if (!selectedCompetitionIds.includes(id)) {
                    selectedCompetitionIds.push(id);
                }
            } else {
                selectedCompetitionIds = selectedCompetitionIds.filter(selectedId => selectedId !== id);
            }
            updateBulkActionBar(paginatedList.length);
            // Also update the row's selected class
            e.target.closest('.competition-card').classList.toggle('selected', e.target.checked);
        });
    });

    // Select All checkbox
    const selectAllCheckbox = document.getElementById('select-all-competitions');
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', (e) => {
            const paginatedIds = paginatedList.map(c => c.id);
            if (e.target.checked) {
                // Add only the ones not already selected
                paginatedIds.forEach(id => {
                    if (!selectedCompetitionIds.includes(id)) {
                        selectedCompetitionIds.push(id);
                    }
                });
            } else {
                // Remove all from the current page
                selectedCompetitionIds = selectedCompetitionIds.filter(id => !paginatedIds.includes(id));
            }
            const currentPage = document.querySelector('.pagination-container .page-btn.active')?.dataset.page || 1;
            // Re-render the current page to update checkbox states
            fetchAndDisplayCompetitions(currentPage);
            updateBulkActionBar(paginatedList.length);
        });
    }
}

function updateBulkActionBar(currentPageItemCount) {
    const bar = document.getElementById('bulk-action-bar');
    const countSpan = document.getElementById('bulk-action-count');
    const selectAllCheckbox = document.getElementById('select-all-competitions');

    if (selectedCompetitionIds.length > 0) {
        bar.classList.add('visible');
        countSpan.textContent = `${selectedCompetitionIds.length} Ø¹Ù†ØµØ± Ù…Ø­Ø¯Ø¯`;
    } else {
        bar.classList.remove('visible');
    }

    if (selectAllCheckbox) {
        const paginatedIds = Array.from(document.querySelectorAll('.competition-select-checkbox')).map(cb => parseInt(cb.dataset.id));
        const allOnPageSelected = currentPageItemCount > 0 && paginatedIds.every(id => selectedCompetitionIds.includes(id));
        selectAllCheckbox.checked = allOnPageSelected;
    }
}

async function renderCompetitionCreatePage(agentId) {
    const appContent = document.getElementById('app-content');
    let competitionImageFile = null; // Variable to hold the new image file

    // --- NEW: Permission Check ---
    const isSuperAdmin = currentUserProfile?.role === 'super_admin';
    const canCreate = isSuperAdmin || currentUserProfile?.permissions?.competitions?.can_create;
    if (!canCreate) {
        appContent.innerHTML = `
            <div class="access-denied-container">
                <i class="fas fa-lock"></i>
                <h2>Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø©</h2>
                <p>Ø£Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø¯ÙŠØ±.</p>
            </div>`;
        return;
    }

    if (!agentId) { // If no agent is selected, do not render the form.
        appContent.innerHTML = `<p class="error">ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©. Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¨Ø¯ÙˆÙ† ØªØ­Ø¯ÙŠØ¯ ÙˆÙƒÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹.</p>`;
        return;
    }

    // Fetch agent and template data
    const agentResponse = await authedFetch(`/api/agents/${agentId}`);
    if (!agentResponse.ok) {
        appContent.innerHTML = `<p class="error">Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ÙˆÙƒÙŠÙ„.</p>`;
        return;
    }
    const { data: agent } = await agentResponse.json();

    const agentClassification = agent.classification || 'R'; // Default to R if not set
    const templatesResponse = await authedFetch(`/api/templates/available?classification=${agentClassification}`);

    if (!templatesResponse.ok) {
        appContent.innerHTML = `<p class="error">Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª.</p>`;
        return;
    }
    const { data: templates } = await templatesResponse.json();
    
    appContent.innerHTML = `
        <div class="page-header"><h1><i class="fas fa-magic"></i> Ø¥Ù†Ø´Ø§Ø¡ ÙˆØ¥Ø±Ø³Ø§Ù„ Ù…Ø³Ø§Ø¨Ù‚Ø©</h1></div>
        <p class="page-subtitle">Ù„Ù„Ø¹Ù…ÙŠÙ„: <a href="#profile/${agent._id}" class="agent-name-link-subtitle"><strong>${agent.name}</strong></a>. Ù‚Ù… Ø¨ØªØ¹Ø¯ÙŠÙ„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø£Ø¯Ù†Ø§Ù‡ ÙˆØ³ÙŠØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒÙ„ÙŠØ´Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹.</p>
        
        <div class="create-competition-layout-v3">
            <!-- Agent Info Column -->
            <div class="agent-info-v3 card-style-container">
                <h3><i class="fas fa-user-circle"></i> Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„</h3>
                <div class="agent-info-grid">
                    <div class="action-info-card"><i class="fas fa-star"></i><div class="info"><label>Ø§Ù„Ù…Ø±ØªØ¨Ø©</label><p>${agent.rank || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}</p></div></div>                    <div class="action-info-card"><i class="fas fa-tag"></i><div class="info"><label>Ø§Ù„ØªØµÙ†ÙŠÙ</label><p>${agent.classification}</p></div></div>
                    <div class="action-info-card" id="balance-card"><i class="fas fa-wallet"></i><div class="info"><label>Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ</label><p id="agent-remaining-balance">${Math.max(0, agent.remaining_balance || 0)}</p></div></div>
                    <div class="action-info-card" id="bonus-card"><i class="fas fa-gift"></i><div class="info"><label>Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹ Ù…ØªØ¨Ù‚ÙŠ</label><p id="agent-remaining-deposit-bonus">${Math.max(0, agent.remaining_deposit_bonus || 0)} Ù…Ø±Ø§Øª</p></div></div>
                    <div class="action-info-card"><i class="fas fa-percent"></i><div class="info"><label>Ù†Ø³Ø¨Ø© Ø¨ÙˆÙ†Øµ Ø§Ù„Ø¥ÙŠØ¯Ø§Ø¹</label><p>${agent.deposit_bonus_percentage || 0}%</p></div></div>
                </div>
            </div>

            <!-- Variables Column -->
            <div class="variables-v3 card-style-container">
                <h3><i class="fas fa-cogs"></i> 1. ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª</h3>
                <div class="form-group">
                    <label for="competition-template-select">Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©</label>
                    <select id="competition-template-select" required>
                        <option value="" disabled selected>-- Ø§Ø®ØªØ§Ø± Ù…Ø³Ø§Ø¨Ù‚Ø© --</option>
                        ${templates.map(t => {
                            const q = t.question || '';
                            const displayQ = q.length > 120 ? q.substring(0, 120) + '...' : q;
                            return `<option value="${t._id}" title="${q.replace(/"/g, '&quot;')}">${displayQ}</option>`;
                        }).join('')}
                    </select>
                    <div id="template-usage-info" class="form-hint" style="display: none;"></div>
                </div>
                <div class="override-fields-grid">
                    <div class="form-group">
                        <label for="override-trading-winners">Ø¹Ø¯Ø¯ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† (ØªØ¯Ø§ÙˆÙ„ÙŠ)</label>
                        <input type="number" id="override-trading-winners" value="${agent.winners_count !== undefined ? agent.winners_count : 1}" min="0">
                    </div>
                    <div class="form-group">
                        <label for="override-prize">Ø§Ù„Ø¬Ø§Ø¦Ø²Ø© Ù„ÙƒÙ„ ÙØ§Ø¦Ø² ($)</label>
                        <input type="number" id="override-prize" step="0.01" value="${parseFloat(agent.prize_per_winner || 0).toFixed(2)}">
                    </div>
                    <div class="form-group">
                        <label for="override-deposit-winners">Ø¹Ø¯Ø¯ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† (Ø¥ÙŠØ¯Ø§Ø¹)</label>
                        <input type="number" id="override-deposit-winners" value="${agent.deposit_bonus_winners_count !== undefined ? agent.deposit_bonus_winners_count : 0}" min="0">
                    </div>
                    <div class="form-group">
                        <label for="override-duration">Ù…Ø¯Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</label>
                        <select id="override-duration">
                            <option value="" disabled>-- Ø§Ø®ØªØ± Ù…Ø¯Ø© --</option>
                            <option value="10s">10 Ø«ÙˆØ§Ù†ÙŠ</option>
                            <option value="1d" ${agent.competition_duration === '24h' || !agent.competition_duration || (agent.competition_duration !== '48h' && agent.competition_duration !== '168h') ? 'selected' : ''}>ÙŠÙˆÙ… ÙˆØ§Ø­Ø¯</option>
                            <option value="2d" ${agent.competition_duration === '48h' ? 'selected' : ''}>ÙŠÙˆÙ…ÙŠÙ†</option>
                            <option value="1w" ${agent.competition_duration === '168h' ? 'selected' : ''}>Ø£Ø³Ø¨ÙˆØ¹</option>
                        </select>
                    </div>
                    <div class="form-group" style="grid-column: 1 / -1; background-color: var(--bg-color); padding: 10px 15px; border-radius: 6px; margin-top: 10px;">
                        <label for="winner-selection-date-preview" style="color: var(--primary-color);"><i class="fas fa-calendar-alt"></i> ØªØ§Ø±ÙŠØ® Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø² Ø§Ù„Ù…ØªÙˆÙ‚Ø¹</label>
                        <p id="winner-selection-date-preview" class="summary-preview-text"></p>
                    </div>
                </div>
                <div class="form-group" style="margin-top: 15px;">
                    <label for="override-correct-answer">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ù„Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</label>
                    <input type="text" id="override-correct-answer" placeholder="Ø§ÙƒØªØ¨ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ù‡Ù†Ø§" required>
                </div>
                <div class="form-group" style="margin-top: 15px; background-color: var(--bg-color); padding: 10px; border-radius: 6px; display: none;">
                    <label style="color: var(--primary-color);"><i class="fas fa-key"></i> Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©</label>
                    <p id="correct-answer-display" class="summary-preview-text" style="color: var(--text-color);"></p>
                </div>
                <div id="validation-messages" class="validation-messages" style="margin-top: 20px;"></div>
            </div>
            
            <!-- Preview Column -->
            <div class="preview-v3 card-style-container">
                <form id="competition-form">
                    <h3><i class="fab fa-telegram-plane"></i> 2. Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØ¥Ø±Ø³Ø§Ù„</h3>
                    <div class="telegram-preview-wrapper">
                        <div class="telegram-preview-header">
                            <div class="header-left"><i class="fab fa-telegram"></i><span>Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ø±Ø³Ø§Ù„Ø©</span></div>
                        </div>
                        <div class="telegram-preview-body">
                            <textarea id="competition-description" rows="15" required readonly></textarea>
                        </div>
                        <div id="telegram-image-preview-container" class="telegram-image-preview-container" style="display: none;">
                            <img id="telegram-image-preview" src="" alt="Competition Image Preview">
                        </div>
                        <div class="image-actions" style="margin-top: 10px;">
                            <input type="file" id="competition-image-upload" accept="image/*" style="display: none;">
                            <button type="button" id="change-competition-image-btn" class="btn-secondary btn-small"><i class="fas fa-edit"></i> ØªØºÙŠÙŠØ± Ø§Ù„ØµÙˆØ±Ø©</button>
                        </div>
                    </div>
                    <div class="form-actions">
                        <button type="submit" class="btn-primary btn-send-telegram"><i class="fas fa-paper-plane"></i> Ø¥Ø±Ø³Ø§Ù„ Ø¥Ù„Ù‰ ØªÙ„Ø¬Ø±Ø§Ù… Ø§Ù„Ø¢Ù†</button>
                        <button type="button" id="cancel-competition-form" class="btn-secondary">Ø¥Ù„ØºØ§Ø¡</button>
                    </div>
                </form>
            </div>
        </div>
    `;

    const form = document.getElementById('competition-form');
    const templateSelect = document.getElementById('competition-template-select');
    const descInput = document.getElementById('competition-description');
    const tradingWinnersInput = document.getElementById('override-trading-winners');
    const prizeInput = document.getElementById('override-prize');
    const depositWinnersInput = document.getElementById('override-deposit-winners');
    const durationInput = document.getElementById('override-duration');
    const imagePreviewContainer = document.getElementById('telegram-image-preview-container');
    const imagePreview = document.getElementById('telegram-image-preview');
    const imageUploadInput = document.getElementById('competition-image-upload');
    const changeImageBtn = document.getElementById('change-competition-image-btn');

    changeImageBtn.addEventListener('click', () => imageUploadInput.click());

    imageUploadInput.addEventListener('change', () => {
        const file = imageUploadInput.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.src = e.target.result;
            };
            reader.readAsDataURL(file);
            competitionImageFile = file;
        }
    });

    async function checkExistingCompetition(agentId, templateId) {
        const templateUsageInfo = document.getElementById('template-usage-info');
        templateUsageInfo.style.display = 'none';
        templateUsageInfo.classList.remove('error-text');
        if (!agentId || !templateId) return;
        try {
            const response = await authedFetch(`/api/competitions/check-existence?agent_id=${agentId}&template_id=${templateId}`);
            if (response.ok) {
                const { exists } = await response.json();
                if (exists) {
                    templateUsageInfo.innerHTML = `<i class="fas fa-exclamation-triangle"></i> ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„ Ù…Ù† Ù‚Ø¨Ù„.`;
                    templateUsageInfo.style.display = 'block';
                    templateUsageInfo.classList.add('error-text');
                }
            }
        } catch (error) { console.error('Failed to check for existing competition:', error); }
    }

    function updateDescriptionAndPreview(event = {}) {
        const selectedId = templateSelect.value;
        const selectedTemplate = templates.find(t => String(t._id) === selectedId);

        if (!selectedTemplate) {
            descInput.value = 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù‚Ø§Ù„Ø¨ Ù…Ø³Ø§Ø¨Ù‚Ø© Ø£ÙˆÙ„Ø§Ù‹ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©.';
            return;
        }

        // --- REVISED: Image Handling ---
        // Image is now always set from the template when the template is selected.
        if (event.target && event.target.id === 'competition-template-select') {
            const imageUrl = selectedTemplate.image_url || 'images/competition_bg.jpg';
            imagePreview.src = imageUrl;
            imagePreviewContainer.style.display = 'block';
            competitionImageFile = null; // Reset custom image when template changes
        }

        if (event.target && event.target.id === 'competition-template-select') {
            checkExistingCompetition(agent._id, selectedId);
            if (selectedTemplate.usage_limit !== null) {
                const remaining = Math.max(0, selectedTemplate.usage_limit - (selectedTemplate.usage_count || 0));
                const message = `Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ© Ù„Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø§Ù„Ø¨: ${remaining}`;
                if (remaining === 1) showToast(message, 'error');
                else if (remaining <= 3) showToast(message, 'warning');
                else showToast(message, 'info');
            }
        }

        const correctAnswerDisplay = document.getElementById('correct-answer-display');
        correctAnswerDisplay.textContent = selectedTemplate.correct_answer || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø©';
        correctAnswerDisplay.parentElement.style.display = 'block';

        const correctAnswerInput = document.getElementById('override-correct-answer');
        if (correctAnswerInput) correctAnswerInput.value = selectedTemplate.correct_answer || '';

        const originalTemplateContent = selectedTemplate.content;
        const selectedTemplateQuestion = selectedTemplate.question;

        const tradingWinners = parseInt(tradingWinnersInput.value) || 0;
        const depositWinners = parseInt(depositWinnersInput.value) || 0;
        const prize = parseInt(prizeInput.value || 0);
        const duration = durationInput.value;
        const depositBonusPerc = agent.deposit_bonus_percentage || 0;
        
        function numberToArPlural(num) {
            const words = { 3: 'Ø«Ù„Ø§Ø«', 4: 'Ø£Ø±Ø¨Ø¹', 5: 'Ø®Ù…Ø³', 6: 'Ø³Øª', 7: 'Ø³Ø¨Ø¹', 8: 'Ø«Ù…Ø§Ù†ÙŠ', 9: 'ØªØ³Ø¹', 10: 'Ø¹Ø´Ø±' };
            return words[num] || num.toString();
        }
        
        let prizeDetailsText = '';
        if (tradingWinners === 1) prizeDetailsText = `${prize}$ Ù„ÙØ§Ø¦Ø² ÙˆØ§Ø­Ø¯ ÙÙ‚Ø·.`;
        else if (tradingWinners === 2) prizeDetailsText = `${prize}$ Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø§Ø«Ù†ÙŠÙ† ÙÙ‚Ø·.`;
        else if (tradingWinners >= 3 && tradingWinners <= 10) prizeDetailsText = `${prize}$ Ù„Ù€ ${numberToArPlural(tradingWinners)} ÙØ§Ø¦Ø²ÙŠÙ† ÙÙ‚Ø·.`;
        else if (tradingWinners > 10) prizeDetailsText = `${prize}$ Ù„Ù€ ${tradingWinners} ÙØ§Ø¦Ø²Ø§Ù‹ ÙÙ‚Ø·.`;
        else if (tradingWinners > 0) prizeDetailsText = `${prize}$ Ù„Ù€ ${tradingWinners} ÙØ§Ø¦Ø²Ø§Ù‹ ÙÙ‚Ø·.`;

        let depositBonusPrizeText = '';
        if (depositWinners > 0 && depositBonusPerc > 0) {
            if (depositWinners === 1) depositBonusPrizeText = `${depositBonusPerc}% Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹ Ù„ÙØ§Ø¦Ø² ÙˆØ§Ø­Ø¯ ÙÙ‚Ø·.`;
            else if (depositWinners === 2) depositBonusPrizeText = `${depositBonusPerc}% Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹ Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø§Ø«Ù†ÙŠÙ† ÙÙ‚Ø·.`;
            else if (depositWinners >= 3 && depositWinners <= 10) depositBonusPrizeText = `${depositBonusPerc}% Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹ Ù„Ù€ ${numberToArPlural(depositWinners)} ÙØ§Ø¦Ø²ÙŠÙ† ÙÙ‚Ø·.`;
            else if (depositWinners > 10) depositBonusPrizeText = `${depositBonusPerc}% Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹ Ù„Ù€ ${depositWinners} ÙØ§Ø¦Ø²Ø§Ù‹ ÙÙ‚Ø·.`;
        }

        let content = originalTemplateContent;
        content = content.replace(/{{agent_name}}/g, agent.name || 'Ø§Ù„ÙˆÙƒÙŠÙ„');
        if (prizeDetailsText) content = content.replace(/{{prize_details}}/g, prizeDetailsText);
        else content = content.replace(/^.*{{prize_details}}.*\n?/gm, '');

        if (depositBonusPrizeText) content = content.replace(/{{deposit_bonus_prize_details}}/g, depositBonusPrizeText);
        else content = content.replace(/^.*{{deposit_bonus_prize_details}}.*\n?/gm, '');

        let displayDuration = '';
        if (duration) {
            const endDate = new Date();
            let daysToAdd = 0;
            if (duration === '1d') daysToAdd = 1;
            else if (duration === '2d') daysToAdd = 2;
            else if (duration === '1w') daysToAdd = 7;
            endDate.setDate(endDate.getDate() + daysToAdd);
            const formattedEndDate = endDate.toLocaleDateString('ar-EG', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
            displayDuration = `Ù…Ù† ØªØ§Ø±ÙŠØ® Ø§Ù„ÙŠÙˆÙ… ÙˆØ­ØªÙ‰ Ù†Ù‡Ø§ÙŠØ© ÙŠÙˆÙ… ${formattedEndDate}`;
        }

        if (displayDuration) content = content.replace(/â³ Ù…Ø¯Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©: {{competition_duration}}/g, `â³ Ù…Ø¯Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©:\n${displayDuration}`);
        else content = content.replace(/^.*â³ Ù…Ø¯Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©: {{competition_duration}}.*\n?/gm, '');
        
        content = content.replace(/{{question}}/g, selectedTemplateQuestion || '');
        content = content.replace(/{{remaining_deposit_bonus}}/g, agent.remaining_deposit_bonus || 0);
        content = content.replace(/{{deposit_bonus_percentage}}/g, agent.deposit_bonus_percentage || 0);
        content = content.replace(/{{winners_count}}/g, tradingWinners);
        content = content.replace(/{{prize_per_winner}}/g, prize);
        descInput.value = content;

        const totalCost = tradingWinners * prize;
        const newRemainingBalance = (agent.remaining_balance || 0) - totalCost;
        const newRemainingDepositBonus = (agent.remaining_deposit_bonus || 0) - depositWinners;
        const balanceEl = document.getElementById('agent-remaining-balance');
        const bonusEl = document.getElementById('agent-remaining-deposit-bonus');
        const validationContainer = document.getElementById('validation-messages');
        
        // Ensure we never display negative values
        balanceEl.textContent = `${Math.max(0, newRemainingBalance).toFixed(2)}`;
        bonusEl.textContent = `${Math.max(0, newRemainingDepositBonus)} Ù…Ø±Ø§Øª`;

        let validationMessages = '';
        if (newRemainingBalance < 0) {
            validationMessages += `<div class="validation-error"><i class="fas fa-exclamation-triangle"></i> Ø§Ù„Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙ. Ø§Ù„ØªÙƒÙ„ÙØ© (${totalCost.toFixed(2)}$) ØªØªØ¬Ø§ÙˆØ² Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø­ (${(agent.remaining_balance || 0).toFixed(2)}$).</div>`;
        }
        if (newRemainingDepositBonus < 0) {
            validationMessages += `<div class="validation-error"><i class="fas fa-exclamation-triangle"></i> Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø¨ÙˆÙ†Øµ Ø§Ù„Ø¥ÙŠØ¯Ø§Ø¹ ØºÙŠØ± ÙƒØ§ÙÙ (Ø§Ù„Ù…ØªØ§Ø­: ${agent.remaining_deposit_bonus || 0}).</div>`;
        }
        const templateUsageInfo = document.getElementById('template-usage-info');
        if (templateUsageInfo.style.display === 'block' && templateUsageInfo.classList.contains('error-text')) {
            // Message is already displayed
        }
        validationContainer.innerHTML = validationMessages;
        document.getElementById('balance-card').classList.toggle('invalid', newRemainingBalance < 0);
        document.getElementById('bonus-card').classList.toggle('invalid', newRemainingDepositBonus < 0);

        const winnerDatePreview = document.getElementById('winner-selection-date-preview');
        if (duration) {
            let daysToAdd = 0;
            switch (duration) {
                case '1d': daysToAdd = 1; break;
                case '2d': daysToAdd = 2; break;
                case '1w': daysToAdd = 7; break;
            }
            const localToday = new Date();
            localToday.setHours(0, 0, 0, 0);
            localToday.setDate(localToday.getDate() + daysToAdd + 1);
            winnerDatePreview.innerHTML = `Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† ÙÙŠ Ø¨Ø¯Ø§ÙŠØ© ÙŠÙˆÙ… <br><strong>${localToday.toLocaleDateString('ar-EG', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}</strong>`;
            winnerDatePreview.parentElement.style.display = 'block';
        } else {
            winnerDatePreview.parentElement.style.display = 'none';
        }
    }

    [templateSelect, tradingWinnersInput, prizeInput, depositWinnersInput, durationInput].forEach(input => {
        input.addEventListener('change', updateDescriptionAndPreview);
    });

    imagePreviewContainer.addEventListener('click', (e) => {
        if (document.querySelector('.image-modal-overlay')) return;
        const imgSrc = imagePreview.src;
        if (imgSrc) { // Allow modal for all image sources, including data: URLs
            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'image-modal-overlay';
            modalOverlay.setAttribute('role', 'dialog');
            modalOverlay.setAttribute('aria-modal', 'true');
            modalOverlay.setAttribute('aria-label', 'Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„ØµÙˆØ±Ø© Ø¨Ø­Ø¬Ù… ÙƒØ¨ÙŠØ±');
            modalOverlay.innerHTML = `<img src="${imgSrc}" class="image-modal-content" alt="Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„ØµÙˆØ±Ø©">`;
            const closeModal = () => {
                modalOverlay.remove();
                document.removeEventListener('keydown', handleEsc);
            };
            const handleEsc = (event) => {
                if (event.key === 'Escape') closeModal();
            };
            modalOverlay.addEventListener('click', closeModal);
            document.addEventListener('keydown', handleEsc);
            document.body.appendChild(modalOverlay);
        }
    });

    document.getElementById('cancel-competition-form').addEventListener('click', () => {
        window.location.hash = `profile/${agent.id}`;
    });

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        // Ù…Ù†Ø¹ Ø§Ù„Ø¶ØºØ· Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬ Ø¹Ù„Ù‰ Ø²Ø± Ø§Ù„Ø¥Ø±Ø³Ø§Ù„
        if (form.dataset.sending === 'true') return;
        form.dataset.sending = 'true';
        const sendBtn = e.target.querySelector('.btn-send-telegram');
        const originalBtnHtml = sendBtn.innerHTML;
        sendBtn.disabled = true;
        sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ ÙˆØ§Ù„Ø¥Ø±Ø³Ø§Ù„...';

        try {
            const selectedTemplateId = templateSelect.value;
            const selectedTemplate = templates.find(t => t._id == selectedTemplateId);
            if (!selectedTemplate) throw new Error('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù‚Ø§Ù„Ø¨ Ù…Ø³Ø§Ø¨Ù‚Ø© ØµØ§Ù„Ø­.');

            const winnersCount = parseInt(document.getElementById('override-trading-winners').value) || 0;
            const prizePerWinner = parseFloat(document.getElementById('override-prize').value) || 0;
            const depositWinnersCount = parseInt(document.getElementById('override-deposit-winners').value) || 0;
            
            if (winnersCount === 0 && depositWinnersCount === 0) {
                throw new Error('ÙŠØ¬Ø¨ ØªØ­Ø¯ÙŠØ¯ ÙØ§Ø¦Ø² ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ (ØªØ¯Ø§ÙˆÙ„ÙŠ Ø£Ùˆ Ø¥ÙŠØ¯Ø§Ø¹).');
            }

            const totalCost = winnersCount * prizePerWinner;

            if (totalCost > (agent.remaining_balance || 0) || depositWinnersCount > (agent.remaining_deposit_bonus || 0)) {
                throw new Error('Ø§Ù„Ø±ØµÙŠØ¯ Ø£Ùˆ Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ø¨ÙˆÙ†Øµ ØºÙŠØ± ÙƒØ§ÙÙ.');
            }

            const verification = await verifyTelegramChat(agent);
            if (!verification.verified) throw new Error('ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªÙ„Ø¬Ø±Ø§Ù….');

            let finalImageUrl = selectedTemplate.image_url || '/images/competition_bg.jpg'; // Default to template image

            // --- FIX: Normalize image URL so Telegram can fetch it from the backend ---
            if (finalImageUrl) {
                // Handle absolute localhost URLs from old templates
                if (finalImageUrl.startsWith('http://localhost')) {
                    try {
                        const url = new URL(finalImageUrl);
                        finalImageUrl = url.pathname; // Convert to relative path
                    } catch (e) {
                        console.error('Could not parse template image URL, leaving as is:', e);
                    }
                }
                // If we have a relative path without a leading slash (e.g., "uploads/competitions/xxx"), prefix it
                if (!finalImageUrl.startsWith('/') && !finalImageUrl.startsWith('http')) {
                    finalImageUrl = `/${finalImageUrl}`;
                }
            }
            // --- End of FIX ---

            if (competitionImageFile) {
                sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©...';
                const formData = new FormData();
                formData.append('image', competitionImageFile);

                const uploadResponse = await authedFetch('/api/competitions/upload-image', { method: 'POST', body: formData });

                if (!uploadResponse.ok) {
                    throw new Error('ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©.');
                }
                
                const uploadResult = await uploadResponse.json();
                finalImageUrl = uploadResult.imageUrl;
                // Uploaded paths from backend should start with "/uploads", but guard just in case
                if (finalImageUrl && !finalImageUrl.startsWith('/')) {
                    finalImageUrl = `/${finalImageUrl}`;
                }
            }



            // console.log(`The image URL being sent is: ${finalImageUrl}`);

            sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...';

            // Ø§Ø³ØªØ®Ø¯Ù… Ù…ÙØªØ§Ø­ Ø·Ù„Ø¨ Ø«Ø§Ø¨Øª Ø®Ù„Ø§Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ù„Ù…Ù†Ø¹ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚ØªÙŠÙ† Ø¨Ø§Ù„Ø®Ø·Ø£
            const requestKey = form.dataset.requestId || `comp-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
            form.dataset.requestId = requestKey;

            const competitionPayload = {
                name: selectedTemplate.question,
                description: descInput.value,
                is_active: true,
                classification: agent.classification,
                status: 'sent',
                agent_id: agent._id,
                duration: durationInput.value,
                total_cost: totalCost,
                deposit_winners_count: depositWinnersCount,
                trading_winners_count: winnersCount,
                required_winners: winnersCount + depositWinnersCount,
                correct_answer: document.getElementById('override-correct-answer').value,
                prize_per_winner: prizePerWinner,
                template_id: selectedTemplate._id,
                image_url: finalImageUrl,
                client_request_id: requestKey,
                deposit_bonus_percentage: agent.deposit_bonus_percentage || 0 // Ensure this is sent
            };

            /* console.log('ğŸ¯ [Create Competition] Payload being sent to backend:', {
                trading_winners_count: competitionPayload.trading_winners_count,
                deposit_winners_count: competitionPayload.deposit_winners_count,
                required_winners: competitionPayload.required_winners,
                total_cost: competitionPayload.total_cost,
                prize_per_winner: competitionPayload.prize_per_winner
            }); */

            const compResponse = await authedFetch('/api/competitions', {
                method: 'POST',
                body: JSON.stringify(competitionPayload)
            });

            if (!compResponse.ok) {
                const result = await compResponse.json().catch(() => ({}));
                if (compResponse.status === 409) {
                    throw new Error(result.message || 'ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„ Ù…Ù† Ù‚Ø¨Ù„.');
                }
                throw new Error(result.message || 'ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©.');
            }

            const savedCompetition = await compResponse.json();
            const telegramResponse = compResponse;
            /* console.log('âœ… [Create Competition] Competition saved successfully:', {
                id: savedCompetition.data?._id,
                trading_winners_count: savedCompetition.data?.trading_winners_count,
                deposit_winners_count: savedCompetition.data?.deposit_winners_count,
                required_winners: savedCompetition.data?.required_winners
            }); */

            if (!telegramResponse.ok) {
                const result = await telegramResponse.json();
                // Even if Telegram fails, the competition is saved. Log it and inform the user.
                console.error(`ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¥Ù„Ù‰ ØªÙ„Ø¬Ø±Ø§Ù… Ù„ÙƒÙ† ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©: ${result.message}`);
                showToast(`ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©ØŒ Ù„ÙƒÙ† ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¥Ù„Ù‰ ØªÙ„Ø¬Ø±Ø§Ù…: ${result.message}`, 'warning');
            } else {
                showToast('ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© ÙˆØ¥Ø±Ø³Ø§Ù„Ù‡Ø§ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                // --- NEW: Automatically toggle the competition icon on success ---
                const todayDayIndex = new Date().getDay();
                try {
                    await window.taskStore.updateTaskStatus(agent._id, todayDayIndex, 'competition_sent', true);
                } catch (e) {
                    // Ignore Saturday errors or other task update issues, as the competition itself was successful
                    // console.warn('Could not update task status (likely Saturday or network issue):', e.message);
                }
            }
            // --- End of FIX ---

            // --- UPDATE: Balance deduction is now handled by the backend in createCompetition ---
            // We no longer need to send a separate PUT request here.
            showToast('ØªÙ… Ø®ØµÙ… Ø§Ù„ØªÙƒØ§Ù„ÙŠÙ Ù…Ù† Ø§Ù„Ø±ØµÙŠØ¯ ÙˆØ§Ù„Ø¨ÙˆÙ†Øµ Ø¨Ù†Ø¬Ø§Ø­.', 'success');

            // --- FIX: Force a full page reload to show updated balance ---
            // Using .hash only changes the URL fragment without reloading, which can show stale cached data.
            // Using .assign() reloads the page, ensuring the latest agent data (with deducted balance) is fetched from the server.
            showToast('Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ©. Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„ØµÙØ­Ø© Ø§Ù„ÙˆÙƒÙŠÙ„...', 'info');
            form.dataset.sending = 'false';
            delete form.dataset.requestId;
            window.location.assign(`/#profile/${agent._id}`);

        } catch (error) {
            showToast(error.message, 'error');
            console.error('Competition creation failed:', error);
            sendBtn.disabled = false;
            sendBtn.innerHTML = originalBtnHtml;
            form.dataset.sending = 'false';
            delete form.dataset.requestId;
        }
    });
}

async function renderArchivedCompetitionsPage() {
    const appContent = document.getElementById('app-content');
    // --- NEW: Permission Check ---
    const isSuperAdmin = currentUserProfile?.role === 'super_admin';
    const isAdmin = isSuperAdmin || currentUserProfile?.role === 'admin';
    const compsPerm = currentUserProfile?.permissions?.competitions?.manage_comps || 'none';
    const canView = isAdmin || templatesPerm === 'full' || templatesPerm === 'view';

    if (!canView) {
        appContent.innerHTML = `
            <div class="access-denied-container">
                <i class="fas fa-lock"></i>
                <h2>Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© ÙˆØµÙˆÙ„</h2>
                <p>Ø£Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø¯ÙŠØ±.</p>
            </div>`;
        return;
    }
    appContent.innerHTML = `
        <div class="page-header column-header">
            <div class="header-top-row">
                <h1><i class="fas fa-archive"></i> Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©</h1>
            </div>
            <div class="filters-container">
                <div class="filter-search-container">
                    <input type="search" id="archive-comp-search-input" placeholder="Ø¨Ø­Ø« Ø¨Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø£Ùˆ Ø§Ù„ÙˆÙƒÙŠÙ„..." autocomplete="off">
                    <i class="fas fa-search"></i>
                    <i class="fas fa-times-circle search-clear-btn" id="archive-comp-search-clear"></i>
                </div>
                <div class="sort-container">
                    <label for="archive-comp-sort-select">ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨:</label>
                    <select id="archive-comp-sort-select">
                        <option value="newest">Ø§Ù„Ø£Ø­Ø¯Ø« Ø£ÙˆÙ„Ø§Ù‹</option>
                        <option value="name_asc">Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© (Ø£ - ÙŠ)</option>
                        <option value="agent_asc">Ø§Ø³Ù… Ø§Ù„ÙˆÙƒÙŠÙ„ (Ø£ - ÙŠ)</option>
                    </select>
                </div>
            </div>
        </div>
        <div id="archived-competitions-list-container"></div>
    `;

    let allArchivedCompetitions = [];

    async function loadArchivedCompetitions() {
        const response = await authedFetch('/api/competitions?status=completed&sort=newest');

        if (!response.ok) {
            document.getElementById('archived-competitions-list-container').innerHTML = '<p class="error">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©.</p>';
            return;
        }

        const { data } = await response.json();
        allArchivedCompetitions = data || [];
        applyFiltersAndSort();
    }

    function displayArchived(competitions) {
        const container = document.getElementById('archived-competitions-list-container');
        if (competitions.length === 0) {
            container.innerHTML = '<p class="no-results-message">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ù…Ù†ØªÙ‡ÙŠØ©.</p>';
            return;
        }
        container.innerHTML = `
            <div class="competitions-list-view">
                ${competitions.map(comp => {
                    const agent = comp.agents;
                    const agentInfoHtml = agent
                        ? `<a href="#profile/${agent.id}" class="table-agent-cell">
                                ${agent.avatar_url ? `<img src="${agent.avatar_url}" alt="Agent Avatar" class="avatar-small" loading="lazy">` : `<div class="avatar-placeholder-small"><i class="fas fa-user"></i></div>`}
                                <div class="agent-details"><span>${agent.name}</span></div>
                           </a>`
                        : `<div><span>(ÙˆÙƒÙŠÙ„ Ù…Ø­Ø°ÙˆÙ)</span></div>`;

                    return `
                    <div class="competition-card" data-id="${comp.id}">
                        <div class="competition-card-name"><h3>${comp.name}</h3></div>
                        <div class="competition-card-status"><span class="status-badge-v2 status-completed">Ù…ÙƒØªÙ…Ù„Ø©</span></div>
                        ${agentInfoHtml}
                        <div class="competition-card-footer">
                            <button class="btn-danger delete-competition-btn" title="Ø­Ø°Ù" data-id="${comp._id}"><i class="fas fa-trash-alt"></i></button>
                        </div>
                    </div>`;
                }).join('')}
            </div>
        `;
    }

    function applyFiltersAndSort() {
        const searchInput = document.getElementById('archive-comp-search-input');
        const sortSelect = document.getElementById('archive-comp-sort-select');
        const searchTerm = searchInput.value.toLowerCase().trim();
        const sortValue = sortSelect.value;

        let filtered = allArchivedCompetitions.filter(comp => {
            const name = comp.name.toLowerCase();
            const agentName = comp.agents ? comp.agents.name.toLowerCase() : '';
            return searchTerm === '' || name.includes(searchTerm) || agentName.includes(searchTerm);
        });

        filtered.sort((a, b) => {
            switch (sortValue) {
                case 'name_asc': return a.name.localeCompare(b.name);
                case 'agent_asc': return (a.agents?.name || '').localeCompare(b.agents?.name || '');
                default: return new Date(b.created_at) - new Date(a.created_at);
            }
        });

        displayArchived(filtered);
    }

    document.getElementById('archive-comp-search-input').addEventListener('input', applyFiltersAndSort);
    document.getElementById('archive-comp-sort-select').addEventListener('change', applyFiltersAndSort);
    document.getElementById('archive-comp-search-clear').addEventListener('click', () => {
        const searchInput = document.getElementById('archive-comp-search-input');
        searchInput.value = '';
        applyFiltersAndSort();
    });

    // --- NEW: Add event listener for delete buttons ---
    const container = document.getElementById('archived-competitions-list-container');
    container.addEventListener('click', async (e) => {
        const deleteBtn = e.target.closest('.delete-competition-btn');
        if (deleteBtn) {
            const isSuperAdmin = currentUserProfile?.role === 'super_admin';
            const isAdmin = isSuperAdmin || currentUserProfile?.role === 'admin';
            const compsPerm = currentUserProfile?.permissions?.competitions?.manage_comps || 'none';
            const canEdit = isAdmin || compsPerm === 'full';

            if (!canEdit) {
                showToast('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ø­Ø°Ù Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª.', 'error');
                return;
            }

            const id = deleteBtn.dataset.id;
            showConfirmationModal(
                'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹ØŸ',
                async () => {
                    const response = await authedFetch(`/api/competitions/${id}`, { method: 'DELETE' });
                    if (!response.ok) {
                        showToast('ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©.', 'error');
                    } else {
                        showToast('ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                        await loadArchivedCompetitions(); // Refresh the list
                    }
                }, { title: 'ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù', confirmText: 'Ø­Ø°Ù', confirmClass: 'btn-danger' });
        }
    });

    await loadArchivedCompetitions();
}

// --- 3. Edit Existing Competition Form ---

async function renderCompetitionEditForm(compId) {
    // --- NEW: Permission Check ---
    const isSuperAdmin = currentUserProfile?.role === 'super_admin';
    const canEdit = isSuperAdmin || (currentUserProfile?.permissions?.competitions?.manage_comps === 'full');
    if (!canEdit) {
        document.getElementById('app-content').innerHTML = `
            <div class="access-denied-container">
                <i class="fas fa-lock"></i>
                <h2>Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª</h2>
                <p>Ø£Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø¯ÙŠØ±.</p>
            </div>`;
        return;
    }
    appContent.innerHTML = `
        <div class="form-container">
            <h2>ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©: ${competition.name}</h2>
            <form id="competition-form" class="form-layout">
                <div class="form-group"><label for="competition-name">Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</label><input type="text" id="competition-name" value="${competition.name}" required></div>
                <div class="form-group"><label for="competition-description">Ø§Ù„ÙˆØµÙ</label><textarea id="competition-description" rows="3">${competition.description || ''}</textarea></div>
                <div class="form-group"><label class="custom-checkbox toggle-switch"><input type="checkbox" id="competition-active" ${competition.is_active ? 'checked' : ''}> <span class="slider"></span><span class="label-text">Ù†Ø´Ø·Ø©</span></label></div>
                <div class="form-actions">
                    <button type="submit" class="btn-primary">Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª</button>
                    <button type="button" id="cancel-competition-form" class="btn-secondary">Ø¥Ù„ØºØ§Ø¡</button>
                </div>
            </form>
        </div>
    `;

    document.getElementById('cancel-competition-form').addEventListener('click', () => { window.location.hash = 'competitions'; });

    document.getElementById('competition-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const formData = {
            name: document.getElementById('competition-name').value,
            description: document.getElementById('competition-description').value,
            is_active: document.getElementById('competition-active').checked,
        };

        const response = await authedFetch(`/api/competitions/${compId}`, {
            method: 'PUT',
            body: JSON.stringify(formData)
        });

        if (!response.ok) {
            showToast('ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª.', 'error');
        } else {
            showToast('ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¨Ù†Ø¬Ø§Ø­.', 'success');
            window.location.hash = 'competitions';
        }
    });
}

// --- 4. Competition Templates Page ---

async function renderCompetitionTemplatesPage() {
    // --- NEW: Permission Check ---
    const appContent = document.getElementById('app-content');
    const isSuperAdmin = currentUserProfile?.role === 'super_admin';
    const isAdmin = isSuperAdmin || currentUserProfile?.role === 'admin';
    const templatesPerm = currentUserProfile?.permissions?.competitions?.manage_templates || 'none';
    const canView = isAdmin || templatesPerm === 'full' || templatesPerm === 'view';

    if (!canView) {
        appContent.innerHTML = `
            <div class="access-denied-container">
                <i class="fas fa-lock"></i>
                <h2>Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© ÙˆØµÙˆÙ„</h2>
                <p>Ø£Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø¯ÙŠØ±.</p>
            </div>`;
        return;
    }

    const canEdit = isAdmin || templatesPerm === 'full'; // Ø¥ØµÙ„Ø§Ø­: ØªØ¹Ø±ÙŠÙ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¹Ø±Ø¶
    document.querySelector('main').classList.add('full-width');

    const defaultTemplateContent = `Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† Ø´Ø±ÙƒØ© Ø¥Ù†Ø²Ùˆ Ù„Ù„ØªØ¯Ø§ÙˆÙ„ ğŸ†

âœ¨ Ù‡Ù„ ØªÙ…Ù„Ùƒ Ø¹ÙŠÙ†Ù‹Ø§ Ø®Ø¨ÙŠØ±Ø© ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø´Ø§Ø±ØªØ§ØªØŸ Ø§Ø®ØªØ¨Ø± Ù†ÙØ³Ùƒ ÙˆØ§Ø±Ø¨Ø­!

ğŸ’° Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©: {{prize_details}}
                 {{deposit_bonus_prize_details}}

â“ Ø³Ø¤Ø§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©:
{{question}}

ğŸ“ ÙƒÙŠÙÙŠØ© Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©:
Ø¶Ø¹ ØªØ¹Ù„ÙŠÙ‚Ùƒ Ø¹Ù„Ù‰ Ù…Ù†Ø´ÙˆØ± Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¨Ø§Ù„Ù‚Ù†Ø§Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø­Ø³Ø§Ø¨Ùƒ Ø§Ù„Ø´Ø®ØµÙŠ Ø¹Ù„Ù‰ ØªÙ„ÙŠØ¬Ø±Ø§Ù….

ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªØ¶Ù…Ù† ØªØ¹Ù„ÙŠÙ‚Ùƒ:
â€¢ Ø¥Ø¬Ø§Ø¨ØªÙƒ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¤Ø§Ù„.
â€¢ Ø§Ø³Ù…Ùƒ Ø§Ù„Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ù…Ø³Ø¬Ù„ Ø¨Ø§Ù„ÙˆØ«Ø§Ø¦Ù‚.
â€¢ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ¯Ø§ÙˆÙ„ÙŠ.

ÙŠÙÙ…Ù†Ø¹ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚ Ø¨Ø¹Ø¯ Ù†Ø´Ø±Ù‡ØŒ ÙˆØ£ÙŠ ØªØ¹Ù„ÙŠÙ‚ Ù…ÙØ¹Ø¯Ù„ Ø³ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¹Ø§Ø¯Ù‡ Ù…Ø¨Ø§Ø´Ø±Ø©.

â³ Ù…Ø¯Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©: {{competition_duration}}

ğŸ“š ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ø¹Ø±ÙØ© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ÙˆØªØ¹Ù„Ù‘Ù… Ø§Ù„Ù…Ø²ÙŠØ¯ Ø¹Ù† Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„ÙÙ†ÙŠØ© ÙˆØ£Ø³Ø§Ù„ÙŠØ¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ±Ø³ Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠ Ø§Ù„Ù…Ù‚Ø¯Ù… Ù…Ù† Ø§Ù„Ø®Ø¨ÙŠØ± Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠ Ø£. Ø´Ø±ÙŠÙ Ø®ÙˆØ±Ø´ÙŠØ¯ Ø¹Ù„Ù‰ Ù…ÙˆÙ‚Ø¹ Ø¥Ù†Ø²Ùˆ. ğŸ†“

âœ¨ Ù„Ø§ ØªÙÙˆØª Ø§Ù„ÙØ±ØµØ©!
Ø¬Ø§ÙˆØ¨ ØµØ­ØŒ Ø§Ø®ØªØ¨Ø± Ù…Ø¹Ø±ÙØªÙƒØŒ ÙˆÙƒÙ† Ø§Ù„ÙØ§Ø¦Ø² Ù…Ø¹ Ø¥Ù†Ø²Ùˆ ğŸ`;

    appContent.innerHTML = `
        <div class="page-header">
            <div class="header-top-row">
                <h1><i class="fas fa-file-alt"></i> Ø¥Ø¯Ø§Ø±Ø© Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª</h1>
                <button id="show-template-form-btn" class="btn-primary"><i class="fas fa-plus-circle"></i> Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ù„Ø¨ Ø¬Ø¯ÙŠØ¯</button>
            </div>
            <div class="template-filters">
                <div class="filter-search-container">
                    <input type="search" id="template-search-input" placeholder="Ø¨Ø­Ø« Ø¨Ø§Ø³Ù… Ø§Ù„Ù‚Ø§Ù„Ø¨..." autocomplete="off">
                    <i class="fas fa-search"></i>
                    <i class="fas fa-times-circle search-clear-btn" id="template-search-clear"></i>
                </div>
                <div class="filter-buttons" data-filter-group="classification">
                    <button class="filter-btn active" data-filter="all">Ø§Ù„ÙƒÙ„</button>
                    <button class="filter-btn" data-filter="R">R</button>
                    <button class="filter-btn" data-filter="A">A</button>
                    <button class="filter-btn" data-filter="B">B</button>
                    <button class="filter-btn" data-filter="C">C</button>
                    <button class="filter-btn" data-filter="All">Ø¹Ø§Ù…</button>
                </div>
            </div>
        </div>
        <div class="templates-list-container">
            <div id="templates-list" class="templates-list-grouped"></div>
        </div>
    `;

    const templatesListDiv = document.getElementById('templates-list');
    const showFormBtn = document.getElementById('show-template-form-btn');

    if (showFormBtn) {
        if (canEdit) {
            showFormBtn.addEventListener('click', () => renderCreateTemplateModal(defaultTemplateContent, loadTemplates));
        } else {
            showFormBtn.addEventListener('click', () => showToast('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù‚ÙˆØ§Ù„Ø¨.', 'error'));
        }
    }

    async function loadTemplates() {
        const response = await authedFetch('/api/templates?archived=false');

        if (!response.ok) {
            console.error('Error fetching templates:', await response.text());
            templatesListDiv.innerHTML = '<p class="error">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨.</p>';
            return;
        }

        const { data: templates } = await response.json();
        // Sort templates by classification R, A, B, C, then All
        const classificationOrder = { 'R': 1, 'A': 2, 'B': 3, 'C': 4, 'All': 5 };
        templates.sort((a, b) => {
            const orderA = classificationOrder[a.classification] || 99;
            const orderB = classificationOrder[b.classification] || 99;
            if (orderA !== orderB) {
                return orderA - orderB;
            }
            // Secondary sort by question name alphabetically
            // --- FIX: Add a fallback for templates that might not have a name ---
            return (a.name || '').localeCompare(b.name || '');
        });

        if (templates.length === 0) {
            templatesListDiv.innerHTML = '<p class="no-results-message">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚ÙˆØ§Ù„Ø¨ Ù…Ø­ÙÙˆØ¸Ø© Ø¨Ø¹Ø¯.</p>';
        } else {
            const groupedTemplates = templates.reduce((acc, template) => {
            const key = template.classification || 'All'; // Ensure key exists
                if (!acc[key]) acc[key] = [];
                acc[key].push(template);
                return acc;
        }, {}); // Initialize with an empty object

            const classificationOrder = ['R', 'A', 'B', 'C', 'All'];
            let groupsHtml = '';

            for (const classification of classificationOrder) {
                if (groupedTemplates[classification]) {
                    const group = groupedTemplates[classification];
                    groupsHtml += `
                        <details class="template-group" data-classification-group="${classification}" open>
                            <summary class="template-group-header">
                                <h2>ØªØµÙ†ÙŠÙ ${classification === 'All' ? 'Ø¹Ø§Ù…' : classification}</h2>
                                <span class="template-count">${group.length} Ù‚ÙˆØ§Ù„Ø¨</span>
                            </summary>
                            <div class="template-group-content">
                                ${group.map(template => `
                                <div class="template-card" data-id="${template._id}" data-question="${(template.name || '').toLowerCase()}" data-classification="${template.classification || 'All'}">
                                        <div class="template-card-header">
                                        <h4>${template.name || 'Ù‚Ø§Ù„Ø¨ Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…'}</h4>
                                        </div>
                                        <div class="template-card-body">
                                            <p>${template.content.substring(0, 120)}...</p>
                                        </div>
                                        <div class="template-card-footer">
                                            <button class="btn-secondary edit-template-btn" data-id="${template._id}"><i class="fas fa-edit"></i> ØªØ¹Ø¯ÙŠÙ„</button>
                                            <button class="btn-danger delete-template-btn" data-id="${template._id}"><i class="fas fa-trash-alt"></i> Ø­Ø°Ù</button>
                                        </div> 
                                    </div>
                                `).join('')}
                            </div>
                        </details>
                    `;
                }
            }
            templatesListDiv.innerHTML = groupsHtml;
        }
    }

    templatesListDiv.addEventListener('click', async (e) => {
        const editBtn = e.target.closest('.edit-template-btn');
        if (editBtn) {
            if (!canEdit) {
                showToast('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨.', 'error'); // Corrected permission check
                return;
            }
            const id = editBtn.dataset.id; // This is the Supabase ID, which is correct for fetching
            const response = await authedFetch(`/api/templates/${id}`);
            const { data: template } = await response.json();
            
            if (!response.ok || !template) {
                showToast('ÙØ´Ù„ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø§Ù„Ø¨.', 'error');
                return;
            }
            
            renderEditTemplateModal(template, loadTemplates);
        }

        const deleteBtn = e.target.closest('.delete-template-btn');
        if (deleteBtn) {
            if (!canEdit) {
                showToast('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ø­Ø°Ù Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨.', 'error');
                return;
            }
            const templateId = deleteBtn.dataset.id; // This is the MongoDB _id string
            showConfirmationModal(
                'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø§Ù„Ø¨ØŸ<br><small>Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡.</small>',
                async () => {
                    const response = await authedFetch(`/api/templates/${templateId}/archive`, { method: 'PATCH' });
                    if (!response.ok) {
                        const result = await response.json();
                        showToast(result.message || 'ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù‚Ø§Ù„Ø¨.', 'error');
                    } else {
                        showToast('ØªÙ… Ø­Ø°Ù Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                        await loadTemplates();
                    }
                },
                { title: 'ØªØ£ÙƒÙŠØ¯ Ø­Ø°Ù Ø§Ù„Ù‚Ø§Ù„Ø¨', confirmText: 'Ø­Ø°Ù', confirmClass: 'btn-danger' }
            );
        }
    });

    await loadTemplates();
    setupTemplateFilters();
}

function renderCreateTemplateModal(defaultContent, onSaveCallback) {
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    
    let templateImageFile = null; // Variable to hold the new image file

    const modal = document.createElement('div');
    modal.className = 'form-modal-content modal-fullscreen'; // Use existing style from components.css
    
    modal.innerHTML = `
        <div class="form-modal-header">
            <h2><i class="fas fa-plus-circle"></i> Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ù„Ø¨ Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¬Ø¯ÙŠØ¯</h2>
            <button id="close-modal-btn" class="btn-icon-action" title="Ø¥ØºÙ„Ø§Ù‚">&times;</button>
        </div>
        <div class="form-modal-body">
            <form id="create-template-form" class="template-form-grid">
                <div class="template-form-fields">
                    <h3 class="details-section-title" style="margin-top: 0;"><i class="fas fa-info-circle"></i> Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©</h3>
                    <div class="form-group">
                        <label for="create-template-question">Ø§Ù„Ø³Ø¤Ø§Ù„ (Ø³ÙŠÙƒÙˆÙ† Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©)</label>
                        <textarea id="create-template-question" rows="3" required></textarea>
                        <div id="template-question-validation" class="validation-error" style="display: none; margin-top: 8px; font-size: 0.9em;"></div>
                    </div>
                    <div class="form-group">
                        <label for="create-template-correct-answer">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©</label>
                        <textarea id="create-template-correct-answer" rows="2" required></textarea>
                    </div>
                    <div class="form-group">
                        <label for="create-template-classification">Ø§Ù„ØªØµÙ†ÙŠÙ (Ù„Ù…Ù† Ø³ÙŠØ¸Ù‡Ø± Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø§Ù„Ø¨)</label>
                        <select id="create-template-classification" required>
                            <option value="All" selected>Ø¹Ø§Ù… (ÙŠØ¸Ù‡Ø± Ù„Ù„Ø¬Ù…ÙŠØ¹)</option>
                            <option value="R">R</option>
                            <option value="A">A</option>
                            <option value="B">B</option>
                            <option value="C">C</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="create-template-usage-limit">Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… (Ø§ØªØ±ÙƒÙ‡ ÙØ§Ø±ØºØ§Ù‹ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ØºÙŠØ± Ø§Ù„Ù…Ø­Ø¯ÙˆØ¯)</label>
                        <input type="number" id="create-template-usage-limit" min="1" placeholder="Ù…Ø«Ø§Ù„: 5">
                    </div>
                </div>
                <div class="template-form-content">
                    <h3 class="details-section-title" style="margin-top: 0;"><i class="fas fa-file-alt"></i> Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</h3>
                    <!-- NEW: Image Preview Section with upload button -->
                    <div class="form-group">
                        <label>ØµÙˆØ±Ø© Ø§Ù„Ù‚Ø§Ù„Ø¨</label>
                        <div class="image-preview-container">
                            <img id="create-template-image-preview" src="images/competition_bg.jpg" alt="ØµÙˆØ±Ø© Ø§Ù„Ù‚Ø§Ù„Ø¨" class="image-preview">
                        </div>
                        <input type="file" id="create-template-image-upload" accept="image/*" style="display: none;">
                        <button type="button" id="change-template-image-btn" class="btn-secondary btn-small" style="margin-top: 10px;"><i class="fas fa-edit"></i> ØªØºÙŠÙŠØ± Ø§Ù„ØµÙˆØ±Ø©</button>
                    </div>
                    <div class="form-group">
                        <label for="create-template-content">Ù†Øµ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</label>
                        <textarea id="create-template-content" rows="15" required>${defaultContent}</textarea>
                    </div>
                </div>
                <div class="form-actions template-form-actions">
                    <button type="submit" class="btn-primary"><i class="fas fa-save"></i> Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨</button>
                    <button type="button" id="cancel-create-modal" class="btn-secondary">Ø¥Ù„ØºØ§Ø¡</button>
                </div>
            </form>
        </div>
    `;
    
    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    const closeModal = () => overlay.remove();

    // --- NEW: Event Listeners for Image Manipulation ---
    const imageUploadInput = document.getElementById('create-template-image-upload');
    const changeImageBtn = document.getElementById('change-template-image-btn');
    const imagePreview = document.getElementById('create-template-image-preview');

    changeImageBtn.addEventListener('click', () => imageUploadInput.click());

    imageUploadInput.addEventListener('change', () => {
        const file = imageUploadInput.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.src = e.target.result;
            };
            reader.readAsDataURL(file);
            templateImageFile = file;
        }
    });

    // --- NEW: Live validation for template question ---
    const questionInput = document.getElementById('create-template-question');
    const validationDiv = document.getElementById('template-question-validation');
    let debounceTimeout;

    questionInput.addEventListener('input', () => {
        clearTimeout(debounceTimeout);
        debounceTimeout = setTimeout(async () => {
            const questionText = questionInput.value.trim();
            if (questionText) {
                try {
                    const response = await authedFetch(`/api/templates/check-existence?question=${encodeURIComponent(questionText)}`);
                    if (response.ok) {
                        const { exists, archived } = await response.json();
                        if (exists) {
                            if (archived) {
                                validationDiv.innerHTML = 'Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù‚Ø§Ù„Ø¨ Ù…Ø­Ø°ÙˆÙ. ÙŠÙ…ÙƒÙ†Ùƒ <a href="#archived-templates">Ø§Ø³ØªØ¹Ø§Ø¯ØªÙ‡ Ù…Ù† Ø§Ù„Ø£Ø±Ø´ÙŠÙ</a>.';
                            } else {
                                validationDiv.textContent = 'Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‚Ø§Ù„Ø¨ Ø¢Ø®Ø±.';
                            }
                            validationDiv.style.display = 'block';
                        } else {
                            validationDiv.style.display = 'none';
                        }
                    } else {
                        validationDiv.style.display = 'none'; // Hide on error
                    }
                } catch (error) {
                    console.error('Error checking template existence:', error);
                    validationDiv.style.display = 'none'; // Hide on error
                }
            } else {
                validationDiv.style.display = 'none';
            }
        }, 500); // 500ms debounce delay
    });


    document.getElementById('close-modal-btn').addEventListener('click', closeModal);
    document.getElementById('cancel-create-modal').addEventListener('click', closeModal);
    
    document.getElementById('create-template-form').addEventListener('submit', async (e) => {
        e.preventDefault();

        // --- NEW: Prevent submission if validation error is visible ---
        if (validationDiv.style.display === 'block') {
            showToast('Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ù„Ø£Ù† Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„.', 'error');
            return;
        }

        const submitBtn = e.target.querySelector('button[type="submit"]');
        const originalBtnHtml = submitBtn.innerHTML;
        submitBtn.disabled = true;

                    const questionText = document.getElementById('create-template-question').value.trim();        
                    if (!questionText) {
                        showToast('Ø­Ù‚Ù„ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…Ø·Ù„ÙˆØ¨.', 'error');
                        submitBtn.disabled = false;
                        return;
                    }
        
                    // Debugging: Log values before sending
                    console.log('DEBUG: Question Text (name/question):', questionText);
                    console.log('DEBUG: Template Content:', document.getElementById('create-template-content').value.trim());
                    console.log('DEBUG: Correct Answer:', document.getElementById('create-template-correct-answer').value.trim());
                    console.log('DEBUG: Classification:', document.getElementById('create-template-classification').value);
                    console.log('DEBUG: Usage Limit:', document.getElementById('create-template-usage-limit').value);
        
                    try {
                        let finalImageUrl = '/images/competition_bg.jpg'; // Default image
        
                        if (templateImageFile) {
                            submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©...';
                            const formData = new FormData();
                            formData.append('image', templateImageFile);
        
                            // Re-using the competition image upload endpoint
                            const uploadResponse = await authedFetch('/api/competitions/upload-image', { method: 'POST', body: formData });
        
                            if (!uploadResponse.ok) {
                                throw new Error('ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©.');
                            }
                            
                            const uploadResult = await uploadResponse.json();
                            finalImageUrl = uploadResult.imageUrl; // The backend should return the relative path
                        }
                        
                        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨...';
        
                        const formData = {
                            name: questionText,
                            question: questionText, // FIX: Ensure 'question' field is also sent
                            classification: document.getElementById('create-template-classification').value,
                            content: document.getElementById('create-template-content').value.trim(),
                            correct_answer: document.getElementById('create-template-correct-answer').value.trim(),
                            usage_limit: document.getElementById('create-template-usage-limit').value ? parseInt(document.getElementById('create-template-usage-limit').value, 10) : null,
                            usage_count: 0,
                            is_archived: false,
                            image_url: finalImageUrl // Add the image URL to the payload
                        };
        
                        console.log('DEBUG: Creating template with data:', formData);
            const response = await authedFetch('/api/templates', {
                method: 'POST',
                body: JSON.stringify(formData)
            });

            const result = await response.json();

            if (!response.ok) {
                console.error('Template creation failed:', result);
                throw new Error(result.message || 'ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨.');
            }
            
            console.log('Template created successfully:', result);
            showToast('ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
            closeModal();
            if (onSaveCallback) onSaveCallback();

        } catch (error) {
            showToast(error.message, 'error');
            console.error('Template creation failed:', error);
            submitBtn.disabled = false;
            submitBtn.innerHTML = originalBtnHtml;
        }
    });
}

function setupTemplateFilters() {
    const searchInput = document.getElementById('template-search-input');
    const clearBtn = document.getElementById('template-search-clear');
    const filterButtons = document.querySelectorAll('.template-filters .filter-btn');

    if (!searchInput) return;

    const applyFilters = () => {
        if (clearBtn) {
            clearBtn.style.display = searchInput.value ? 'block' : 'none';
        }

        const searchTerm = searchInput.value.toLowerCase().trim();
        const activeFilter = document.querySelector('.template-filters .filter-btn.active').dataset.filter;

        const allGroups = document.querySelectorAll('.template-group'); // Corrected selector
        let hasResults = false;

        allGroups.forEach(group => {
            const cards = group.querySelectorAll('.template-card');
            let visibleCardsInGroup = 0;

            cards.forEach(card => {
                const question = card.dataset.question || ''; // Add fallback for safety
                const classification = card.dataset.classification;

                const matchesSearch = searchTerm === '' || question.includes(searchTerm);
                const matchesFilter = activeFilter === 'all' || classification === activeFilter;

                const isVisible = matchesSearch && matchesFilter;
                card.style.display = isVisible ? '' : 'none';
                if (isVisible) {
                    visibleCardsInGroup++;
                }
            });

            // Hide the entire group if no cards are visible
            group.style.display = visibleCardsInGroup > 0 ? '' : 'none';
            if (visibleCardsInGroup > 0) {
                hasResults = true;
            }
        });
    };

    searchInput.addEventListener('input', applyFilters);
    if (clearBtn) {
        clearBtn.addEventListener('click', () => {
            searchInput.value = '';
            applyFilters();
            searchInput.focus();
        });
    }

    filterButtons.forEach(button => {
        button.addEventListener('click', () => {
            filterButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            applyFilters();
        });
    });
}

async function renderArchivedTemplatesPage() {
    const appContent = document.getElementById('app-content');
    // --- NEW: Permission Check ---
    const isSuperAdmin = currentUserProfile?.role === 'super_admin';
    const isAdmin = isSuperAdmin || currentUserProfile?.role === 'admin';
    const templatesPerm = currentUserProfile?.permissions?.competitions?.manage_templates || 'none';
    const canView = isAdmin || templatesPerm === 'full' || templatesPerm === 'view';

    if (!canView) {
        appContent.innerHTML = ` <div class="access-denied-container">
                <i class="fas fa-lock"></i>
                <h2>Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© ÙˆØµÙˆÙ„</h2>
                <p>Ø£Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø¯ÙŠØ±.</p>
            </div>`;
        return;
    }
    document.querySelector('main').classList.add('full-width');

    appContent.innerHTML = `
        <div class="page-header">
            <div class="header-top-row">
                <h1><i class="fas fa-archive"></i> Ø£Ø±Ø´ÙŠÙ Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª</h1>
            </div>
            <div class="template-filters">
                <div class="filter-search-container">
                    <input type="search" id="archive-search-input" placeholder="Ø¨Ø­Ø« Ø¨Ø§Ø³Ù… Ø§Ù„Ù‚Ø§Ù„Ø¨..." autocomplete="off">
                    <i class="fas fa-search"></i>
                    <i class="fas fa-times-circle search-clear-btn" id="archive-search-clear"></i>
                </div>
                <div class="filter-buttons" data-filter-group="classification">
                    <button class="filter-btn active" data-filter="all">Ø§Ù„ÙƒÙ„</button>
                    <button class="filter-btn" data-filter="R">R</button>
                    <button class="filter-btn" data-filter="A">A</button>
                    <button class="filter-btn" data-filter="B">B</button>
                    <button class="filter-btn" data-filter="C">C</button>
                    <button class="filter-btn" data-filter="All">Ø¹Ø§Ù…</button>
                </div>
            </div>
        </div>
        <p class="page-subtitle" style="text-align: right; margin-top: 0;">Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„ØªÙŠ ÙˆØµÙ„Øª Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù…Ù† Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…. ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„Ù‡Ø§ Ù…Ù† Ù‡Ù†Ø§.</p>
        <div id="archived-templates-list" class="table-responsive-container">
            <p>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ø±Ø´ÙŠÙ...</p>
        </div>
    `;

    const listDiv = document.getElementById('archived-templates-list');
    let allArchivedTemplates = [];

    function displayArchived(templatesToDisplay) {
        const isSuperAdmin = currentUserProfile?.role === 'super_admin';
        const isAdmin = isSuperAdmin || currentUserProfile?.role === 'admin';
        const templatesPerm = currentUserProfile?.permissions?.competitions?.manage_templates || 'none';
        const canEdit = isAdmin || templatesPerm === 'full';
        if (templatesToDisplay.length === 0) {
            listDiv.innerHTML = '<p class="no-results-message">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚ÙˆØ§Ù„Ø¨ ÙÙŠ Ø§Ù„Ø£Ø±Ø´ÙŠÙ ØªØ·Ø§Ø¨Ù‚ Ø¨Ø­Ø«Ùƒ.</p>';
        } else { // Corrected logic
            listDiv.innerHTML = `
                <table class="modern-table">
                    <thead>
                        <tr>
                            <th>Ø§Ø³Ù… Ø§Ù„Ù‚Ø§Ù„Ø¨ (Ø§Ù„Ø³Ø¤Ø§Ù„)</th>
                            <th>Ø§Ù„ØªØµÙ†ÙŠÙ</th>
                            <th>Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…</th>
                            <th class="actions-column">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${templatesToDisplay.map(template => `
                            <tr data-question="${(template.name || '').toLowerCase()}" data-classification="${template.classification || 'All'}">
                                <td data-label="Ø§Ø³Ù… Ø§Ù„Ù‚Ø§Ù„Ø¨">${template.name || 'Ù‚Ø§Ù„Ø¨ Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…'}</td>
                                <td data-label="Ø§Ù„ØªØµÙ†ÙŠÙ"><span class="classification-badge classification-${(template.classification || 'all').toLowerCase()}">${template.classification || 'Ø§Ù„ÙƒÙ„'}</span></td>
                                <td data-label="Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…">${template.usage_count} / ${template.usage_limit}</td>
                                <td class="actions-cell">
                                    <button class="btn-primary reactivate-template-btn btn-small" data-id="${template._id}"><i class="fas fa-undo"></i> Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„</button>
                                    ${canEdit ? `<button class="btn-danger delete-template-btn btn-small" data-id="${template._id}"><i class="fas fa-trash-alt"></i> Ø­Ø°Ù Ù†Ù‡Ø§Ø¦ÙŠ</button>` : ''}
                                </td> 
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }
    }

    function setupArchiveFilters() {
        const searchInput = document.getElementById('archive-search-input');
        const clearBtn = document.getElementById('archive-search-clear');
        const filterButtons = document.querySelectorAll('.template-filters .filter-btn');

        const applyFilters = () => {
            if (clearBtn) clearBtn.style.display = searchInput.value ? 'block' : 'none';
            const searchTerm = searchInput.value.toLowerCase().trim();
            const activeFilter = document.querySelector('.template-filters .filter-btn.active').dataset.filter;

            const filtered = allArchivedTemplates.filter(template => {
                const matchesSearch = searchTerm === '' || template.name.toLowerCase().includes(searchTerm);
                const matchesFilter = activeFilter === 'all' || (template.classification || 'All') === activeFilter;
                return matchesSearch && matchesFilter;
            });
            displayArchived(filtered);
        };

        searchInput.addEventListener('input', applyFilters);
        clearBtn.addEventListener('click', () => { searchInput.value = ''; applyFilters(); });
        filterButtons.forEach(btn => btn.addEventListener('click', () => {
            filterButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            applyFilters();
        }));
    }

    async function loadAndDisplayArchived() {
        const response = await authedFetch('/api/templates?archived=true');

        if (!response.ok) {
            listDiv.innerHTML = `<p class="error">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ø±Ø´ÙŠÙ.</p>`;
            console.error('Archive fetch error:', await response.text());
            return;
        }
        const { data } = await response.json();
        allArchivedTemplates = data || [];
        displayArchived(allArchivedTemplates || []);
        setupArchiveFilters();
    }

    listDiv.addEventListener('click', async (e) => {
        const reactivateBtn = e.target.closest('.reactivate-template-btn');
        const deleteBtn = e.target.closest('.delete-template-btn');

        if (reactivateBtn) {
            const id = reactivateBtn.dataset.id;
            showConfirmationModal('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø§Ù„Ø¨ØŸ<br><small>Ø³ÙŠØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¹Ø¯Ø§Ø¯ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ Ø¥Ù„Ù‰ Ø§Ù„ØµÙØ±.</small>', async () => {
                const response = await authedFetch(`/api/templates/${id}/reactivate`, { method: 'PUT' });
                if (!response.ok) {
                    const result = await response.json();
                    showToast(result.message || 'ÙØ´Ù„ Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù‚Ø§Ù„Ø¨.', 'error');
                } else {
                    showToast('ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                    await loadAndDisplayArchived();
                }
            }, { title: 'ØªØ£ÙƒÙŠØ¯ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙØ¹ÙŠÙ„' });
        }

        if (deleteBtn) {
            const id = deleteBtn.dataset.id;
            showConfirmationModal('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø­Ø°Ù Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù„Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø§Ù„Ø¨ØŸ<br><small>Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡.</small>', async () => {
                const response = await authedFetch(`/api/templates/${id}`, { method: 'DELETE' });
                if (!response.ok) {
                    const result = await response.json();
                    showToast(result.message || 'ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù‚Ø§Ù„Ø¨.', 'error');
                } else {
                    showToast('ØªÙ… Ø­Ø°Ù Ø§Ù„Ù‚Ø§Ù„Ø¨ Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹.', 'success');
                    await loadAndDisplayArchived();
                }
            }, { title: 'ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ', confirmText: 'Ø­Ø°Ù Ù†Ù‡Ø§Ø¦ÙŠ', confirmClass: 'btn-danger' });
        }
    });

    await loadAndDisplayArchived();
}

function renderEditTemplateModal(template, onSaveCallback) {
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    let templateImageFile = null; // Variable to hold the new image file

    const modal = document.createElement('div');
    modal.className = 'form-modal-content modal-fullscreen'; // Use fullscreen for consistency

    modal.innerHTML = `
        <div class="form-modal-header">
            <h2><i class="fas fa-edit"></i> ØªØ¹Ø¯ÙŠÙ„ Ù‚Ø§Ù„Ø¨ Ù…Ø³Ø§Ø¨Ù‚Ø©</h2>
            <button id="close-modal-btn" class="btn-icon-action" title="Ø¥ØºÙ„Ø§Ù‚">&times;</button>
        </div>
        <div class="form-modal-body">
            <form id="edit-template-form" class="template-form-grid">
                <div class="template-form-fields">
                    <h3 class="details-section-title" style="margin-top: 0;"><i class="fas fa-info-circle"></i> Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©</h3>
                    <div class="form-group">
                        <label for="edit-template-question">Ø§Ù„Ø³Ø¤Ø§Ù„ (Ø³ÙŠÙƒÙˆÙ† Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©)</label>
                        <textarea id="edit-template-question" rows="3" required>${template.name}</textarea>
                    </div>
                    <div class="form-group">
                        <label for="edit-template-correct-answer">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©</label>
                        <textarea id="edit-template-correct-answer" rows="2" required>${template.correct_answer || ''}</textarea>
                    </div>
                    <div class="form-group">
                        <label for="edit-template-classification">Ø§Ù„ØªØµÙ†ÙŠÙ</label>
                        <select id="edit-template-classification" required>
                            <option value="All" ${template.classification === 'All' ? 'selected' : ''}>Ø¹Ø§Ù…</option>
                            <option value="R" ${template.classification === 'R' ? 'selected' : ''}>R</option>
                            <option value="A" ${template.classification === 'A' ? 'selected' : ''}>A</option>
                            <option value="B" ${template.classification === 'B' ? 'selected' : ''}>B</option>
                            <option value="C" ${template.classification === 'C' ? 'selected' : ''}>C</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="edit-template-usage-limit">
                            Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… (Ø§ØªØ±ÙƒÙ‡ ÙØ§Ø±ØºØ§Ù‹ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ØºÙŠØ± Ø§Ù„Ù…Ø­Ø¯ÙˆØ¯)
                            <small style="display: block; color: var(--text-secondary-color);">Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø­Ø§Ù„ÙŠØ§Ù‹: ${template.usage_count || 0}</small>
                        </label>
                        <input type="number" id="edit-template-usage-limit" min="1" placeholder="Ù…Ø«Ø§Ù„: 5" value="${template.usage_limit || ''}">
                    </div>
                </div>
                <div class="template-form-content">
                    <h3 class="details-section-title" style="margin-top: 0;"><i class="fas fa-file-alt"></i> Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</h3>
                    <div class="form-group">
                        <label>ØµÙˆØ±Ø© Ø§Ù„Ù‚Ø§Ù„Ø¨</label>
                        <div class="image-preview-container">
                            <img id="edit-template-image-preview" src="${template.image_url || 'images/competition_bg.jpg'}" alt="ØµÙˆØ±Ø© Ø§Ù„Ù‚Ø§Ù„Ø¨" class="image-preview">
                        </div>
                        <input type="file" id="edit-template-image-upload" accept="image/*" style="display: none;">
                        <button type="button" id="change-template-image-btn" class="btn-secondary btn-small" style="margin-top: 10px;"><i class="fas fa-edit"></i> ØªØºÙŠÙŠØ± Ø§Ù„ØµÙˆØ±Ø©</button>
                    </div>
                    <div class="form-group">
                        <label for="edit-template-content">Ù†Øµ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</label>
                        <textarea id="edit-template-content" rows="15" required>${template.content}</textarea>
                    </div>
                </div>
                <div class="form-actions template-form-actions">
                    <button type="submit" class="btn-primary"><i class="fas fa-save"></i> Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª</button>
                    <button type="button" id="cancel-edit-modal" class="btn-secondary">Ø¥Ù„ØºØ§Ø¡</button>
                </div>
            </form>
        </div>
    `;
    
    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    const closeModal = () => overlay.remove();

    // Image manipulation listeners
    const imageUploadInput = document.getElementById('edit-template-image-upload');
    const changeImageBtn = document.getElementById('change-template-image-btn');
    const imagePreview = document.getElementById('edit-template-image-preview');

    changeImageBtn.addEventListener('click', () => imageUploadInput.click());

    imageUploadInput.addEventListener('change', () => {
        const file = imageUploadInput.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.src = e.target.result;
            };
            reader.readAsDataURL(file);
            templateImageFile = file;
        }
    });

    document.getElementById('close-modal-btn').addEventListener('click', closeModal);
    document.getElementById('cancel-edit-modal').addEventListener('click', closeModal);

    document.getElementById('edit-template-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const submitBtn = e.target.querySelector('button[type="submit"]');
        const originalBtnHtml = submitBtn.innerHTML;
        submitBtn.disabled = true;
        console.log('Edit template form submitted.');

        try {
            let finalImageUrl = template.image_url; // Start with the existing image URL

            // Defensively strip origin if it's a localhost URL
            if (finalImageUrl && finalImageUrl.startsWith('http://localhost')) {
                try {
                    const url = new URL(finalImageUrl);
                    finalImageUrl = url.pathname;
                } catch (e) {
                    console.error('Could not parse existing template image URL:', e);
                }
            }

            console.log('Initial image URL:', finalImageUrl);
            console.log('templateImageFile:', templateImageFile);

            if (templateImageFile) {
                console.log('New template image file detected. Uploading...');
                submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©...';
                const formData = new FormData();
                formData.append('image', templateImageFile);

                const uploadResponse = await authedFetch('/api/competitions/upload-image', { method: 'POST', body: formData });

                if (!uploadResponse.ok) {
                    const errorText = await uploadResponse.text();
                    console.error('Image upload failed. Status:', uploadResponse.status, 'Response:', errorText);
                    throw new Error('ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©.');
                }
                
                const uploadResult = await uploadResponse.json();
                finalImageUrl = uploadResult.imageUrl;
                console.log('Image uploaded successfully. New image URL:', finalImageUrl);
            } else {
                console.log('No new image file. Keeping existing URL.');
            }
            
            submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª...';

            const updatedData = {
                name: document.getElementById('edit-template-question').value.trim(),
                classification: document.getElementById('edit-template-classification').value,
                content: document.getElementById('edit-template-content').value.trim(),
                correct_answer: document.getElementById('edit-template-correct-answer').value.trim(),
                usage_limit: document.getElementById('edit-template-usage-limit').value ? parseInt(document.getElementById('edit-template-usage-limit').value, 10) : null,
                image_url: finalImageUrl // Use the new or existing image URL
            };

            console.log('Submitting updated template data:', updatedData);

            const response = await authedFetch(`/api/templates/${template._id}`, {
                method: 'PUT',
                body: JSON.stringify(updatedData)
            });

            if (!response.ok) {
                const result = await response.json();
                console.error('Failed to save template:', result);
                throw new Error(result.message || 'ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª.');
            }
            
            showToast('ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¨Ù†Ø¬Ø§Ø­.', 'success');
            closeModal();
            if (onSaveCallback) onSaveCallback();

        } catch (error) {
            showToast(error.message, 'error');
            console.error('Template edit failed:', error);
            submitBtn.disabled = false;
            submitBtn.innerHTML = originalBtnHtml;
        }
    });
}

// New function to display competition details in a dedicated section
function displayCompetitionDetails(competition) {
    const detailsContainer = document.getElementById('competition-details-container');
    if (!detailsContainer) return;

    // Basic info
    detailsContainer.innerHTML = `
        <h2>ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©: ${competition.name}</h2>
        <p><strong>Ø§Ù„ÙˆØµÙ:</strong> ${competition.description || 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆØµÙ Ù…ØªØ§Ø­.'}</p>
        <p><strong>Ø§Ù„Ø­Ø§Ù„Ø©:</strong> ${competition.is_active ? 'Ù†Ø´Ø·Ø©' : 'ØºÙŠØ± Ù†Ø´Ø·Ø©'}</p>
        <p><strong>ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¨Ø¯Ø¡:</strong> ${new Date(competition.starts_at).toLocaleString('ar-EG')}</p>
        <p><strong>ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡:</strong> ${new Date(competition.ends_at).toLocaleString('ar-EG')}</p>
    `;

    // Agent info
    if (competition.agents) {
        const agent = competition.agents;
        detailsContainer.innerHTML += `
            <div class="agent-info-card">
                <h3>Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„</h3>
                <p><strong>Ø§Ù„Ø§Ø³Ù…:</strong> ${agent.name}</p>
                <p><strong>Ø§Ù„ØªØµÙ†ÙŠÙ:</strong> ${agent.classification || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}</p>
                <p><strong>Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ:</strong> $${Math.max(0, agent.remaining_balance || 0)}</p>
            </div>
        `;
    }

    // --- FIX: Display the actual winner selection request date from `processed_at` ---
    const winnerDateElement = document.querySelector('.competition-winner-date');
    if (winnerDateElement) {
        let winnerDateHtml = '<strong>ØªØ§Ø±ÙŠØ® Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø²:</strong> ';
        if (competition.processed_at) {
            const formattedWinnerDate = new Intl.DateTimeFormat('ar-EG', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            }).format(new Date(competition.processed_at));
            winnerDateHtml += `<span class="date-value">${formattedWinnerDate}</span>`;
        } else {
            winnerDateHtml += `<span class="date-value" style="color: var(--warning-color);">Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¨Ø¹Ø¯</span>`;
        }
        winnerDateElement.innerHTML = winnerDateHtml;
    }
    
    console.log('Competition Processed At:', competition.processed_at);
}


// == templates.js ==
ï»¿// Competition Templates page and modal logic extracted from competitions.js
// This file contains functions to render the templates page, archived templates,
// and the create/edit modals. It depends on global helpers: authedFetch, showToast,
// renderCreateTemplateModal, renderEditTemplateModal, showConfirmationModal, currentUserProfile

async function renderCompetitionTemplatesPage() {
    // --- NEW: Permission Check ---
    const appContent = document.getElementById('app-content');
    const isSuperAdmin = currentUserProfile?.role === 'super_admin';
    const isAdmin = isSuperAdmin || currentUserProfile?.role === 'admin';
    const templatesPerm = currentUserProfile?.permissions?.competitions?.manage_templates || 'none';
    const canView = isAdmin || templatesPerm === 'full' || templatesPerm === 'view';

    if (!canView) {
        appContent.innerHTML = `
            <div class="access-denied-container">
                <i class="fas fa-lock"></i>
                <h2>Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© ÙˆØµÙˆÙ„</h2>
                <p>Ø£Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø¯ÙŠØ±.</p>
            </div>`;
        return;
    }

    const canEdit = isAdmin || templatesPerm === 'full';
    document.querySelector('main').classList.add('full-width');

    const defaultTemplateContent = `Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† Ø´Ø±ÙƒØ© Ø¥Ù†Ø²Ùˆ Ù„Ù„ØªØ¯Ø§ÙˆÙ„ ğŸ†

âœ¨ Ù‡Ù„ ØªÙ…Ù„Ùƒ Ø¹ÙŠÙ†Ù‹Ø§ Ø®Ø¨ÙŠØ±Ø© ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø´Ø§Ø±ØªØ§ØªØŸ Ø§Ø®ØªØ¨Ø± Ù†ÙØ³Ùƒ ÙˆØ§Ø±Ø¨Ø­!

ğŸ’° Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©: {{prize_details}}
                 {{deposit_bonus_prize_details}}

â“ Ø³Ø¤Ø§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©:
{{question}}

ğŸ“ ÙƒÙŠÙÙŠØ© Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©:
Ø¶Ø¹ ØªØ¹Ù„ÙŠÙ‚Ùƒ Ø¹Ù„Ù‰ Ù…Ù†Ø´ÙˆØ± Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¨Ø§Ù„Ù‚Ù†Ø§Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø­Ø³Ø§Ø¨Ùƒ Ø§Ù„Ø´Ø®ØµÙŠ Ø¹Ù„Ù‰ ØªÙ„ÙŠØ¬Ø±Ø§Ù….

ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªØ¶Ù…Ù† ØªØ¹Ù„ÙŠÙ‚Ùƒ:
â€¢ Ø¥Ø¬Ø§Ø¨ØªÙƒ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¤Ø§Ù„.
â€¢ Ø§Ø³Ù…Ùƒ Ø§Ù„Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ù…Ø³Ø¬Ù„ Ø¨Ø§Ù„ÙˆØ«Ø§Ø¦Ù‚.
â€¢ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ¯Ø§ÙˆÙ„ÙŠ.

ÙŠÙÙ…Ù†Ø¹ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚ Ø¨Ø¹Ø¯ Ù†Ø´Ø±Ù‡ØŒ ÙˆØ£ÙŠ ØªØ¹Ù„ÙŠÙ‚ Ù…ÙØ¹Ø¯Ù„ Ø³ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¹Ø§Ø¯Ù‡ Ù…Ø¨Ø§Ø´Ø±Ø©.

â³ Ù…Ø¯Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©: {{competition_duration}}

ğŸ“š ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ø¹Ø±ÙØ© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ÙˆØªØ¹Ù„Ù‘Ù… Ø§Ù„Ù…Ø²ÙŠØ¯ Ø¹Ù† Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„ÙÙ†ÙŠØ© ÙˆØ£Ø³Ø§Ù„ÙŠØ¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ±Ø³ Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠ Ø§Ù„Ù…Ù‚Ø¯Ù… Ù…Ù† Ø§Ù„Ø®Ø¨ÙŠØ± Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠ Ø£. Ø´Ø±ÙŠÙ Ø®ÙˆØ±Ø´ÙŠØ¯ Ø¹Ù„Ù‰ Ù…ÙˆÙ‚Ø¹ Ø¥Ù†Ø²Ùˆ. ğŸ†“

âœ¨ Ù„Ø§ ØªÙÙˆØª Ø§Ù„ÙØ±ØµØ©!
Ø¬Ø§ÙˆØ¨ ØµØ­ØŒ Ø§Ø®ØªØ¨Ø± Ù…Ø¹Ø±ÙØªÙƒØŒ ÙˆÙƒÙ† Ø§Ù„ÙØ§Ø¦Ø² Ù…Ø¹ Ø¥Ù†Ø²Ùˆ ğŸ`;

    appContent.innerHTML = `
        <div class="page-header">
            <div class="header-top-row">
                <h1><i class="fas fa-file-alt"></i> Ø¥Ø¯Ø§Ø±Ø© Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª</h1>
                <button id="show-template-form-btn" class="btn-primary"><i class="fas fa-plus-circle"></i> Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ù„Ø¨ Ø¬Ø¯ÙŠØ¯</button>
            </div>
            <div class="template-filters">
                <div class="filter-search-container">
                    <input type="search" id="template-search-input" placeholder="Ø¨Ø­Ø« Ø¨Ø§Ø³Ù… Ø§Ù„Ù‚Ø§Ù„Ø¨..." autocomplete="off">
                    <i class="fas fa-search"></i>
                    <i class="fas fa-times-circle search-clear-btn" id="template-search-clear"></i>
                </div>
                <div class="filter-buttons" data-filter-group="classification">
                    <button class="filter-btn active" data-filter="all">Ø§Ù„ÙƒÙ„</button>
                    <button class="filter-btn" data-filter="R">R</button>
                    <button class="filter-btn" data-filter="A">A</button>
                    <button class="filter-btn" data-filter="B">B</button>
                    <button class="filter-btn" data-filter="C">C</button>
                    <button class="filter-btn" data-filter="All">Ø¹Ø§Ù…</button>
                </div>
            </div>
        </div>
        <div class="templates-list-container">
            <div id="templates-list" class="templates-list-grouped"></div>
        </div>
    `;

    const templatesListDiv = document.getElementById('templates-list');
    const showFormBtn = document.getElementById('show-template-form-btn');

    if (showFormBtn) {
        if (canEdit) {
            showFormBtn.addEventListener('click', () => renderCreateTemplateModal(defaultTemplateContent, loadTemplates));
        } else {
            showFormBtn.addEventListener('click', () => showToast('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù‚ÙˆØ§Ù„Ø¨.', 'error'));
        }
    }

    async function loadTemplates() {
        const response = await authedFetch('/api/templates?archived=false');

        if (!response.ok) {
            console.error('Error fetching templates:', await response.text());
            templatesListDiv.innerHTML = '<p class="error">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨.</p>';
            return;
        }

        const { data: templates } = await response.json();
        const classificationOrder = { 'R': 1, 'A': 2, 'B': 3, 'C': 4, 'All': 5 };
        templates.sort((a, b) => {
            const orderA = classificationOrder[a.classification] || 99;
            const orderB = classificationOrder[b.classification] || 99;
            if (orderA !== orderB) {
                return orderA - orderB;
            }
            return (a.question || '').localeCompare(b.question || '');
        });

        if (templates.length === 0) {
            templatesListDiv.innerHTML = '<p class="no-results-message">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚ÙˆØ§Ù„Ø¨ Ù…Ø­ÙÙˆØ¸Ø© Ø¨Ø¹Ø¯.</p>';
        } else {
            const groupedTemplates = templates.reduce((acc, template) => {
                const key = template.classification || 'All';
                if (!acc[key]) acc[key] = [];
                acc[key].push(template);
                return acc;
            }, {});

            const classificationOrderArr = ['R', 'A', 'B', 'C', 'All'];
            let groupsHtml = '';

            for (const classification of classificationOrderArr) {
                if (groupedTemplates[classification]) {
                    const group = groupedTemplates[classification];
                    groupsHtml += `
                        <details class="template-group" data-classification-group="${classification}" open>
                            <summary class="template-group-header">
                                <h2>ØªØµÙ†ÙŠÙ ${classification === 'All' ? 'Ø¹Ø§Ù…' : classification}</h2>
                                <span class="template-count">${group.length} Ù‚ÙˆØ§Ù„Ø¨</span>
                            </summary>
                            <div class="template-group-content">
                                ${group.map(template => `
                                <div class="template-card" data-id="${template._id}" data-question="${(template.question || '').toLowerCase()}" data-classification="${template.classification || 'All'}">
                                        <div class="template-card-header">
                                        <h4>${template.question || 'Ù‚Ø§Ù„Ø¨ Ø¨Ø¯ÙˆÙ† Ø³Ø¤Ø§Ù„'}</h4>
                                        </div>
                                        <div class="template-card-body">
                                            <p>${template.content.substring(0, 120)}...</p>
                                        </div>
                                        <div class="template-card-footer">
                                            <button class="btn-secondary edit-template-btn" data-id="${template._id}"><i class="fas fa-edit"></i> ØªØ¹Ø¯ÙŠÙ„</button>
                                            <button class="btn-danger delete-template-btn" data-id="${template._id}"><i class="fas fa-trash-alt"></i> Ø­Ø°Ù</button>
                                        </div> 
                                    </div>
                                `).join('')}
                            </div>
                        </details>
                    `;
                }
            }
            templatesListDiv.innerHTML = groupsHtml;
        }
    }

    templatesListDiv.addEventListener('click', async (e) => {
        const editBtn = e.target.closest('.edit-template-btn');
        if (editBtn) {
            if (!canEdit) {
                showToast('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨.', 'error');
                return;
            }
            const id = editBtn.dataset.id;
            const response = await authedFetch(`/api/templates/${id}`);
            const { data: template } = await response.json();
            if (!response.ok || !template) {
                showToast('ÙØ´Ù„ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø§Ù„Ø¨.', 'error');
                return;
            }
            renderEditTemplateModal(template, loadTemplates);
        }

        const deleteBtn = e.target.closest('.delete-template-btn');
        if (deleteBtn) {
            if (!canEdit) {
                showToast('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ø­Ø°Ù Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨.', 'error');
                return;
            }
            const templateId = deleteBtn.dataset.id;
            showConfirmationModal(
                'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø§Ù„Ø¨ØŸ<br><small>Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡.</small>',
                async () => {
                    const response = await authedFetch(`/api/templates/${templateId}/archive`, { method: 'PATCH' });
                    if (!response.ok) {
                        const result = await response.json();
                        showToast(result.message || 'ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù‚Ø§Ù„Ø¨.', 'error');
                    } else {
                        showToast('ØªÙ… Ø­Ø°Ù Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                        await loadTemplates();
                    }
                },
                { title: 'ØªØ£ÙƒÙŠØ¯ Ø­Ø°Ù Ø§Ù„Ù‚Ø§Ù„Ø¨', confirmText: 'Ø­Ø°Ù', confirmClass: 'btn-danger' }
            );
        }
    });

    await loadTemplates();
    setupTemplateFilters();
}

function renderCreateTemplateModal(defaultContent, onSaveCallback) {
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    
    let templateImageFile = null; // Variable to hold the new image file

    const modal = document.createElement('div');
    modal.className = 'form-modal-content modal-fullscreen';
    
    modal.innerHTML = `
        <div class="form-modal-header">
            <h2><i class="fas fa-plus-circle"></i> Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ù„Ø¨ Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¬Ø¯ÙŠØ¯</h2>
            <button id="close-modal-btn" class="btn-icon-action" title="Ø¥ØºÙ„Ø§Ù‚">&times;</button>
        </div>
        <div class="form-modal-body">
            <form id="create-template-form" class="template-form-grid template-form-stacked">
                    <div class="template-form-fields">
                    <h3 class="details-section-title" style="margin-top: 0;"><i class="fas fa-info-circle"></i> Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©</h3>
                    <div class="form-group">
                        <label for="create-template-question">Ø§Ù„Ø³Ø¤Ø§Ù„ (Ø³ÙŠÙƒÙˆÙ† Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©)</label>
                        <textarea id="create-template-question" rows="3" required></textarea>
                        <div id="template-question-validation" class="validation-error" style="display: none; margin-top: 8px; font-size: 0.9em;"></div>
                    </div>
                    <div class="form-group">
                        <label for="create-template-correct-answer">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©</label>
                        <textarea id="create-template-correct-answer" rows="2" required></textarea>
                    </div>
                    <div class="form-group">
                        <label for="create-template-classification">Ø§Ù„ØªØµÙ†ÙŠÙ (Ù„Ù…Ù† Ø³ÙŠØ¸Ù‡Ø± Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø§Ù„Ø¨)</label>
                        <select id="create-template-classification" required>
                            <option value="All" selected>Ø¹Ø§Ù… (ÙŠØ¸Ù‡Ø± Ù„Ù„Ø¬Ù…ÙŠØ¹)</option>
                            <option value="R">R</option>
                            <option value="A">A</option>
                            <option value="B">B</option>
                            <option value="C">C</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="create-template-type">Ø§Ù„Ù†ÙˆØ¹</label>
                        <select id="create-template-type" required>
                            <option value="Ù…Ù…ÙŠØ²Ø§Øª" selected>Ù…Ù…ÙŠØ²Ø§Øª</option>
                            <option value="ØªÙØ§Ø¹Ù„ÙŠØ©">ØªÙØ§Ø¹Ù„ÙŠØ©</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="create-template-usage-limit">Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… (Ø§ØªØ±ÙƒÙ‡ ÙØ§Ø±ØºØ§Ù‹ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ØºÙŠØ± Ø§Ù„Ù…Ø­Ø¯ÙˆØ¯)</label>
                        <input type="number" id="create-template-usage-limit" min="1" placeholder="Ù…Ø«Ø§Ù„: 5">
                    </div>
                </div>
                <div class="template-form-content">
                    <h3 class="details-section-title" style="margin-top: 0;"><i class="fas fa-file-alt"></i> Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</h3>
                    <!-- NEW: Image Preview Section with upload button -->
                    <div class="form-group">
                        <label>ØµÙˆØ±Ø© Ø§Ù„Ù‚Ø§Ù„Ø¨</label>
                        <div class="image-preview-container">
                            <img id="create-template-image-preview" src="images/competition_bg.jpg" alt="ØµÙˆØ±Ø© Ø§Ù„Ù‚Ø§Ù„Ø¨" class="image-preview">
                        </div>
                        <input type="file" id="create-template-image-upload" accept="image/*" style="display: none;">
                        <button type="button" id="change-template-image-btn" class="btn-secondary btn-small" style="margin-top: 10px;"><i class="fas fa-edit"></i> ØªØºÙŠÙŠØ± Ø§Ù„ØµÙˆØ±Ø©</button>
                    </div>
                    <div class="form-group">
                        <label for="create-template-content">Ù†Øµ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</label>
                        <textarea id="create-template-content" rows="15" required>${defaultContent}</textarea>
                    </div>
                </div>
                <div class="form-actions template-form-actions">
                    <button type="submit" class="btn-primary"><i class="fas fa-save"></i> Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨</button>
                    <button type="button" id="cancel-create-modal" class="btn-secondary">Ø¥Ù„ØºØ§Ø¡</button>
                </div>
            </form>
        </div>
    `;

    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    const closeModal = () => overlay.remove();

    // --- NEW: Event Listeners for Image Manipulation ---
    const imageUploadInput = document.getElementById('create-template-image-upload');
    const changeImageBtn = document.getElementById('change-template-image-btn');
    const imagePreview = document.getElementById('create-template-image-preview');

    changeImageBtn.addEventListener('click', () => imageUploadInput.click());

    imageUploadInput.addEventListener('change', () => {
        const file = imageUploadInput.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.src = e.target.result;
            };
            reader.readAsDataURL(file);
            templateImageFile = file;
        }
    });

    // --- NEW: Live validation for template question ---
    const questionInput = document.getElementById('create-template-question');
    const validationDiv = document.getElementById('template-question-validation');
    let debounceTimeout;

    questionInput.addEventListener('input', () => {
        clearTimeout(debounceTimeout);
        debounceTimeout = setTimeout(async () => {
            const questionText = questionInput.value.trim();
            if (questionText) {
                try {
                    const response = await authedFetch(`/api/templates/check-existence?question=${encodeURIComponent(questionText)}`);
                    if (response.ok) {
                        const { exists, archived } = await response.json();
                        if (exists) {
                            if (archived) {
                                validationDiv.innerHTML = 'Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù‚Ø§Ù„Ø¨ Ù…Ø­Ø°ÙˆÙ. ÙŠÙ…ÙƒÙ†Ùƒ <a href="#archived-templates">Ø§Ø³ØªØ¹Ø§Ø¯ØªÙ‡ Ù…Ù† Ø§Ù„Ø£Ø±Ø´ÙŠÙ</a>.';
                            } else {
                                validationDiv.textContent = 'Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‚Ø§Ù„Ø¨ Ø¢Ø®Ø±.';
                            }
                            validationDiv.style.display = 'block';
                        } else {
                            validationDiv.style.display = 'none';
                        }
                    } else {
                        validationDiv.style.display = 'none'; // Hide on error
                    }
                } catch (error) {
                    console.error('Error checking template existence:', error);
                    validationDiv.style.display = 'none'; // Hide on error
                }
            } else {
                validationDiv.style.display = 'none';
            }
        }, 500); // 500ms debounce delay
    });

    document.getElementById('close-modal-btn').addEventListener('click', closeModal);
    document.getElementById('cancel-create-modal').addEventListener('click', closeModal);
    
    document.getElementById('create-template-form').addEventListener('submit', async (e) => {
        e.preventDefault();

        // --- NEW: Prevent submission if validation error is visible ---
        if (validationDiv.style.display === 'block') {
            showToast('Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ù„Ø£Ù† Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„.', 'error');
            return;
        }

        const submitBtn = e.target.querySelector('button[type="submit"]');
        const originalBtnHtml = submitBtn.innerHTML;
        submitBtn.disabled = true;

                    const questionText = document.getElementById('create-template-question').value.trim();        
                    if (!questionText) {
                        showToast('Ø­Ù‚Ù„ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…Ø·Ù„ÙˆØ¨.', 'error');
                        submitBtn.disabled = false;
                        return;
                    }
        
                    // Debugging: Log values before sending
                    console.log('DEBUG: Question Text (name/question):', questionText);
                    console.log('DEBUG: Template Content:', document.getElementById('create-template-content').value.trim());
                    console.log('DEBUG: Correct Answer:', document.getElementById('create-template-correct-answer').value.trim());
                    console.log('DEBUG: Classification:', document.getElementById('create-template-classification').value);
                    console.log('DEBUG: Usage Limit:', document.getElementById('create-template-usage-limit').value);
        
                    try {
                        let finalImageUrl = '/images/competition_bg.jpg'; // Default image
        
                        if (templateImageFile) {
                            submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©...';
                            const formData = new FormData();
                            formData.append('image', templateImageFile);
        
                            // Re-using the competition image upload endpoint
                            const uploadResponse = await authedFetch('/api/competitions/upload-image', { method: 'POST', body: formData });
        
                            if (!uploadResponse.ok) {
                                throw new Error('ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©.');
                            }
                            
                            const uploadResult = await uploadResponse.json();
                            finalImageUrl = uploadResult.imageUrl; // The backend should return the relative path
                        }
                        
                        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨...';
        
                        // ØªØ¬Ù…ÙŠØ¹ ÙƒÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø§Ù„Ø¨ Ù„Ù„Ø­ÙØ¸
                        const formData = {
                            // Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
                            question: questionText.trim(),
                            content: document.getElementById('create-template-content').value.trim(),
                            type: document.getElementById('create-template-type').value || 'Ù…Ù…ÙŠØ²Ø§Øª',
                            classification: document.getElementById('create-template-classification').value || 'All',
                            
                            // ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©
                            correct_answer: document.getElementById('create-template-correct-answer').value.trim(),
                            competition_type: 'standard',
                            prize_details: '',  // Ø³ÙŠØªÙ… ØªØ¹Ø¨Ø¦ØªÙ‡ Ù…Ù† Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø¹Ù†Ø¯ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
                            deposit_bonus_prize_details: '', // Ø³ÙŠØªÙ… ØªØ¹Ø¨Ø¦ØªÙ‡ Ù…Ù† Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø¹Ù†Ø¯ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
                            competition_duration: '', // Ø³ÙŠØªÙ… ØªØ¹Ø¨Ø¦ØªÙ‡ Ø¹Ù†Ø¯ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©
                            
                            // Ø¶ÙˆØ§Ø¨Ø· Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
                            usage_limit: document.getElementById('create-template-usage-limit').value ? 
                                parseInt(document.getElementById('create-template-usage-limit').value, 10) : null,
                            
                            // Ø§Ù„ÙˆØ³Ø§Ø¦Ø·
                            image_url: finalImageUrl,
                            
                            // Ø§Ù„Ø­Ø§Ù„Ø©
                            status: 'active',
                        };

                        console.log('DEBUG: Creating template with data:', formData);
                        console.log('DEBUG (Frontend): FormData before sending:', formData);
            const response = await authedFetch('/api/templates', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json;charset=UTF-8',
                    'Accept': 'application/json'
                },
                body: JSON.stringify(formData)
            });

            const result = await response.json();

            if (!response.ok) {
                console.error('Template creation failed:', result);
                throw new Error(result.message || 'ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨.');
            }
            
            console.log('Template created successfully:', result);
            showToast('ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
            closeModal();
            if (onSaveCallback) onSaveCallback();

        } catch (error) {
            showToast(error.message, 'error');
            console.error('Template creation failed:', error);
            submitBtn.disabled = false;
            submitBtn.innerHTML = originalBtnHtml;
        }
    });
}

function setupTemplateFilters() {
    const searchInput = document.getElementById('template-search-input');
    const clearBtn = document.getElementById('template-search-clear');
    const filterButtons = document.querySelectorAll('.template-filters .filter-btn');

    if (!searchInput) return;

    const applyFilters = () => {
        if (clearBtn) {
            clearBtn.style.display = searchInput.value ? 'block' : 'none';
        }

        const searchTerm = searchInput.value.toLowerCase().trim();
        const activeFilter = document.querySelector('.template-filters .filter-btn.active').dataset.filter;

        const allGroups = document.querySelectorAll('.template-group');
        let hasResults = false;

        allGroups.forEach(group => {
            const cards = group.querySelectorAll('.template-card');
            let visibleCardsInGroup = 0;

            cards.forEach(card => {
                const question = card.dataset.question || '';
                const classification = card.dataset.classification;

                const matchesSearch = searchTerm === '' || question.includes(searchTerm);
                const matchesFilter = activeFilter === 'all' || classification === activeFilter;

                const isVisible = matchesSearch && matchesFilter;
                card.style.display = isVisible ? '' : 'none';
                if (isVisible) {
                    visibleCardsInGroup++;
                }
            });

            group.style.display = visibleCardsInGroup > 0 ? '' : 'none';
            if (visibleCardsInGroup > 0) {
                hasResults = true;
            }
        });
    };

    searchInput.addEventListener('input', applyFilters);
    if (clearBtn) {
        clearBtn.addEventListener('click', () => {
            searchInput.value = '';
            applyFilters();
            searchInput.focus();
        });
    }

    filterButtons.forEach(button => {
        button.addEventListener('click', () => {
            filterButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            applyFilters();
        });
    });
}

async function renderArchivedTemplatesPage() {
    const appContent = document.getElementById('app-content');
    const isSuperAdmin = currentUserProfile?.role === 'super_admin';
    const isAdmin = isSuperAdmin || currentUserProfile?.role === 'admin';
    const templatesPerm = currentUserProfile?.permissions?.competitions?.manage_templates || 'none';
    const canView = isAdmin || templatesPerm === 'full' || templatesPerm === 'view';

    if (!canView) {
        appContent.innerHTML = ` <div class="access-denied-container">
                <i class="fas fa-lock"></i>
                <h2>Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© ÙˆØµÙˆÙ„</h2>
                <p>Ø£Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø¯ÙŠØ±.</p>
            </div>`;
        return;
    }
    document.querySelector('main').classList.add('full-width');

    appContent.innerHTML = `
        <div class="page-header">
            <div class="header-top-row">
                <h1><i class="fas fa-archive"></i> Ø£Ø±Ø´ÙŠÙ Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª</h1>
            </div>
            <div class="template-filters">
                <div class="filter-search-container">
                    <input type="search" id="archive-search-input" placeholder="Ø¨Ø­Ø« Ø¨Ø§Ø³Ù… Ø§Ù„Ù‚Ø§Ù„Ø¨..." autocomplete="off">
                    <i class="fas fa-search"></i>
                    <i class="fas fa-times-circle search-clear-btn" id="archive-search-clear"></i>
                </div>
                <div class="filter-buttons" data-filter-group="classification">
                    <button class="filter-btn active" data-filter="all">Ø§Ù„ÙƒÙ„</button>
                    <button class="filter-btn" data-filter="R">R</button>
                    <button class="filter-btn" data-filter="A">A</button>
                    <button class="filter-btn" data-filter="B">B</button>
                    <button class="filter-btn" data-filter="C">C</button>
                    <button class="filter-btn" data-filter="All">Ø¹Ø§Ù…</button>
                </div>
            </div>
        </div>
        <p class="page-subtitle" style="text-align: right; margin-top: 0;">Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„ØªÙŠ ÙˆØµÙ„Øª Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù…Ù† Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…. ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„Ù‡Ø§ Ù…Ù† Ù‡Ù†Ø§.</p>
        <div id="archived-templates-list" class="table-responsive-container">
            <p>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ø±Ø´ÙŠÙ...</p>
        </div>
    `;

    const listDiv = document.getElementById('archived-templates-list');
    let allArchivedTemplates = [];

    function displayArchived(templatesToDisplay) {
        const isSuperAdmin = currentUserProfile?.role === 'super_admin';
        const isAdmin = isSuperAdmin || currentUserProfile?.role === 'admin';
        const templatesPerm = currentUserProfile?.permissions?.competitions?.manage_templates || 'none';
        const canEdit = isAdmin || templatesPerm === 'full';
        if (templatesToDisplay.length === 0) {
            listDiv.innerHTML = '<p class="no-results-message">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚ÙˆØ§Ù„Ø¨ ÙÙŠ Ø§Ù„Ø£Ø±Ø´ÙŠÙ ØªØ·Ø§Ø¨Ù‚ Ø¨Ø­Ø«Ùƒ.</p>';
        } else {
            listDiv.innerHTML = `
                <table class="modern-table">
                    <thead>
                        <tr>
                            <th>Ø§Ø³Ù… Ø§Ù„Ù‚Ø§Ù„Ø¨ (Ø§Ù„Ø³Ø¤Ø§Ù„)</th>
                            <th>Ø§Ù„ØªØµÙ†ÙŠÙ</th>
                            <th>Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…</th>
                            <th class="actions-column">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${templatesToDisplay.map(template => `
                            <tr data-question="${(template.name || '').toLowerCase()}" data-classification="${template.classification || 'All'}">
                                <td data-label="Ø§Ø³Ù… Ø§Ù„Ù‚Ø§Ù„Ø¨">${template.name || 'Ù‚Ø§Ù„Ø¨ Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…'}</td>
                                <td data-label="Ø§Ù„ØªØµÙ†ÙŠÙ"><span class="classification-badge classification-${(template.classification || 'all').toLowerCase()}">${template.classification || 'Ø§Ù„ÙƒÙ„'}</span></td>
                                <td data-label="Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…">${template.usage_count} / ${template.usage_limit}</td>
                                <td class="actions-cell">
                                    <button class="btn-primary reactivate-template-btn btn-small" data-id="${template._id}"><i class="fas fa-undo"></i> Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„</button>
                                    ${canEdit ? `<button class="btn-danger delete-template-btn btn-small" data-id="${template._id}"><i class="fas fa-trash-alt"></i> Ø­Ø°Ù Ù†Ù‡Ø§Ø¦ÙŠ</button>` : ''}
                                </td> 
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }
    }

    function setupArchiveFilters() {
        const searchInput = document.getElementById('archive-search-input');
        const clearBtn = document.getElementById('archive-search-clear');
        const filterButtons = document.querySelectorAll('.template-filters .filter-btn');

        const applyFilters = () => {
            if (clearBtn) clearBtn.style.display = searchInput.value ? 'block' : 'none';
            const searchTerm = searchInput.value.toLowerCase().trim();
            const activeFilter = document.querySelector('.template-filters .filter-btn.active').dataset.filter;

            const filtered = allArchivedTemplates.filter(template => {
                const matchesSearch = searchTerm === '' || template.name.toLowerCase().includes(searchTerm);
                const matchesFilter = activeFilter === 'all' || (template.classification || 'All') === activeFilter;
                return matchesSearch && matchesFilter;
            });
            displayArchived(filtered);
        };

        searchInput.addEventListener('input', applyFilters);
        clearBtn.addEventListener('click', () => { searchInput.value = ''; applyFilters(); });
        filterButtons.forEach(btn => btn.addEventListener('click', () => {
            filterButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            applyFilters();
        }));
    }

    async function loadAndDisplayArchived() {
        const response = await authedFetch('/api/templates?archived=true');

        if (!response.ok) {
            listDiv.innerHTML = `<p class="error">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ø±Ø´ÙŠÙ.</p>`;
            console.error('Archive fetch error:', await response.text());
            return;
        }
        const { data } = await response.json();
        allArchivedTemplates = data || [];
        displayArchived(allArchivedTemplates || []);
        setupArchiveFilters();
    }

    listDiv.addEventListener('click', async (e) => {
        const reactivateBtn = e.target.closest('.reactivate-template-btn');
        const deleteBtn = e.target.closest('.delete-template-btn');

        if (reactivateBtn) {
            const id = reactivateBtn.dataset.id;
            showConfirmationModal('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø§Ù„Ø¨ØŸ<br><small>Ø³ÙŠØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¹Ø¯Ø§Ø¯ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ Ø¥Ù„Ù‰ Ø§Ù„ØµÙØ±.</small>', async () => {
                const response = await authedFetch(`/api/templates/${id}/reactivate`, { method: 'PUT' });
                if (!response.ok) {
                    const result = await response.json();
                    showToast(result.message || 'ÙØ´Ù„ Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù‚Ø§Ù„Ø¨.', 'error');
                } else {
                    showToast('ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                    await loadAndDisplayArchived();
                }
            }, { title: 'ØªØ£ÙƒÙŠØ¯ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙØ¹ÙŠÙ„' });
        }

        if (deleteBtn) {
            const id = deleteBtn.dataset.id;
            showConfirmationModal('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø­Ø°Ù Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù„Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø§Ù„Ø¨ØŸ<br><small>Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡.</small>', async () => {
                const response = await authedFetch(`/api/templates/${id}`, { method: 'DELETE' });
                if (!response.ok) {
                    const result = await response.json();
                    showToast(result.message || 'ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù‚Ø§Ù„Ø¨.', 'error');
                } else {
                    showToast('ØªÙ… Ø­Ø°Ù Ø§Ù„Ù‚Ø§Ù„Ø¨ Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹.', 'success');
                    await loadAndDisplayArchived();
                }
            }, { title: 'ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ', confirmText: 'Ø­Ø°Ù Ù†Ù‡Ø§Ø¦ÙŠ', confirmClass: 'btn-danger' });
        }
    });

    await loadAndDisplayArchived();
}

function renderEditTemplateModal(template, onSaveCallback) {
    // NEW: Full-screen edit modal replicating create modal structure with existing data populated.
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';

    let updatedImageFile = null;

    const modal = document.createElement('div');
    modal.className = 'form-modal-content modal-fullscreen';
    modal.innerHTML = `
        <div class="form-modal-header">
            <h2><i class="fas fa-edit"></i> ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù‚Ø§Ù„Ø¨</h2>
            <button id="close-edit-template-modal" class="btn-icon-action" title="Ø¥ØºÙ„Ø§Ù‚">&times;</button>
        </div>
        <div class="form-modal-body">
            <form id="edit-template-form" class="template-form-grid template-form-stacked">
                <div class="template-form-fields">
                    <h3 class="details-section-title" style="margin-top:0;"><i class="fas fa-info-circle"></i> Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©</h3>
                    <div class="form-group">
                        <label for="edit-template-question">Ø§Ù„Ø³Ø¤Ø§Ù„ (Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©)</label>
                        <textarea id="edit-template-question" rows="3" required>${template.question || ''}</textarea>
                        <div id="edit-template-question-validation" class="validation-error" style="display:none; margin-top:8px; font-size:0.9em;"></div>
                    </div>
                    <div class="form-group">
                        <label for="edit-template-correct-answer">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©</label>
                        <textarea id="edit-template-correct-answer" rows="2" required>${template.correct_answer || ''}</textarea>
                    </div>
                    <div class="form-group">
                        <label for="edit-template-classification">Ø§Ù„ØªØµÙ†ÙŠÙ</label>
                        <select id="edit-template-classification" required>
                            ${['All','R','A','B','C'].map(cls => `<option value="${cls}" ${template.classification === cls ? 'selected' : ''}>${cls === 'All' ? 'Ø¹Ø§Ù… (Ø§Ù„Ø¬Ù…ÙŠØ¹)' : cls}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="edit-template-type">Ø§Ù„Ù†ÙˆØ¹</label>
                        <select id="edit-template-type" required>
                            ${['Ù…Ù…ÙŠØ²Ø§Øª','ØªÙØ§Ø¹Ù„ÙŠØ©'].map(t => `<option value="${t}" ${template.type === t ? 'selected' : ''}>${t}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="edit-template-usage-limit">Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… (ÙØ§Ø±Øº = ØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯)</label>
                        <input type="number" id="edit-template-usage-limit" min="1" value="${template.usage_limit === null || template.usage_limit === undefined ? '' : template.usage_limit}">
                        <div style="display:block; margin-top:6px; color:var(--text-secondary-color); line-height:1.6;">
                            <div>Ø§Ø³ØªØ®Ø¯Ø§Ù…Ø§Øª Ø§Ù„Ø¯ÙˆØ±Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: <strong>${template.usage_count || 0}</strong>${template.usage_limit !== null && template.usage_limit !== undefined ? ` / ${template.usage_limit}` : ''}</div>
                            <div>Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: <strong>${(template.usage_total ?? (Array.isArray(template.times_used) ? template.times_used.length : 0) + (template.usage_count || 0))}</strong></div>
                        </div>
                    </div>
                </div>
                <div class="template-form-content">
                    <h3 class="details-section-title" style="margin-top:0;"><i class="fas fa-file-alt"></i> Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</h3>
                    <div class="form-group">
                        <label>ØµÙˆØ±Ø© Ø§Ù„Ù‚Ø§Ù„Ø¨</label>
                        <div class="image-preview-container">
                            <img id="edit-template-image-preview" src="${template.image_url || 'images/competition_bg.jpg'}" alt="ØµÙˆØ±Ø© Ø§Ù„Ù‚Ø§Ù„Ø¨" class="image-preview">
                        </div>
                        <input type="file" id="edit-template-image-upload" accept="image/*" style="display:none;">
                        <button type="button" id="change-edit-template-image-btn" class="btn-secondary btn-small" style="margin-top:10px;"><i class="fas fa-edit"></i> ØªØºÙŠÙŠØ± Ø§Ù„ØµÙˆØ±Ø©</button>
                    </div>
                    <div class="form-group">
                        <label for="edit-template-content">Ù†Øµ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</label>
                        <textarea id="edit-template-content" rows="15" required>${template.content || ''}</textarea>
                    </div>
                </div>
                <div class="form-actions template-form-actions">
                    <button type="submit" class="btn-primary"><i class="fas fa-save"></i> Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª</button>
                    <button type="button" id="cancel-edit-template-modal" class="btn-secondary">Ø¥Ù„ØºØ§Ø¡</button>
                </div>
            </form>
        </div>
    `;

    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    const closeModal = () => overlay.remove();
    document.getElementById('close-edit-template-modal').addEventListener('click', closeModal);
    document.getElementById('cancel-edit-template-modal').addEventListener('click', closeModal);

    // Image handling
    const imageUploadInput = document.getElementById('edit-template-image-upload');
    const changeImageBtn = document.getElementById('change-edit-template-image-btn');
    const imagePreview = document.getElementById('edit-template-image-preview');
    changeImageBtn.addEventListener('click', () => imageUploadInput.click());
    imageUploadInput.addEventListener('change', () => {
        const file = imageUploadInput.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = e => { imagePreview.src = e.target.result; };
            reader.readAsDataURL(file);
            updatedImageFile = file;
        }
    });

    // Live duplicate question validation
    const questionInput = document.getElementById('edit-template-question');
    const validationDiv = document.getElementById('edit-template-question-validation');
    let debounceTimeout;
    questionInput.addEventListener('input', () => {
        clearTimeout(debounceTimeout);
        debounceTimeout = setTimeout(async () => {
            const text = questionInput.value.trim();
            if (!text || text === template.question) { validationDiv.style.display='none'; return; }
            try {
                const resp = await authedFetch(`/api/templates/check-existence?question=${encodeURIComponent(text)}`);
                if (resp.ok) {
                    const { exists, archived } = await resp.json();
                    if (exists) {
                        validationDiv.innerHTML = archived ? 'Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù‚Ø§Ù„Ø¨ Ù…Ø­Ø°ÙˆÙ.' : 'Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‚Ø§Ù„Ø¨ Ø¢Ø®Ø±.';
                        validationDiv.style.display = 'block';
                    } else {
                        validationDiv.style.display = 'none';
                    }
                } else { validationDiv.style.display='none'; }
            } catch (err) { validationDiv.style.display='none'; }
        }, 500);
    });

    document.getElementById('edit-template-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        if (validationDiv.style.display === 'block') { showToast('Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ù„Ø£Ù† Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…Ø³ØªØ®Ø¯Ù….', 'error'); return; }

        const submitBtn = e.target.querySelector('button[type="submit"]');
        const originalHtml = submitBtn.innerHTML;
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...';

        try {
            let finalImageUrl = template.image_url || 'images/competition_bg.jpg';
            if (updatedImageFile) {
                const formData = new FormData();
                formData.append('image', updatedImageFile);
                const uploadResp = await authedFetch('/api/competitions/upload-image', { method: 'POST', body: formData });
                if (!uploadResp.ok) throw new Error('ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©');
                const uploadResult = await uploadResp.json();
                finalImageUrl = uploadResult.imageUrl;
            }

            const payload = {
                question: questionInput.value.trim(),
                correct_answer: document.getElementById('edit-template-correct-answer').value.trim(),
                classification: document.getElementById('edit-template-classification').value,
                type: document.getElementById('edit-template-type').value,
                usage_limit: document.getElementById('edit-template-usage-limit').value ? parseInt(document.getElementById('edit-template-usage-limit').value,10) : null,
                content: document.getElementById('edit-template-content').value.trim(),
                image_url: finalImageUrl
            };

            const resp = await authedFetch(`/api/templates/${template._id}` , {
                method: 'PUT',
                headers: { 'Content-Type':'application/json;charset=UTF-8','Accept':'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await resp.json();
            if (!resp.ok) throw new Error(result.message || 'ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª.');

            showToast('ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¨Ù†Ø¬Ø§Ø­.', 'success');
            closeModal();
            if (onSaveCallback) onSaveCallback();
        } catch (err) {
            console.error('Edit template failed:', err);
            showToast(err.message || 'ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª.', 'error');
            submitBtn.disabled = false;
            submitBtn.innerHTML = originalHtml;
        }
    });
}

// Export to global so other pages can call these functions
window.renderCompetitionTemplatesPage = renderCompetitionTemplatesPage;
window.renderArchivedTemplatesPage = renderArchivedTemplatesPage;
window.renderCreateTemplateModal = renderCreateTemplateModal;
window.renderEditTemplateModal = renderEditTemplateModal;
window.setupTemplateFilters = setupTemplateFilters;


// == calendar.js ==
ï»¿const ITEM_HEIGHT = 140; // 130px height + 10px margin-bottom
const BUFFER_ITEMS = 5; // Render items above and below the viewport for smoother scrolling
let weeklyResetCountdownInterval = null;

/**
 * Applies or removes search term highlighting from an agent item element.
 * @param {HTMLElement} element The agent item element.
 * @param {string} searchTerm The search term to highlight.
 */
function applyHighlight(element, searchTerm) {
  const nameEl = element.querySelector(".agent-name");
  const idEl = element.querySelector(".calendar-agent-id");
  const originalName = element.dataset.name;
  const originalId = "#" + element.dataset.agentidStr;

  const regex = searchTerm
    ? new RegExp(searchTerm.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"), "gi")
    : null;

  nameEl.innerHTML = searchTerm
    ? originalName.replace(regex, "<mark>$&</mark>")
    : originalName;
  idEl.innerHTML = searchTerm
    ? originalId.replace(regex, "<mark>$&</mark>")
    : originalId;
}

function createAgentItemHtml(
  agent,
  dayIndex,
  isToday,
  tasksState,
  number,
  searchTerm = ""
) {
  // Read state directly from the centralized store's state
  const agentTasks = tasksState.tasks[agent._id] || {};
  const task = agentTasks[dayIndex] || {
    audited: false,
    competition_sent: false,
  };

  const isComplete = task.audited; // Visual completion now only requires audit
  const avatarHtml = agent.avatar_url
    ? `<img src="${agent.avatar_url}" alt="Avatar" class="calendar-agent-avatar" loading="lazy">`
    : `<div class="calendar-agent-avatar-placeholder"><i class="fas fa-user"></i></div>`;

  const isSuperAdmin = currentUserProfile?.role === "super_admin";
  const cursorStyle = isSuperAdmin ? "cursor: grab;" : "cursor: pointer;";

  const element = document.createElement("div");
  element.id = `agent-card-${agent._id}-${dayIndex}`;
  element.className = `calendar-agent-item ${isComplete ? "complete" : ""}`;
  element.dataset.agentId = agent._id;
  element.dataset.classification = agent.classification;
  element.dataset.name = agent.name;
  element.dataset.agentidStr = agent.agent_id;
  element.dataset.dayIndex = dayIndex;
  element.style.cssText = cursorStyle;
  if (isSuperAdmin) element.setAttribute("draggable", "true");

  element.innerHTML = `
        <div class="calendar-agent-number">${number}</div>
        <div class="calendar-agent-main">
            ${avatarHtml}
            <div class="calendar-agent-info">
                <span class="agent-name"></span>
                <div class="agent-meta">
                    <p class="calendar-agent-id" title="Ù†Ø³Ø® Ø§Ù„Ø±Ù‚Ù…" data-agent-id-copy="${
                      agent.agent_id
                    }"></p>
                    <span class="classification-badge classification-${agent.classification.toLowerCase()}">${
    agent.classification
  }</span>
                </div>
            </div>
        </div>
        <div class="calendar-agent-actions">
            <div class="action-item ${task.audited ? "done" : ""}">
                <label>Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚</label>
                <label class="custom-checkbox toggle-switch">
                    <input type="checkbox" class="audit-check" data-agent-id="${
                      agent._id
                    }" data-day-index="${dayIndex}" ${
    task.audited ? "checked" : ""
  }>
                    <span class="slider round"></span>
                </label>
            </div>
            <div class="action-item ${task.competition_sent ? "done" : ""}">
                <label>Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</label>
                <label class="custom-checkbox toggle-switch">
                    <input type="checkbox" class="competition-check" data-agent-id="${
                      agent._id
                    }" data-day-index="${dayIndex}" ${
    task.competition_sent ? "checked" : ""
  }>
                    <span class="slider round"></span>
                </label>
            </div>
        </div>
    `;

  applyHighlight(element, searchTerm);

  const nameEl = element.querySelector(".agent-name");
  // Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØµØ­ ÙÙ‚Ø· Ø¹Ù†Ø¯ ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚
  if (isComplete) {
    nameEl.insertAdjacentHTML(
      "beforeend",
      '<i class="fas fa-check-circle task-complete-icon" title="Ø§Ù„Ù…Ù‡Ù…Ø© Ù…ÙƒØªÙ…Ù„Ø©"></i>'
    );
    nameEl.classList.add("has-checkmark");
  }

  return element;
}

class CalendarUI {
  constructor(container) {
    this.container = container;
    this.container.innerHTML = `
        <div class="page-header column-header">
            <div class="header-top-row">
                <h1>ØªÙ‚ÙˆÙŠÙ… Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠ</h1>
                <div class="header-actions-group">
                    <button id="reset-all-tasks-btn" class="btn btn-danger">
                        <i class="fas fa-undo"></i> Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙƒÙ„
                    </button>
                    <div id="weekly-reset-countdown-container" class="countdown-timer-container" style="display: none;">
                        <i class="fas fa-sync-alt"></i>
                        <span>Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ† Ø®Ù„Ø§Ù„: <span id="weekly-reset-countdown" class="countdown-time"></span></span>
                    </div>
                    <span class="info-tooltip" title="Ø­Ø§Ù„Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø³ÙŠØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†Ù‡Ø§ (Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ ÙˆØ§Ù„Ø¥Ø±Ø³Ø§Ù„) ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ÙƒÙ„ ÙŠÙˆÙ… Ø£Ø­Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø© 7 ØµØ¨Ø§Ø­Ø§Ù‹">
                        <i class="fas fa-info-circle"></i>
                    </span>
                </div>
            </div>
            <div class="calendar-filters">
                <div class="filter-search-container">
                    <input type="search" id="calendar-search-input" placeholder="Ø¨Ø­Ø« Ø¨Ø§Ù„Ø§Ø³Ù… Ø£Ùˆ Ø§Ù„Ø±Ù‚Ù…..." autocomplete="off">
                    <i class="fas fa-search"></i>
                    <i class="fas fa-times-circle search-clear-btn" id="calendar-search-clear"></i>
                </div>
                <div class="filter-buttons">
                    <button class="filter-btn active" data-filter="all">Ø§Ù„ÙƒÙ„</button>
                    <button class="filter-btn" data-filter="R">R</button>
                    <button class="filter-btn" data-filter="A">A</button>
                    <button class="filter-btn" data-filter="B">B</button>
                    <button class="filter-btn" data-filter="C">C</button>
                </div>
            </div>
        </div>
        <div id="calendar-container" class="calendar-container"></div>
        `;
    this.calendarContainer = this.container.querySelector(
      "#calendar-container"
    );
    this.calendarData = [];
    this.tasksState = null;
    this.daysOfWeek = [
      "Ø§Ù„Ø£Ø­Ø¯",
      "Ø§Ù„Ø§Ø«Ù†ÙŠÙ†",
      "Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡",
      "Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡",
      "Ø§Ù„Ø®Ù…ÙŠØ³",
      "Ø§Ù„Ø¬Ù…Ø¹Ø©"
    ];
    this.searchDebounceTimer = null;
    this._syncInterval = null;

    this.boundHandleChange = this._handleChange.bind(this);
    this.boundHandleResetAll = this.handleResetAllTasks.bind(this);
    this.boundUpdateUIFromState = this.updateCalendarUIFromState.bind(this);
  }

  destroy() {
    if (window.taskStore && this.boundUpdateUIFromState) {
        window.taskStore.unsubscribe(this.boundUpdateUIFromState);
    }
    clearTimeout(this.searchDebounceTimer);
    if (weeklyResetCountdownInterval) {
      clearInterval(weeklyResetCountdownInterval);
    }
    if (this._syncInterval) {
      clearInterval(this._syncInterval);
      this._syncInterval = null;
    }
    this.calendarContainer.removeEventListener(
      "change",
      this.boundHandleChange
    );
    const resetBtn = this.container.querySelector("#reset-all-tasks-btn");
    if (resetBtn) {
      resetBtn.removeEventListener("click", this.boundHandleResetAll);
    }
    console.log("[Calendar Page] Instance destroyed and listeners cleaned up.");
  }

  async render() {
    const response = await authedFetch("/api/calendar/data");
    if (!response.ok) {
      throw new Error(
        (await response.json()).message || "ÙØ´Ù„ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªÙ‚ÙˆÙŠÙ…"
      );
    }
    const { agents } = await response.json();

    this.tasksState = window.taskStore.state;

    // Ensure we have the most recent authoritative task state from the server
    // (in case taskStore.init/localStorage raced with page rendering)
    try {
      if (
        window.taskStore &&
        typeof window.taskStore.syncWithServer === "function"
      ) {
        await window.taskStore.syncWithServer();
        this.tasksState = window.taskStore.state;
      }
    } catch (e) {
      console.warn("[Calendar] Failed to sync store during render:", e);
    }

    this.calendarData = this.daysOfWeek.map(() => []);
    
    // --- FIX: Build calendar data from ALL agents, showing them on ALL days where they have tasks ---
    agents.forEach((agent) => {
      // Check if agent has any tasks in the store
      const agentTasks = this.tasksState.tasks[agent._id] || {};
      const daysWithTasks = Object.keys(agentTasks).map(d => parseInt(d, 10));
      
      // FIX: Always use audit_days as the source of truth for which days to show agent
      // Tasks are just status indicators, not day assignment
      const dayIndices = agent.audit_days || [];
      dayIndices.forEach((dayIndex) => {
        if (dayIndex >= 0 && dayIndex <= 5) {
          // Ensure the array exists before checking
          if (!this.calendarData[dayIndex]) {
            this.calendarData[dayIndex] = [];
          }
          const alreadyAdded = this.calendarData[dayIndex].some(a => a._id === agent._id);
          if (!alreadyAdded) {
            this.calendarData[dayIndex].push(agent);
          }
        }
      });
    });

    this._renderDayColumns();
    this._renderAllAgentCards();
    this._setupEventListeners();
    setupCalendarFilters(this);

    // Ù…Ø²Ø§Ù…Ù†Ø© Ø¯ÙˆØ±ÙŠØ© Ù…Ø¹ Ø§Ù„Ø®Ø§Ø¯Ù… Ù„Ø¶Ù…Ø§Ù† Ø¸Ù‡ÙˆØ± ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ø¬Ù…ÙŠØ¹ Ù„Ù„Ø¬Ù…ÙŠØ¹
    if (this._syncInterval) clearInterval(this._syncInterval);
    this._syncInterval = setInterval(() => {
      try {
        if (window.taskStore && window.taskStore.state) {
          const prevState = JSON.stringify(this.tasksState?.tasks || {});
          const newState = JSON.stringify(window.taskStore.state.tasks || {});
          if (prevState !== newState) {
            this.tasksState = window.taskStore.state;
            this._renderDayColumns();
            this._renderAllAgentCards();
          }
        }
      } catch (_) {
        /* ignore */
      }
    }, 20000); // ÙƒÙ„ 20 Ø«Ø§Ù†ÙŠØ©

    // The global subscription is enabled
    if (window.taskStore) {
        window.taskStore.subscribe(this.boundUpdateUIFromState);
    }
  }

  updateCalendarUIFromState(newState) {
      console.log('[Calendar] Received store update');
      this.tasksState = newState;
      // Re-render columns to reflect changes
      // We could optimize this to only update changed cells, but re-rendering columns is fast enough
      this._renderDayColumns();
      this._renderAllAgentCards();
      
      // Re-apply filters if any
      const searchInput = document.getElementById("calendar-search-input");
      if (searchInput && searchInput.value) {
          searchInput.dispatchEvent(new Event('input'));
      }
  }

  _renderDayColumns() {
    this.calendarContainer.innerHTML = "";
    this.daysOfWeek.forEach((dayName, index) => {
      const isToday = new Date().getDay() === index;
      const { completedTasks, totalTasks, progressPercent } =
        this._calculateDayProgress(index);

      const columnEl = document.createElement("div");
      columnEl.className = `day-column ${isToday ? "today" : ""}`;
      columnEl.dataset.dayIndex = index;
      columnEl.innerHTML = `
                <h2>${dayName}</h2>
                <div class="day-progress">
                    <div class="progress-bar" style="width: ${progressPercent}%"></div>
                    <span class="progress-label">${completedTasks} / ${totalTasks} Ù…ÙƒØªÙ…Ù„</span>
                </div>
                <div class="day-column-content"></div>
            `;
      this.calendarContainer.appendChild(columnEl);
    });
  }

  _calculateDayProgress(dayIndex) {
    const dailyAgents = this.calendarData[dayIndex] || [];
    const totalTasks = dailyAgents.length;
    let completedTasks = 0;
    dailyAgents.forEach((agent) => {
      const task = (this.tasksState.tasks[agent._id] || {})[dayIndex] || {};
      if (task.audited) {
        completedTasks++;
      }
    });
    const progressPercent =
      totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;
    return { completedTasks, totalTasks, progressPercent };
  }

  _renderAllAgentCards() {
    this.calendarData.forEach((agentsForDay, dayIndex) => {
      const columnEl = this.calendarContainer.querySelector(
        `.day-column[data-day-index="${dayIndex}"]`
      );
      if (!columnEl) return;

      const contentContainer = columnEl.querySelector(".day-column-content");
      contentContainer.innerHTML = "";

      if (agentsForDay.length > 0) {
        const fragment = document.createDocumentFragment();
        const isToday = new Date().getDay() === dayIndex;
        agentsForDay.forEach((agent, index) => {
          const agentElement = createAgentItemHtml(
            agent,
            dayIndex,
            isToday,
            this.tasksState,
            index + 1,
            ""
          );
          fragment.appendChild(agentElement);
        });
        contentContainer.appendChild(fragment);
      } else {
        contentContainer.innerHTML =
          '<div class="no-tasks-placeholder"><i class="fas fa-bed"></i><p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù‡Ø§Ù…</p></div>';
      }
    });
  }

  _setupEventListeners() {
    this.calendarContainer.addEventListener("change", this.boundHandleChange);
    this.container
      .querySelector("#reset-all-tasks-btn")
      .addEventListener("click", this.boundHandleResetAll);
    setupClickAndDragEventListeners(
      this.calendarContainer,
      this.calendarData,
      this
    );
  }

  async handleResetAllTasks() {
    showConfirmationModal(
      "Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù‡Ø§Ù… (Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ ÙˆØ§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©) Ù„Ù‡Ø°Ø§ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ØŸ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡.",
      async () => {
        showLoader();
        try {
          await window.taskStore.resetAllTasks();
          showToast("ØªÙ…Øª Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù‡Ø§Ù… Ø¨Ù†Ø¬Ø§Ø­.", "success");

          // FIX: Manually re-render the UI without a page reload
          this.tasksState = window.taskStore.state; // Get the fresh, reset state
          this._renderDayColumns(); // Re-render columns to reset progress bars
          this._renderAllAgentCards(); // Re-render agent cards with reset state
        } catch (error) {
          console.error("Failed to reset all tasks:", error);
          showToast(`ÙØ´Ù„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†: ${error.message}`, "error");
        } finally {
          hideLoader();
        }
      },
      {
        title: "ØªØ£ÙƒÙŠØ¯ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙƒÙ„",
        confirmText: "Ù†Ø¹Ù…ØŒ Ø£Ø¹Ø¯ Ø§Ù„ØªØ¹ÙŠÙŠÙ†",
        confirmClass: "btn-danger",
      }
    );
  }

  async _handleChange(e) {
    const checkbox = e.target;
    if (!checkbox.matches(".audit-check, .competition-check")) return;

    const agentId = checkbox.dataset.agentId;
    const dayIndex = parseInt(checkbox.dataset.dayIndex, 10);
    const taskType = checkbox.classList.contains("audit-check")
      ? "audited"
      : "competition_sent";
    const status = checkbox.checked;

    // ========== DEBUG CONSOLE LOGS ==========
    /* console.log("ğŸ”„ Toggle Changed!");
    console.log("ğŸ“ Agent ID:", agentId);
    console.log("ğŸ“… Day Index:", dayIndex);
    console.log("ğŸ·ï¸ Task Type:", taskType);
    console.log("âœ… New Status:", status ? "ON (checked)" : "OFF (unchecked)");
    console.log("ğŸ¯ Checkbox element:", checkbox);
    console.log("ğŸ” Checkbox classes:", checkbox.className);
    console.log("ğŸ“Š Checkbox checked property:", checkbox.checked);
    console.log("========================================"); */
    // ========================================

    const agentItem = checkbox.closest(".calendar-agent-item");
    agentItem.classList.add("is-loading");
    agentItem
      .querySelectorAll('input[type="checkbox"]')
      .forEach((cb) => (cb.disabled = true));

    try {
      // This updates the central store
      // console.log("ğŸ“¤ Sending update to server...");
      await window.taskStore.updateTaskStatus(
        agentId,
        dayIndex,
        taskType,
        status
      );
      // console.log("âœ… Server update successful!");

      // FIX: Now, manually and correctly update the UI for this single item.
      updateCalendarUIFromState.call(this, {
        agentId,
        dayIndex,
        taskType,
        status,
      });
      // console.log("ğŸ¨ UI updated successfully!");
    } catch (error) {
      console.error(
        `[Calendar Error] Failed to update task. AgentID: ${agentId}, Day: ${dayIndex}, Type: ${taskType}. Reason:`,
        error
      );
      console.error("âŒ Error details:", error);
      showToast("ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ù‡Ù…Ø©.", "error");

      // Revert UI on error
      checkbox.checked = !status;
      console.log("âª Reverted checkbox to:", !status);
      agentItem.classList.remove("is-loading");
      agentItem
        .querySelectorAll('input[type="checkbox"]')
        .forEach((cb) => (cb.disabled = false));
    }
  }

  _updateAfterDrag(sourceDayIndex, newDayIndex, agentId) {
    const agentToMove = this.calendarData[sourceDayIndex].find(
      (a) => a._id === agentId
    );
    if (!agentToMove) return;

    this.calendarData[sourceDayIndex] = this.calendarData[
      sourceDayIndex
    ].filter((a) => a._id !== agentId);
    this.calendarData[newDayIndex].push(agentToMove);
    this.calendarData[newDayIndex].sort((a, b) => a.name.localeCompare(b.name));

    // Re-render only the two affected columns for efficiency
    this._renderSingleDayColumn(sourceDayIndex);
    this._renderSingleDayColumn(newDayIndex);
  }

  _renderSingleDayColumn(dayIndex) {
    const columnEl = this.calendarContainer.querySelector(
      `.day-column[data-day-index="${dayIndex}"]`
    );
    if (!columnEl) return;

    const contentContainer = columnEl.querySelector(".day-column-content");
    contentContainer.innerHTML = "";

    const agentsForDay = this.calendarData[dayIndex] || [];
    if (agentsForDay.length > 0) {
      const fragment = document.createDocumentFragment();
      const isToday = new Date().getDay() === dayIndex;
      agentsForDay.forEach((agent, index) => {
        const agentElement = createAgentItemHtml(
          agent,
          dayIndex,
          isToday,
          this.tasksState,
          index + 1,
          ""
        );
        fragment.appendChild(agentElement);
      });
      contentContainer.appendChild(fragment);
    } else {
      contentContainer.innerHTML =
        '<div class="no-tasks-placeholder"><i class="fas fa-bed"></i><p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù‡Ø§Ù…</p></div>';
    }
    updateDayProgressUI.call(this, dayIndex);
  }
}

let currentCalendarInstance = null;

async function renderCalendarPage() {
  if (currentCalendarInstance) {
    currentCalendarInstance.destroy();
  }
  const appContent = document.getElementById("app-content");
  currentCalendarInstance = new CalendarUI(appContent);
  try {
    await currentCalendarInstance.render();
    startWeeklyResetCountdown();
  } catch (error) {
    console.error("Error rendering calendar page:", error);
    const calendarContainer = document.getElementById("calendar-container");
    if (calendarContainer)
      calendarContainer.innerHTML = `<p class="error">Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªÙ‚ÙˆÙŠÙ…: ${error.message}</p>`;
  }
}

function getNextResetTime() {
  const now = new Date();
  const nextReset = new Date();
  const day = now.getDay();
  const daysUntilSunday = (7 - day) % 7;
  nextReset.setDate(now.getDate() + daysUntilSunday);
  nextReset.setHours(7, 0, 0, 0);
  if (day === 0 && now.getTime() > nextReset.getTime()) {
    nextReset.setDate(nextReset.getDate() + 7);
  }
  return nextReset;
}

function startWeeklyResetCountdown() {
  const countdownContainer = document.getElementById(
    "weekly-reset-countdown-container"
  );
  const countdownElement = document.getElementById("weekly-reset-countdown");
  if (!countdownContainer || !countdownElement) return;

  const updateTimer = () => {
    const now = new Date();
    const nextReset = getNextResetTime();
    const diff = nextReset - now;

    if (diff > 0 && diff < 5 * 60 * 60 * 1000) {
      countdownContainer.style.display = "flex";
      const h = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const m = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      const s = Math.floor((diff % (1000 * 60)) / 1000);
      countdownElement.textContent = `${h}Ø³ ${m}Ø¯ ${s}Ø«`;
    } else {
      countdownContainer.style.display = "none";
    }

    if (diff < 0) {
      const lastReset = localStorage.getItem("lastWeeklyReset");
      if (!lastReset || new Date(lastReset) < nextReset) {
        localStorage.setItem("lastWeeklyReset", new Date().toISOString());
        location.reload();
      }
    }
  };

  updateTimer();
  weeklyResetCountdownInterval = setInterval(updateTimer, 1000);
}

function updateCalendarUIFromState({ agentId, dayIndex, taskType, status }) {
  const container = this.calendarContainer;
  if (!container) return;

  const agentItem = container.querySelector(
    `#agent-card-${agentId}-${dayIndex}`
  );
  if (!agentItem) return;

  const taskState = (this.tasksState.tasks[agentId] || {})[dayIndex] || {
    audited: false,
    competition_sent: false,
  };

  const checkbox = agentItem.querySelector(
    `.${taskType === "audited" ? "audit-check" : "competition-check"}`
  );
  if (checkbox) checkbox.checked = status;

  checkbox?.closest(".action-item").classList.toggle("done", status);

  if (taskType === "audited") {
    const isComplete = taskState.audited;
    agentItem.classList.toggle("complete", isComplete);
    const nameEl = agentItem.querySelector(".agent-name");
    if (nameEl) nameEl.classList.toggle("has-checkmark", isComplete);
  }

  agentItem.classList.remove("is-loading");
  agentItem
    .querySelectorAll('input[type="checkbox"]')
    .forEach((cb) => (cb.disabled = false));

  updateDayProgressUI.call(this, dayIndex);
}

function updateDayProgressUI(dayIndex) {
  const column = document.querySelector(
    `.day-column[data-day-index="${dayIndex}"]`
  );
  if (!column) return;

  const progressBar = column.querySelector(".progress-bar");
  const progressLabel = column.querySelector(".progress-label");

  const allAgentsForDay = this.calendarData?.[dayIndex] || [];
  const totalTasks = allAgentsForDay.length;
  let completedTasks = 0;

  allAgentsForDay.forEach((agent) => {
    const task = (this.tasksState.tasks[agent._id] || {})[dayIndex] || {};
    if (task.audited) {
      completedTasks++;
    }
  });

  const progressPercent =
    totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;
  progressBar.style.width = `${progressPercent}%`;
  progressLabel.textContent = `${completedTasks} / ${totalTasks} Ù…ÙƒØªÙ…Ù„`;
}

function setupClickAndDragEventListeners(container, calendarData, uiInstance) {
  container.addEventListener("click", (e) => {
    const copyIdTrigger = e.target.closest(
      ".calendar-agent-id[data-agent-id-copy]"
    );
    if (copyIdTrigger) {
      e.stopPropagation();
      navigator.clipboard
        .writeText(copyIdTrigger.dataset.agentIdCopy)
        .then(() =>
          showToast(
            `ØªÙ… Ù†Ø³Ø® Ø§Ù„Ø±Ù‚Ù…: ${copyIdTrigger.dataset.agentIdCopy}`,
            "info"
          )
        );
      return;
    }
    const card = e.target.closest(".calendar-agent-item[data-agent-id]");
    if (card && !e.target.closest(".calendar-agent-actions")) {
      window.location.hash = `#profile/${card.dataset.agentId}`;
    }

    const actionItem = e.target.closest(".action-item");
    if (actionItem && !e.target.matches('input[type="checkbox"]')) {
      const checkbox = actionItem.querySelector('input[type="checkbox"]');
      if (checkbox) {
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event("change", { bubbles: true }));
      }
    }
  });

  const isSuperAdmin = currentUserProfile?.role === "super_admin";
  if (isSuperAdmin) {
    let draggedItem = null;
    let sourceDayIndex = null;

    container.addEventListener("dragstart", (e) => {
      const target = e.target.closest(".calendar-agent-item");
      if (target) {
        draggedItem = target;
        sourceDayIndex = parseInt(target.dataset.dayIndex, 10);
        setTimeout(() => target.classList.add("dragging"), 0);
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", target.dataset.agentId);
      }
    });

    container.addEventListener("dragend", () => {
      if (draggedItem) {
        draggedItem.classList.remove("dragging");
        draggedItem = null;
      }
    });

    container.addEventListener("dragover", (e) => {
      e.preventDefault();
      const column = e.target.closest(".day-column");
      if (column) column.classList.add("drag-over");
    });

    container.addEventListener("dragleave", (e) => {
      const column = e.target.closest(".day-column");
      if (column) column.classList.remove("drag-over");
    });

    container.addEventListener("drop", async (e) => {
      e.preventDefault();
      const targetColumn = e.target.closest(".day-column");
      if (!targetColumn || !draggedItem) return;

      targetColumn.classList.remove("drag-over");
      const newDayIndex = parseInt(targetColumn.dataset.dayIndex, 10);
      const agentId = draggedItem.dataset.agentId;
      const agentNameSafe = draggedItem?.dataset?.name || "Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„";

      if (sourceDayIndex === newDayIndex) return;

      try {
        const agentCheckResponse = await authedFetch(
          `/api/agents/${agentId}?select=audit_days`
        );
        const { data: agent } = await agentCheckResponse.json();
        if ((agent.audit_days || []).includes(newDayIndex)) {
          showToast(
            `Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„ Ù…Ø¬Ø¯ÙˆÙ„ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ ÙŠÙˆÙ… ${uiInstance.daysOfWeek[newDayIndex]}.`,
            "warning"
          );
          return;
        }

        showConfirmationModal(
          `Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ù†Ù‚Ù„ Ø§Ù„ÙˆÙƒÙŠÙ„ <strong>${agentNameSafe}</strong> Ù…Ù† ÙŠÙˆÙ… <strong>${uiInstance.daysOfWeek[sourceDayIndex]}</strong> Ø¥Ù„Ù‰ ÙŠÙˆÙ… <strong>${uiInstance.daysOfWeek[newDayIndex]}</strong>ØŸ`,
          async () => {
            const agentResponse = await authedFetch(
              `/api/agents/${agentId}?select=audit_days`
            );
            const { data: agent } = await agentResponse.json();
            const newAuditDays = [
              ...(agent.audit_days || []).filter((d) => d !== sourceDayIndex),
              newDayIndex,
            ];

            await authedFetch(`/api/agents/${agentId}`, {
              method: "PUT",
              body: JSON.stringify({ audit_days: newAuditDays }),
            });

            showToast("ØªÙ… ØªØ­Ø¯ÙŠØ« ÙŠÙˆÙ… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ Ø¨Ù†Ø¬Ø§Ø­.", "success");
            await logAgentActivity(
              currentUserProfile?._id,
              agentId,
              "DETAILS_UPDATE",
              `ØªÙ… ØªØºÙŠÙŠØ± ÙŠÙˆÙ… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ Ù…Ù† ${uiInstance.daysOfWeek[sourceDayIndex]} Ø¥Ù„Ù‰ ${uiInstance.daysOfWeek[newDayIndex]} Ø¹Ø¨Ø± Ø§Ù„ØªÙ‚ÙˆÙŠÙ….`
            );

            uiInstance._updateAfterDrag(sourceDayIndex, newDayIndex, agentId);
          }
        );
      } catch (error) {
        showToast(`ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« ÙŠÙˆÙ… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚: ${error.message}`, "error");
      }
    });
  }
}

function setupCalendarFilters(uiInstance) {
  const searchInput = document.getElementById("calendar-search-input");
  const clearBtn = document.getElementById("calendar-search-clear");
  const filterButtons = document.querySelectorAll(".filter-btn");

  const applyFilters = () => {
    if (clearBtn) {
      clearBtn.style.display = searchInput.value ? "block" : "none";
    }

    const searchTerm = searchInput.value.toLowerCase().trim();
    const activeFilter =
      document.querySelector(".filter-btn.active").dataset.filter;

    uiInstance.calendarData.forEach((allAgentsForDay, dayIndex) => {
      const columnEl = uiInstance.calendarContainer.querySelector(
        `.day-column[data-day-index="${dayIndex}"]`
      );
      if (!columnEl) return;

      const filteredAgents = allAgentsForDay.filter((agent) => {
        const name = agent.name.toLowerCase();
        const agentIdStr = agent.agent_id;
        const classification = agent.classification;
        const matchesSearch =
          searchTerm === "" ||
          name.includes(searchTerm) ||
          agentIdStr.includes(searchTerm);
        const matchesFilter =
          activeFilter === "all" || classification === activeFilter;
        return matchesSearch && matchesFilter;
      });

      const contentContainer = columnEl.querySelector(".day-column-content");
      contentContainer.innerHTML = "";

      if (filteredAgents.length === 0) {
        contentContainer.innerHTML =
          '<div class="no-results-placeholder"><i class="fas fa-search"></i><p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬</p></div>';
      } else {
        const fragment = document.createDocumentFragment();
        const isToday = new Date().getDay() === dayIndex;
        filteredAgents.forEach((agent, index) => {
          const agentElement = createAgentItemHtml(
            agent,
            dayIndex,
            isToday,
            uiInstance.tasksState,
            index + 1,
            searchTerm
          );
          fragment.appendChild(agentElement);
        });
        contentContainer.appendChild(fragment);
      }
    });
  };

  searchInput.addEventListener("input", () => {
    clearTimeout(uiInstance.searchDebounceTimer);
    uiInstance.searchDebounceTimer = setTimeout(applyFilters, 300);
  });

  if (clearBtn) {
    clearBtn.addEventListener("click", () => {
      searchInput.value = "";
      applyFilters();
      searchInput.focus();
    });
  }

  filterButtons.forEach((button) => {
    button.addEventListener("click", () => {
      filterButtons.forEach((btn) => btn.classList.remove("active"));
      button.classList.add("active");
      applyFilters();
    });
  });
}


// == topAgents.js ==
ï»¿// topAgents.js - Updated: 2025-11-16 with Clear Filter Button
let agentStats = [];
let selectedAgentsForComparison = [];
let isTopAgentsComparisonMode = false;

// --- NEW: Confetti Animation on Page Load ---
function triggerConfettiAnimation() {
    const container = document.getElementById('app-content');
    if (!container) return;

    const confettiContainer = document.createElement('div');
    confettiContainer.className = 'confetti-container';
    container.appendChild(confettiContainer);

    const confettiCount = 150; // Number of confetti pieces
    const colors = ['#FFD700', '#C0C0C0', '#CD7F32']; // Gold, Silver, Bronze

    for (let i = 0; i < confettiCount; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = `${Math.random() * 100}vw`;
        confetti.style.animationDuration = `${Math.random() * 3 + 4}s`; // Duration between 4 and 7 seconds
        confetti.style.animationDelay = `${Math.random() * 2}s`;
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confettiContainer.appendChild(confetti);
    }

    // Remove the confetti after the animation is done to keep the DOM clean
    setTimeout(() => confettiContainer.remove(), 7000);
}

// --- NEW: Animate Value Function ---
function animateValue(obj, start, end, duration) {
    if (!obj) return;
    let startTimestamp = null;
    const step = (timestamp) => {
        if (!startTimestamp) startTimestamp = timestamp;
        const progress = Math.min((timestamp - startTimestamp) / duration, 1);
        const value = Math.floor(progress * (end - start) + start);
        obj.innerHTML = formatNumber(value);
        if (progress < 1) {
            window.requestAnimationFrame(step);
        } else {
            obj.innerHTML = formatNumber(end); // Ensure final value is exact
        }
    };
    window.requestAnimationFrame(step);
}

async function renderTopAgentsPage() {
    const appContent = document.getElementById('app-content');
    appContent.innerHTML = `
        <div class="page-header column-header">
            <div class="header-top-row">
                <h1 class="leaderboard-title"><i class="fas fa-chart-bar"></i> Ø£Ø¨Ø±Ø² Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡</h1>
                <div class="header-actions-group">
                    <button id="compare-agents-btn" class="btn-secondary"><i class="fas fa-balance-scale"></i> Ù…Ù‚Ø§Ø±Ù†Ø©</button>
                    <button id="export-top-agents-btn" class="btn-secondary"><i class="fas fa-file-excel"></i> ØªØµØ¯ÙŠØ±</button>
                </div>
            </div>
            <div class="leaderboard-filters-v2">
                <div class="filter-group">
                    <label class="filter-label"><i class="fas fa-sort-amount-down"></i> ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨</label>
                    <div class="filter-buttons" data-filter-group="sort">
                        <button class="filter-btn active" data-sort="total_views"><i class="fas fa-eye"></i> Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª</button>
                        <button class="filter-btn" data-sort="total_reactions"><i class="fas fa-heart"></i> Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª</button>
                        <button class="filter-btn" data-sort="total_participants"><i class="fas fa-users"></i> Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª</button>
                        <button class="filter-btn" data-sort="growth_rate"><i class="fas fa-rocket"></i> Ø§Ù„Ù†Ù…Ùˆ</button>
                    </div>
                </div>
                <div class="filter-group">
                    <label class="filter-label"><i class="fas fa-tags"></i> ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„ØªØµÙ†ÙŠÙ</label>
                    <div class="filter-buttons" data-filter-group="classification">
                        <button class="filter-btn active" data-filter="all"><i class="fas fa-globe-asia"></i> Ø§Ù„ÙƒÙ„</button>
                        <button class="filter-btn classification-badge classification-r" data-filter="R">R</button>
                        <button class="filter-btn classification-badge classification-a" data-filter="A">A</button>
                        <button class="filter-btn classification-badge classification-b" data-filter="B">B</button>
                        <button class="filter-btn classification-badge classification-c" data-filter="C">C</button>
                    </div>
                </div>
                <div class="filter-group">
                    <label class="filter-label"><i class="fas fa-clock"></i> Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ø²Ù…Ù†ÙŠ</label>
                    <div class="filter-buttons" data-filter-group="date">
                        <button class="filter-btn active" data-range="all"><i class="fas fa-infinity"></i> Ø§Ù„ÙƒÙ„</button>
                        <button class="filter-btn" data-range="week"><i class="fas fa-calendar-week"></i> Ù‡Ø°Ø§ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹</button>
                        <button class="filter-btn" data-range="month"><i class="fas fa-calendar-day"></i> Ù‡Ø°Ø§ Ø§Ù„Ø´Ù‡Ø±</button>
                    </div>
                </div>
                <div class="filter-group custom-date-filter">
                    <label class="filter-label"><i class="fas fa-calendar-alt"></i> Ù†Ø·Ø§Ù‚ Ù…Ø®ØµØµ</label>
                    <div class="date-inputs-row">
                        <div class="date-input-wrapper">
                            <label class="date-label">Ù…Ù†</label>
                            <input type="date" id="topAgentsCustomFrom" class="date-input" />
                        </div>
                        <div class="date-input-wrapper">
                            <label class="date-label">Ø¥Ù„Ù‰</label>
                            <input type="date" id="topAgentsCustomTo" class="date-input" />
                        </div>
                        <button id="applyCustomDateFilter" class="btn-primary" style="height: 40px; align-self: flex-end;">
                            <i class="fas fa-filter"></i> ØªØ·Ø¨ÙŠÙ‚
                        </button>
                        <button id="clearCustomDateFilter" class="btn-secondary" style="height: 40px; align-self: flex-end;">
                            <i class="fas fa-times"></i> Ù…Ø³Ø­
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <div id="leaderboard-content-container">
        </div>
        
        <!-- Comparison Floating Bar -->
        <div id="comparison-floating-bar" class="comparison-floating-bar">
            <div class="selected-agents-preview" id="selected-agents-preview"></div>
            <span id="comparison-count-text">ØªÙ… Ø§Ø®ØªÙŠØ§Ø± 0 Ù…Ù† 3</span>
            <button id="show-comparison-modal-btn" class="btn-primary">Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©</button>
            <button id="cancel-comparison-btn" class="btn-secondary"><i class="fas fa-times"></i></button>
        </div>
    `;

    // --- NEW: Trigger the celebration animation ---
    triggerConfettiAnimation();

    // Initial fetch for all time
    await fetchAndRenderTopAgents('all');

    // --- NEW: Custom date filter ---
    const applyCustomDateBtn = document.getElementById('applyCustomDateFilter');
    const clearCustomDateBtn = document.getElementById('clearCustomDateFilter');
    const customFromInput = document.getElementById('topAgentsCustomFrom');
    const customToInput = document.getElementById('topAgentsCustomTo');
    
    if (applyCustomDateBtn) {
        applyCustomDateBtn.addEventListener('click', () => {
            const from = customFromInput.value;
            const to = customToInput.value;
            
            if (!from || !to) {
                showToast('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙˆØ§Ù„Ù†Ù‡Ø§ÙŠØ©', 'warning');
                return;
            }
            
            if (new Date(from) > new Date(to)) {
                showToast('ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‚Ø¨Ù„ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù†Ù‡Ø§ÙŠØ©', 'error');
                return;
            }
            
            // Deactivate preset date buttons
            const dateFilterGroup = document.querySelector('.filter-buttons[data-filter-group="date"]');
            dateFilterGroup?.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            
            fetchAndRenderTopAgents('custom', from, to);
            showToast('ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„ØªØ± Ø§Ù„Ù…Ø®ØµØµ', 'success');
        });
    }

    if (clearCustomDateBtn) {
        clearCustomDateBtn.addEventListener('click', () => {
            // Reset date inputs only
            customFromInput.value = '';
            customToInput.value = '';
            
            // Reactivate "all" date filter button and fetch all agents
            const dateFilterGroup = document.querySelector('.filter-buttons[data-filter-group="date"]');
            if (dateFilterGroup) {
                dateFilterGroup.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                const allBtn = dateFilterGroup.querySelector('[data-range="all"]');
                if (allBtn) allBtn.classList.add('active');
            }
            
            // Fetch and display all agents (without date filter)
            fetchAndRenderTopAgents('all');
            
            showToast('ØªÙ… Ù…Ø³Ø­ ÙÙ„ØªØ± Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø®ØµØµ', 'info');
        });
    }

    // --- NEW: Add listener for export button ---
    const exportBtn = document.getElementById('export-top-agents-btn');
    if (exportBtn) {
        exportBtn.addEventListener('click', () => exportTopAgentsToCSV(agentStats));
    }

    // --- ØªØ¹Ø¯ÙŠÙ„: Ø±Ø¨Ø· Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø· Ù„Ø¶Ù…Ø§Ù† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„ÙÙˆØ±ÙŠØ© ---
    const dateFilterGroup = document.querySelector('.filter-buttons[data-filter-group="date"]');
    const sortFilterGroup = document.querySelector('.filter-buttons[data-filter-group="sort"]');
    const classificationFilterGroup = document.querySelector('.filter-buttons[data-filter-group="classification"]');

    dateFilterGroup?.addEventListener('click', (e) => {
        const btn = e.target.closest('.filter-btn');
        if (!btn || !dateFilterGroup.contains(btn)) return;
        const prev = dateFilterGroup.querySelector('.active'); if (prev) prev.classList.remove('active');
        btn.classList.add('active');
        fetchAndRenderTopAgents(btn.dataset.range);
    });
    sortFilterGroup?.addEventListener('click', (e) => {
        const btn = e.target.closest('.filter-btn');
        if (!btn || !sortFilterGroup.contains(btn)) return;
        const prev = sortFilterGroup.querySelector('.active'); if (prev) prev.classList.remove('active');
        btn.classList.add('active');
        applyAndDisplay(); // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ÙØ±Ø² ÙˆØ§Ù„ØªØµÙÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©
    });
    classificationFilterGroup?.addEventListener('click', (e) => {
        const btn = e.target.closest('.filter-btn');
        if (!btn || !classificationFilterGroup.contains(btn)) return;
        const prev = classificationFilterGroup.querySelector('.active'); if (prev) prev.classList.remove('active');
        btn.classList.add('active');
        applyAndDisplay(); // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ÙØ±Ø² ÙˆØ§Ù„ØªØµÙÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©
    });
    // (metric selector removed per user request â€” always show all metrics inline)
}

async function fetchAndRenderTopAgents(dateRange = 'all', customFrom = null, customTo = null) {
    const container = document.getElementById('leaderboard-content-container');
    container.innerHTML = '<div class="loader-container"><div class="spinner"></div></div>';

    try {
        // console.log('='.repeat(80));
    /* logs suppressed: fetching top agents */
        
        const queryParams = new URLSearchParams();
        
        if (dateRange === 'custom' && customFrom && customTo) {
            queryParams.set('from', customFrom);
            queryParams.set('to', customTo);
        } else {
            queryParams.set('dateRange', dateRange);
        }
        
        const response = await authedFetch(`/api/stats/top-agents?${queryParams.toString()}`);

    /* logs suppressed: response status and ok */

        if (!response.ok) {
            const errorResult = await response.json();
            /* logs suppressed: error response */
            throw new Error(errorResult.message || 'ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡.');
        }

        const result = await response.json();
    /* logs suppressed: API result details */
        
    const topAgentsData = result.data || result; // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† property "data" Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
        
    /* logs suppressed: extracted topAgents data */
        // console.log('='.repeat(80));

        // The rest of the logic remains the same, but we need to adjust for _id
        processAndDisplayTopAgents(topAgentsData);
    } catch (error) {
    /* logs suppressed: catch block error */
        container.innerHTML = `<p class="error">${error.message}</p>`;
    }
}

function processAndDisplayTopAgents(agents, competitions) {
    // console.log('='.repeat(80));
    /* logs suppressed: processAndDisplayTopAgents diagnostics */
    
    // Validate that agents is an array
    if (!Array.isArray(agents)) {
    /* logs suppressed: agents is not an array */
        const container = document.getElementById('leaderboard-content-container');
        container.innerHTML = '<div class="error-message"><i class="fas fa-exclamation-triangle"></i><p>Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªÙ„Ù…Ø© Ù„ÙŠØ³Øª Ø¨Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„ØµØ­ÙŠØ­</p></div>';
        return;
    }
    
    if (agents.length === 0) {
    /* logs suppressed: agents array is empty */
        const container = document.getElementById('leaderboard-content-container');
        container.innerHTML = '<div class="no-results-message"><i class="fas fa-ghost"></i><p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª ÙˆÙƒÙ„Ø§Ø¡ Ù…ØªØ§Ø­Ø©.</p></div>';
        return;
    }
    
    // Group competitions by agent
    // --- FIX: The backend now sends a single array with stats already calculated ---
    agentStats = agents.map(agent => {
        const total_views = agent.total_views || 0;
        const total_reactions = agent.total_reactions || 0;
        const total_participants = agent.total_participants || 0;

        let growth_rate = 0;
        let trend = 'stable'; // 'up', 'down', 'stable'
        
        // --- NEW: Growth Rate Calculation ---
        // Growth is calculated as the change between the current period's total interactions
        // and the previous period's total interactions.
        const current_total = (agent.total_views || 0) + (agent.total_reactions || 0) + (agent.total_participants || 0);
        const previous_total = (agent.previous_total_views || 0) + (agent.previous_total_reactions || 0) + (agent.previous_total_participants || 0);

        if (previous_total > 0) {
            growth_rate = ((current_total - previous_total) / previous_total) * 100;
        } else if (current_total > 0) {
            growth_rate = 100; // Growth from 0 to a positive number is 100%
        }

        if (growth_rate > 5) trend = 'up';
        else if (growth_rate < -5) trend = 'down';

        return {
            ...agent,
            total_views, total_reactions, total_participants,
            growth_rate,
            trend
        };
    });

    /* logs suppressed: agentStats mapping */
    // console.log('='.repeat(80));

    // Store globally for filtering
    window.currentAgentStats = agentStats;

    // Initial render
    applyAndDisplay();
}
function applyAndDisplay() {
    // console.log('='.repeat(80));
    /* logs suppressed: applyAndDisplay called */
    
    const sortKey = document.querySelector('.filter-buttons[data-filter-group="sort"] .active')?.dataset.sort || 'total_views';
    const classification = document.querySelector('.filter-buttons[data-filter-group="classification"] .active')?.dataset.filter || 'all';
    let sortedAgents = [...(window.currentAgentStats || [])];

    /* logs suppressed: applyAndDisplay inputs */

    // 1. Filter by classification
    if (classification !== 'all') {
        sortedAgents = sortedAgents.filter(agent => agent.classification === classification);
    /* logs suppressed: after classification filter */
    }

    // 2. Sort the filtered list
    const classificationOrder = { 'R': 1, 'A': 2, 'B': 3, 'C': 4 };
    sortedAgents.sort((a, b) => {
        const sortValue = b[sortKey] - a[sortKey];
        if (sortValue !== 0) return sortValue;
        const orderA = classificationOrder[a.classification] || 99;
        const orderB = classificationOrder[b.classification] || 99;
        return orderA - orderB;
    });

    /* logs suppressed: after sort and calling display */
    // console.log('='.repeat(80));

    // 3. Display the final sorted and filtered list
    displayTopAgents(sortedAgents, sortKey);
}


function displayTopAgents(sortedAgents, sortKey) {
    // console.log('='.repeat(80));
    /* logs suppressed: displayTopAgents called */
    
    const container = document.getElementById('leaderboard-content-container');
    /* console.log('Container found:', !!container);
    const allContainers = document.querySelectorAll('#leaderboard-content-container');
    console.log('Number of containers with this ID:', allContainers.length);
    if (container) {
        console.log('Container current innerHTML length:', container.innerHTML.length);
    } */
    const dateRange = document.querySelector('.filter-buttons[data-filter-group="date"] .active')?.dataset.range || 'all';

    /* logs suppressed: container found and dateRange */

    if (!container) {
    /* logs suppressed: container not found */
        return;
    }
    // --- NEW: Skeleton Loading State ---
    container.innerHTML = `
        <div class="leaderboard-podium">
            <div class="skeleton-card" style="width: 30%; height: 300px;"></div>
            <div class="skeleton-card" style="width: 36%; height: 350px;"></div>
            <div class="skeleton-card" style="width: 30%; height: 300px;"></div>
        </div>
        <div class="leaderboard-list-section">
            <div class="skeleton-card" style="width: 100%; height: 100px; margin-bottom: 10px;"></div>
            <div class="skeleton-card" style="width: 100%; height: 100px; margin-bottom: 10px;"></div>
            <div class="skeleton-card" style="width: 100%; height: 100px; margin-bottom: 10px;"></div>
        </div>
    `;


    if (!sortedAgents || sortedAgents.length === 0) {
    /* logs suppressed: no agents to display */
        container.innerHTML = '<div class="no-results-message"><i class="fas fa-ghost"></i><p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ø¹Ø±Ø¶Ù‡Ø§ Ø­Ø³Ø¨ Ø§Ù„ÙÙ„Ø§ØªØ± Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©.</p></div>';
        return;
    }
    
    /* logs suppressed: continuing display logic */
    console.log('='.repeat(80));

    const getStatLabel = (key) => {
        switch (key) {
            case 'total_views': return 'Ù…Ø´Ø§Ù‡Ø¯Ø©';
            case 'total_reactions': return 'ØªÙØ§Ø¹Ù„';
            case 'total_participants': return 'Ù…Ø´Ø§Ø±ÙƒØ©';
            case 'growth_rate': return 'Ù†Ù…Ùˆ';
            default: return '';
        }
    };

    const getStatValue = (agent, key) => {
        if (key === 'growth_rate') {
            return `${agent[key].toFixed(1)}%`;
        }
        return formatNumber(agent[key]);
    };

    const getRankIcon = (rank) => {
        if (rank === 1) return '<span class="rank-icon gold">ğŸ¥‡</span>';
        if (rank === 2) return '<span class="rank-icon silver">ğŸ¥ˆ</span>';
        if (rank === 3) return '<span class="rank-icon bronze">ğŸ¥‰</span>';
        return `<span class="rank-number">${rank}</span>`;
    };

    // --- ØªØ¹Ø¯ÙŠÙ„: ÙØµÙ„ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ø«Ù„Ø§Ø«Ø© Ø§Ù„Ø£ÙˆØ§Ø¦Ù„ Ù„Ø¹Ø±Ø¶Ù‡Ù… ÙÙŠ Ù…Ù†ØµØ© Ø§Ù„ØªØªÙˆÙŠØ¬ ---
    const topThree = sortedAgents.slice(0, 3);
    const runnersUp = sortedAgents.slice(3);
    const exclusiveRanks = ['CENTER', 'BRONZE', 'SILVER', 'GOLD', 'PLATINUM', 'DIAMOND', 'SAPPHIRE', 'EMERALD', 'KING', 'LEGEND', 'ÙˆÙƒÙŠÙ„ Ø­ØµØ±ÙŠ Ø¨Ø¯ÙˆÙ† Ù…Ø±ØªØ¨Ø©'];
    const regularRanks = ['BEGINNING', 'GROWTH', 'PRO', 'ELITE'];
    
    const orderAgentsByRank = (agents, rankOrder) => {
        const orderMap = rankOrder.reduce((acc, rank, idx) => {
            acc[rank] = idx;
            return acc;
        }, {});
        return agents.slice().sort((a, b) => {
            const aOrder = orderMap.hasOwnProperty(a.rank) ? orderMap[a.rank] : Number.MAX_SAFE_INTEGER;
            const bOrder = orderMap.hasOwnProperty(b.rank) ? orderMap[b.rank] : Number.MAX_SAFE_INTEGER;
            if (aOrder !== bOrder) return aOrder - bOrder;
            const metricDiff = (b[sortKey] || 0) - (a[sortKey] || 0);
            if (metricDiff !== 0) return metricDiff;
            return (a.name || '').localeCompare(b.name || '', 'ar');
        });
    };

    const exclusiveRunnersUp = orderAgentsByRank(
        runnersUp.filter(agent => exclusiveRanks.includes(agent.rank)),
        exclusiveRanks
    );
    const regularRunnersUp = orderAgentsByRank(
        runnersUp.filter(agent => regularRanks.includes(agent.rank)),
        regularRanks
    );

    // Debug logging
    /* console.log('Top Agents Debug:');
    console.log('Total agents:', sortedAgents.length);
    console.log('Top 3:', topThree.map(a => ({name: a.name, rank: a.rank})));
    console.log('Runners up:', runnersUp.length);
    console.log('Exclusive runners up:', exclusiveRunnersUp.length, exclusiveRunnersUp.map(a => ({name: a.name, rank: a.rank})));
    console.log('Regular runners up:', regularRunnersUp.length, regularRunnersUp.map(a => ({name: a.name, rank: a.rank})));
    console.log('Unfiltered runners up:', runnersUp.filter(agent => !exclusiveRanks.includes(agent.rank) && !regularRanks.includes(agent.rank)).map(a => ({name: a.name, rank: a.rank}))); */

    // --- NEW: Podium data preparation for top 3 overall ---
    const podiumData = {
        first: topThree[0],
        second: topThree[1],
        third: topThree[2]
    };
    // Order for flexbox display: 2nd, 1st, 3rd
    const podiumOrder = [podiumData.second, podiumData.first, podiumData.third].filter(Boolean);

    const topAgentBadge = dateRange === 'week' ? 'ÙˆÙƒÙŠÙ„ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹' : (dateRange === 'month' ? 'ÙˆÙƒÙŠÙ„ Ø§Ù„Ø´Ù‡Ø±' : 'ÙˆÙƒÙŠÙ„ Ø§Ù„Ù…ÙˆØ³Ù…');

    /* logs suppressed: breakdown counts */

    const renderCard = (agent, rank, sortKey) => {
        try {
            const isTopThree = rank <= 3;
            const rankClass = rank === 1 ? 'gold' : (rank === 2 ? 'silver' : 'bronze');
            const trendIcon = agent.trend === 'up' ? '<i class="fas fa-arrow-up trend-up"></i>' : (agent.trend === 'down' ? '<i class="fas fa-arrow-down trend-down"></i>' : '');
            const avatarHtml = agent.avatar_url
                ? `<img src="${agent.avatar_url}" alt="Avatar" class="leaderboard-avatar" loading="lazy">`
                : `<div class="leaderboard-avatar-placeholder"><i class="fas fa-user"></i></div>`;

            // Determine if agent is exclusive
            const isExclusive = exclusiveRanks.includes(agent.rank);
            const exclusiveBadge = isExclusive 
                ? `<div class="exclusive-badge" title="ÙˆÙƒÙŠÙ„ Ø­ØµØ±ÙŠ"><i class="fas fa-crown"></i></div>` 
                : `<div class="regular-badge" title="ÙˆÙƒÙŠÙ„ Ø§Ø¹ØªÙŠØ§Ø¯ÙŠ"><i class="fas fa-star"></i></div>`;

            // --- NEW: Special Badges Logic ---
            const isHotStreak = agent.growth_rate > 15;
            const isNewcomer = agent.growth_rate === 100 && agent.total_views < 5000; // Heuristic for newcomer

            let specialBadgesHtml = '';
            if (isHotStreak) specialBadgesHtml += `<div class="special-badge badge-hot"><i class="fas fa-fire"></i> Hot Streak</div>`;
            if (isNewcomer) specialBadgesHtml += `<div class="special-badge badge-new"><i class="fas fa-star"></i> New</div>`;

            return `
                <div class="leaderboard-card ${isTopThree ? `top-rank ${rankClass}` : ''}" data-agent-id="${agent._id}" style="cursor: pointer;">
                    ${specialBadgesHtml}
                    <div class="leaderboard-rank">
                        ${isTopThree ? `<div class="medal-badge ${rankClass}">${getRankIcon(rank)}</div>` : getRankIcon(rank)}
                    </div>
                    ${rank === 1 ? '<div class="glow-bar"></div>' : ''}
                    <div class="leaderboard-agent-profile">
                        <div style="position: relative;">
                            ${avatarHtml}
                            ${exclusiveBadge}
                        </div>
                        <div class="leaderboard-agent-info">
                            <h3 class="leaderboard-agent-name">${agent.name} ${trendIcon}</h3>
                            <div class="leaderboard-agent-meta" data-agent-id-copy="${agent.agent_id || 'N/A'}" title="Ù†Ø³Ø® Ø§Ù„Ø±Ù‚Ù…">
                                <span class="leaderboard-agent-id">#${agent.agent_id || 'N/A'}</span>
                            </div>
                            <div class="leaderboard-agent-classification">
                                <span class="classification-badge classification-${(agent.classification || '').toLowerCase()}">${agent.classification || ''}</span>
                            </div>
                        </div>
                </div>
                <div class="leaderboard-stats-grid">
                    ${(() => {
                        const metricKeys = ['total_views','total_reactions','total_participants'];
                        const isMetricSort = metricKeys.includes(sortKey);
                        
                        // Special layout for Top 3
                        if (isTopThree) {
                             return `
                                <div class="stat-item top-stat-item">
                                    <span class="stat-label"><i class="fas fa-eye"></i> Ù…Ø´Ø§Ù‡Ø¯Ø§Øª</span>
                                    <span class="stat-value" data-animate-to="${agent.total_views}">0</span>
                                </div>
                                <div class="stat-item top-stat-item">
                                    <span class="stat-label"><i class="fas fa-heart"></i> ØªÙØ§Ø¹Ù„Ø§Øª</span>
                                    <span class="stat-value" data-animate-to="${agent.total_reactions}">0</span>
                                </div>
                                <div class="stat-item top-stat-item">
                                    <span class="stat-label"><i class="fas fa-users"></i> Ù…Ø´Ø§Ø±ÙƒØ§Øª</span>
                                    <span class="stat-value" data-animate-to="${agent.total_participants}">0</span>
                                </div>
                            `;
                        }

                        // If sorting by a metric and this agent is not top 3, show only that metric
                        if (isMetricSort && rank > 3) {
                            if (sortKey === 'total_views') {
                                return `<div class="stat-item"><span class="stat-value" data-animate-to="${agent.total_views}">0</span><span class="stat-label"><i class="fas fa-eye"></i> Ù…Ø´Ø§Ù‡Ø¯Ø§Øª</span></div>`;
                            }
                            if (sortKey === 'total_reactions') {
                                return `<div class="stat-item"><span class="stat-value" data-animate-to="${agent.total_reactions}">0</span><span class="stat-label"><i class="fas fa-heart"></i> ØªÙØ§Ø¹Ù„Ø§Øª</span></div>`;
                            }
                            if (sortKey === 'total_participants') {
                                return `<div class="stat-item"><span class="stat-value" data-animate-to="${agent.total_participants}">0</span><span class="stat-label"><i class="fas fa-users"></i> Ù…Ø´Ø§Ø±ÙƒØ§Øª</span></div>`;
                            }
                        }
                        // Otherwise show all three
                        return `
                            <div class="stat-item"><span class="stat-value" data-animate-to="${agent.total_views}">0</span><span class="stat-label"><i class="fas fa-eye"></i> Ù…Ø´Ø§Ù‡Ø¯Ø§Øª</span></div>
                            <div class="stat-item"><span class="stat-value" data-animate-to="${agent.total_reactions}">0</span><span class="stat-label"><i class="fas fa-heart"></i> ØªÙØ§Ø¹Ù„Ø§Øª</span></div>
                            <div class="stat-item"><span class="stat-value" data-animate-to="${agent.total_participants}">0</span><span class="stat-label"><i class="fas fa-users"></i> Ù…Ø´Ø§Ø±ÙƒØ§Øª</span></div>
                        `;
                    })()}
                </div>
                ${(rank === 1 && topAgentBadge) ? `<div class="top-agent-banner">${topAgentBadge}</div>` : ''}
            </div>
        `;
        } catch (error) {
            /* logs suppressed: error in renderCard */
            return '<div class="error-card">Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©</div>';
        }
    };

    const renderSimpleCard = (agent, rank, sortKey) => {
        try {
            const avatarHtml = agent.avatar_url
                ? `<img src="${agent.avatar_url}" alt="Avatar" class="leaderboard-avatar-simple" loading="lazy">`
                : `<div class="leaderboard-avatar-placeholder-simple"><i class="fas fa-user"></i></div>`;

            // Determine if agent is exclusive
            const isExclusive = exclusiveRanks.includes(agent.rank);
            const exclusiveIcon = isExclusive 
                ? `<i class="fas fa-crown" style="color: #f1c40f; margin-left: 5px;" title="ÙˆÙƒÙŠÙ„ Ø­ØµØ±ÙŠ"></i>` 
                : `<i class="fas fa-star" style="color: #95a5a6; margin-left: 5px;" title="ÙˆÙƒÙŠÙ„ Ø§Ø¹ØªÙŠØ§Ø¯ÙŠ"></i>`;

            return `
                <div class="leaderboard-card-simple" data-agent-id="${agent._id}" style="cursor: pointer;">
                    <span class="simple-rank">${rank}</span>
                    ${avatarHtml}
                    <div class="simple-agent-info">
                        <span class="simple-agent-name">${agent.name} ${exclusiveIcon}</span>
                        <span class="simple-agent-id" data-agent-id-copy="${agent.agent_id || 'N/A'}" title="Ù†Ø³Ø® Ø§Ù„Ø±Ù‚Ù…">#${agent.agent_id || 'N/A'}</span>
                        <span class="simple-agent-classification"><span class="classification-badge classification-${(agent.classification || '').toLowerCase()}">${agent.classification || ''}</span></span>
                    </div>
                    <div class="simple-agent-stats">
                        ${(() => {
                            const metricKeys = ['total_views','total_reactions','total_participants'];
                            const isMetricSort = metricKeys.includes(sortKey);
                            if (isMetricSort && rank > 3) {
                                if (sortKey === 'total_views') return `<span class="simple-stat"><i class="fas fa-eye"></i> ${formatNumber(agent.total_views)}</span>`;
                                if (sortKey === 'total_reactions') return `<span class="simple-stat"><i class="fas fa-heart"></i> ${formatNumber(agent.total_reactions)}</span>`;
                                if (sortKey === 'total_participants') return `<span class="simple-stat"><i class="fas fa-users"></i> ${formatNumber(agent.total_participants)}</span>`;
                            }
                            return `
                                <span class="simple-stat"><i class="fas fa-eye"></i> ${formatNumber(agent.total_views)}</span>
                                <span class="simple-stat"><i class="fas fa-heart"></i> ${formatNumber(agent.total_reactions)}</span>
                                <span class="simple-stat"><i class="fas fa-users"></i> ${formatNumber(agent.total_participants)}</span>
                            `;
                        })()}
                    </div>
                </div>
            `;
        } catch (error) {
            /* logs suppressed: error in renderSimpleCard */
            return '<div class="error-card-simple">Ø®Ø·Ø£</div>';
        }
    };

    try {
        container.innerHTML = `
            ${podiumOrder.length > 0 ? `
                <div class="leaderboard-podium">
                    ${podiumOrder.map((agent) => {
                        const actualRank = sortedAgents.findIndex(a => a._id === agent._id) + 1;
                        return renderCard(agent, actualRank, sortKey);
                    }).join('')}
                </div>
            ` : ''}
            
            ${runnersUp.length > 0 ? `
                <hr class="leaderboard-divider">
                <div class="leaderboard-bottom-sections">
                    <div class="leaderboard-list-section">
                        <h2 class="leaderboard-section-title"><i class="fas fa-crown"></i> Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ø­ØµØ±ÙŠÙŠÙ†</h2>
                        <div class="leaderboard-simple-list">
                            ${exclusiveRunnersUp.length > 0 ? exclusiveRunnersUp.map((agent, index) => {
                                const actualRank = sortedAgents.findIndex(a => a._id === agent._id) + 1;
                                return renderSimpleCard(agent, actualRank, sortKey);
                            }).join('') : '<p class="no-results-message">Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆÙƒÙ„Ø§Ø¡ Ø­ØµØ±ÙŠÙŠÙ† Ù„Ø¹Ø±Ø¶Ù‡Ù….</p>'}
                        </div>
                    </div>
                    <div class="leaderboard-list-section">
                        <h2 class="leaderboard-section-title"><i class="fas fa-users"></i> Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ø§Ø¹ØªÙŠØ§Ø¯ÙŠÙŠÙ†</h2>
                        <div class="leaderboard-simple-list">
                             ${regularRunnersUp.length > 0 ? regularRunnersUp.map((agent, index) => {
                                const actualRank = sortedAgents.findIndex(a => a._id === agent._id) + 1;
                                return renderSimpleCard(agent, actualRank, sortKey);
                            }).join('') : '<p class="no-results-message">Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆÙƒÙ„Ø§Ø¡ Ø§Ø¹ØªÙŠØ§Ø¯ÙŠÙŠÙ† Ù„Ø¹Ø±Ø¶Ù‡Ù….</p>'}
                        </div>
                    </div>
                </div>
            ` : ''}
        `;

    // --- NEW: Trigger Animations ---
    const animatedElements = container.querySelectorAll('[data-animate-to]');
    animatedElements.forEach(el => {
        const targetValue = parseInt(el.dataset.animateTo, 10);
        if (!isNaN(targetValue)) {
            animateValue(el, 0, targetValue, 1500);
        }
    });

    // --- NEW: Event Delegation for CSP Compliance ---
    container.addEventListener('click', (e) => {
        // Comparison Selection Logic
        if (isTopAgentsComparisonMode) {
            const card = e.target.closest('[data-agent-id]');
            if (card) {
                e.stopPropagation();
                e.preventDefault();
                toggleAgentSelection(card.dataset.agentId);
            }
            return;
        }

        const copyIdTrigger = e.target.closest('[data-agent-id-copy]');
        if (copyIdTrigger) {
            e.stopPropagation();
            const agentIdToCopy = copyIdTrigger.dataset.agentIdCopy;
            navigator.clipboard.writeText(agentIdToCopy).then(() => showToast(`ØªÙ… Ù†Ø³Ø® Ø§Ù„Ø±Ù‚Ù…: ${agentIdToCopy}`, 'info'));
            return;
        }

        const card = e.target.closest('[data-agent-id]');
        if (card) {
            window.location.hash = `#profile/${card.dataset.agentId}`;
        }
    });

    // --- NEW: Comparison Button Logic ---
    const compareBtn = document.getElementById('compare-agents-btn');
    if (compareBtn) {
        // Remove old listener if exists (simple way is to clone)
        const newBtn = compareBtn.cloneNode(true);
        compareBtn.parentNode.replaceChild(newBtn, compareBtn);
        
        newBtn.addEventListener('click', () => {
            isTopAgentsComparisonMode = !isTopAgentsComparisonMode;
            const container = document.getElementById('leaderboard-content-container');
            const floatingBar = document.getElementById('comparison-floating-bar');
            
            if (isTopAgentsComparisonMode) {
                container.classList.add('selection-mode');
                floatingBar.classList.add('active');
                newBtn.classList.add('active');
                showToast('Ø§Ø®ØªØ± Ù…Ø§ ÙŠØµÙ„ Ø¥Ù„Ù‰ 3 ÙˆÙƒÙ„Ø§Ø¡ Ù„Ù„Ù…Ù‚Ø§Ø±Ù†Ø©', 'info');
            } else {
                container.classList.remove('selection-mode');
                floatingBar.classList.remove('active');
                newBtn.classList.remove('active');
                selectedAgentsForComparison = [];
                updateComparisonUI();
                // Remove selected class from all cards
                document.querySelectorAll('.leaderboard-card.selected, .leaderboard-card-simple.selected').forEach(el => el.classList.remove('selected'));
            }
        });
    }

    // --- NEW: Comparison Floating Bar Logic ---
    document.getElementById('cancel-comparison-btn')?.addEventListener('click', () => {
        isTopAgentsComparisonMode = false;
        document.getElementById('leaderboard-content-container').classList.remove('selection-mode');
        document.getElementById('comparison-floating-bar').classList.remove('active');
        document.getElementById('compare-agents-btn').classList.remove('active');
        selectedAgentsForComparison = [];
        updateComparisonUI();
        document.querySelectorAll('.leaderboard-card.selected, .leaderboard-card-simple.selected').forEach(el => el.classList.remove('selected'));
    });

    document.getElementById('show-comparison-modal-btn')?.addEventListener('click', showComparisonModal);
    } catch (error) {
        console.error('Error rendering top agents:', error);
        container.innerHTML = '<div class="error-message"><i class="fas fa-exclamation-triangle"></i><p>Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</p></div>';
    }
}

// --- NEW: Comparison Logic Functions ---
function toggleAgentSelection(agentId) {
    const index = selectedAgentsForComparison.indexOf(agentId);
    const card = document.querySelector(`[data-agent-id="${agentId}"]`);
    
    if (index > -1) {
        // Deselect
        selectedAgentsForComparison.splice(index, 1);
        if (card) card.classList.remove('selected');
    } else {
        // Select
        if (selectedAgentsForComparison.length >= 3) {
            showToast('ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ù‚Ø§Ø±Ù†Ø© 3 ÙˆÙƒÙ„Ø§Ø¡ ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰', 'warning');
            return;
        }
        selectedAgentsForComparison.push(agentId);
        if (card) card.classList.add('selected');
    }
    updateComparisonUI();
}

function updateComparisonUI() {
    const previewContainer = document.getElementById('selected-agents-preview');
    const countText = document.getElementById('comparison-count-text');
    
    if (!previewContainer || !countText) return;

    previewContainer.innerHTML = '';
    countText.textContent = `ØªÙ… Ø§Ø®ØªÙŠØ§Ø± ${selectedAgentsForComparison.length} Ù…Ù† 3`;

    selectedAgentsForComparison.forEach(id => {
        const agent = window.currentAgentStats.find(a => a._id === id);
        if (agent) {
            const img = document.createElement('img');
            img.src = agent.avatar_url || 'assets/images/default-avatar.png';
            img.className = 'selected-agent-thumb';
            previewContainer.appendChild(img);
        }
    });
}

function showComparisonModal() {
    if (selectedAgentsForComparison.length < 2) {
        showToast('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ÙˆÙƒÙŠÙ„ÙŠÙ† Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ Ù„Ù„Ù…Ù‚Ø§Ø±Ù†Ø©', 'warning');
        return;
    }

    const agents = selectedAgentsForComparison.map(id => window.currentAgentStats.find(a => a._id === id)).filter(Boolean);
    
    // Determine winners for each category
    const maxViews = Math.max(...agents.map(a => a.total_views || 0));
    const maxReactions = Math.max(...agents.map(a => a.total_reactions || 0));
    const maxParticipants = Math.max(...agents.map(a => a.total_participants || 0));
    const maxGrowth = Math.max(...agents.map(a => a.growth_rate || 0));

    const modalContent = `
        <div class="comparison-modal-content">
            <div class="comparison-header">
                <h2><i class="fas fa-balance-scale"></i> Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡</h2>
                <button class="close-modal-btn"><i class="fas fa-times"></i></button>
            </div>
            <div class="comparison-table-wrapper">
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Ø§Ù„Ù…Ù‚ÙŠØ§Ø³</th>
                            ${agents.map(agent => `
                                <th>
                                    <div class="comparison-agent-header">
                                        <div class="agent-avatar-wrapper">
                                            ${agent.avatar_url 
                                                ? `<img src="${agent.avatar_url}" alt="${agent.name}">` 
                                                : `<div class="default-avatar-placeholder"><i class="fas fa-user-astronaut"></i></div>`
                                            }
                                            <div class="agent-rank-badge rank-${agent.rank}">${agent.rank || '-'}</div>
                                        </div>
                                        <span class="agent-name">${agent.name}</span>
                                        <span class="classification-badge classification-${(agent.classification || '').toLowerCase()}">${agent.classification || ''}</span>
                                    </div>
                                </th>
                            `).join('')}
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="metric-label"><i class="fas fa-trophy"></i> Ø§Ù„Ù…Ø±ØªØ¨Ø©</td>
                            ${agents.map(agent => `<td><span class="rank-value">${agent.rank || '-'}</span></td>`).join('')}
                        </tr>
                        <tr>
                            <td class="metric-label"><i class="fas fa-eye"></i> Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª</td>
                            ${agents.map(agent => {
                                const isWinner = (agent.total_views || 0) === maxViews;
                                return `<td class="${isWinner ? 'comparison-winner' : ''}">
                                    <div class="stat-value-wrapper">
                                        ${formatNumber(agent.total_views)}
                                        ${isWinner ? '<i class="fas fa-crown winner-icon"></i>' : ''}
                                    </div>
                                </td>`;
                            }).join('')}
                        </tr>
                        <tr>
                            <td class="metric-label"><i class="fas fa-heart"></i> Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª</td>
                            ${agents.map(agent => {
                                const isWinner = (agent.total_reactions || 0) === maxReactions;
                                return `<td class="${isWinner ? 'comparison-winner' : ''}">
                                    <div class="stat-value-wrapper">
                                        ${formatNumber(agent.total_reactions)}
                                        ${isWinner ? '<i class="fas fa-crown winner-icon"></i>' : ''}
                                    </div>
                                </td>`;
                            }).join('')}
                        </tr>
                        <tr>
                            <td class="metric-label"><i class="fas fa-users"></i> Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª</td>
                            ${agents.map(agent => {
                                const isWinner = (agent.total_participants || 0) === maxParticipants;
                                return `<td class="${isWinner ? 'comparison-winner' : ''}">
                                    <div class="stat-value-wrapper">
                                        ${formatNumber(agent.total_participants)}
                                        ${isWinner ? '<i class="fas fa-crown winner-icon"></i>' : ''}
                                    </div>
                                </td>`;
                            }).join('')}
                        </tr>
                        <tr>
                            <td class="metric-label"><i class="fas fa-chart-line"></i> Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ù…Ùˆ</td>
                            ${agents.map(agent => {
                                const isWinner = (agent.growth_rate || 0) === maxGrowth;
                                return `<td class="${isWinner ? 'comparison-winner' : ''}">
                                    <div class="stat-value-wrapper">
                                        ${(agent.growth_rate || 0).toFixed(1)}%
                                        ${isWinner ? '<i class="fas fa-crown winner-icon"></i>' : ''}
                                    </div>
                                </td>`;
                            }).join('')}
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    `;

    Swal.fire({
        html: modalContent,
        showConfirmButton: false,
        width: '1000px',
        background: 'transparent',
        customClass: {
            popup: 'no-bg-popup'
        },
        didOpen: () => {
            const closeBtn = document.querySelector('.close-modal-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => Swal.close());
            }
        }
    });
}

// --- NEW: Export to Excel Functionality (Professional) ---
function exportTopAgentsToCSV(agentStats) {
    const sortKey = document.querySelector('.filter-buttons[data-filter-group="sort"] .active')?.dataset.sort || 'total_views';
    const classification = document.querySelector('.filter-buttons[data-filter-group="classification"] .active')?.dataset.filter || 'all';

    // Re-filter and sort the data exactly as it's displayed
    const classificationOrder = { 'R': 1, 'A': 2, 'B': 3, 'C': 4 };
    let agentsToExport = [...(agentStats || [])];

    if (classification !== 'all') {
        agentsToExport = agentsToExport.filter(agent => agent.classification === classification);
    }
    agentsToExport.sort((a, b) => {
        const sortValue = b[sortKey] - a[sortKey];
        if (sortValue !== 0) return sortValue;
        const orderA = classificationOrder[a.classification] || 99;
        const orderB = classificationOrder[b.classification] || 99;
        return orderA - orderB;
    });

    if (!agentsToExport || agentsToExport.length === 0) {
        showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„ØªØµØ¯ÙŠØ±Ù‡Ø§.', 'info');
        return;
    }

    // Check if XLSX library is loaded
    if (typeof XLSX === 'undefined') {
        console.error('XLSX library not loaded');
        showToast('Ù…ÙƒØªØ¨Ø© Excel ØºÙŠØ± Ù…Ø­Ù…Ù„Ø©. ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©.', 'error');
        return;
    }

    try {
        // Prepare data for Excel
        const dataForSheet = agentsToExport.map((agent, index) => ({
            'Ø§Ù„ØªØ±ØªÙŠØ¨': index + 1,
            'Ø§Ø³Ù… Ø§Ù„ÙˆÙƒÙŠÙ„': agent.name || '-',
            'Ø±Ù‚Ù… Ø§Ù„ÙˆÙƒØ§Ù„Ø©': agent.agent_id || '-',
            'Ø§Ù„Ù…Ø±ØªØ¨Ø©': agent.rank || '-',
            'Ø§Ù„ØªØµÙ†ÙŠÙ': agent.classification || '-',
            'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª': agent.total_views || 0,
            'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª': agent.total_reactions || 0,
            'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª': agent.total_participants || 0,
            'Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª': agent.competition_count || 0,
            'Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ù…Ùˆ (%)': (agent.growth_rate || 0).toFixed(2)
        }));

        // Create worksheet
        const ws = XLSX.utils.json_to_sheet(dataForSheet);

        // Set column widths
        ws['!cols'] = [
            { wch: 10 },  // Ø§Ù„ØªØ±ØªÙŠØ¨
            { wch: 25 },  // Ø§Ø³Ù… Ø§Ù„ÙˆÙƒÙŠÙ„
            { wch: 15 },  // Ø±Ù‚Ù… Ø§Ù„ÙˆÙƒØ§Ù„Ø©
            { wch: 18 },  // Ø§Ù„Ù…Ø±ØªØ¨Ø©
            { wch: 12 },  // Ø§Ù„ØªØµÙ†ÙŠÙ
            { wch: 22 },  // Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª
            { wch: 22 },  // Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª
            { wch: 22 },  // Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª
            { wch: 18 },  // Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª
            { wch: 20 }   // Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ù…Ùˆ
        ];

        // Get range
        const range = XLSX.utils.decode_range(ws['!ref']);

        // Style all cells
        for (let R = range.s.r; R <= range.e.r; ++R) {
            for (let C = range.s.c; C <= range.e.c; ++C) {
                const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
                if (!ws[cellAddress]) continue;

                // Initialize style object
                if (!ws[cellAddress].s) ws[cellAddress].s = {};

                // Header row styling (R === 0)
                if (R === 0) {
                    ws[cellAddress].s = {
                        font: { 
                            bold: true, 
                            sz: 14,
                            color: { rgb: "FFFFFF" }
                        },
                        fill: { 
                            fgColor: { rgb: "2E7D32" } // Dark green
                        },
                        alignment: { 
                            horizontal: "center", 
                            vertical: "center",
                            wrapText: true
                        },
                        border: {
                            top: { style: "thin", color: { rgb: "000000" } },
                            bottom: { style: "thin", color: { rgb: "000000" } },
                            left: { style: "thin", color: { rgb: "000000" } },
                            right: { style: "thin", color: { rgb: "000000" } }
                        }
                    };
                } else {
                    // Data rows styling
                    const isEvenRow = (R % 2 === 0);
                    
                    ws[cellAddress].s = {
                        font: { 
                            sz: 11
                        },
                        fill: { 
                            fgColor: { rgb: isEvenRow ? "F5F5F5" : "FFFFFF" } // Alternating row colors
                        },
                        alignment: { 
                            horizontal: "center", 
                            vertical: "center"
                        },
                        border: {
                            top: { style: "thin", color: { rgb: "E0E0E0" } },
                            bottom: { style: "thin", color: { rgb: "E0E0E0" } },
                            left: { style: "thin", color: { rgb: "E0E0E0" } },
                            right: { style: "thin", color: { rgb: "E0E0E0" } }
                        }
                    };

                    // Special styling for top 3 ranks
                    if (C === 0) { // Rank column
                        const rank = ws[cellAddress].v;
                        if (rank === 1) {
                            ws[cellAddress].s.fill = { fgColor: { rgb: "FFD700" } }; // Gold
                            ws[cellAddress].s.font.bold = true;
                            ws[cellAddress].s.font.color = { rgb: "000000" };
                        } else if (rank === 2) {
                            ws[cellAddress].s.fill = { fgColor: { rgb: "C0C0C0" } }; // Silver
                            ws[cellAddress].s.font.bold = true;
                        } else if (rank === 3) {
                            ws[cellAddress].s.fill = { fgColor: { rgb: "CD7F32" } }; // Bronze
                            ws[cellAddress].s.font.bold = true;
                            ws[cellAddress].s.font.color = { rgb: "FFFFFF" };
                        }
                    }

                    // Number formatting for numeric columns
                    if (C >= 5 && C <= 8) { // Numeric columns
                        ws[cellAddress].z = '#,##0'; // Thousands separator
                    } else if (C === 9) { // Growth rate
                        ws[cellAddress].z = '0.00"%"';
                    }
                }
            }
        }

        // Set row heights
        ws['!rows'] = [];
        ws['!rows'][0] = { hpt: 25 }; // Header row height

        // Create workbook
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'Ø£Ø¨Ø±Ø² Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡');

        // Add metadata
        wb.Props = {
            Title: 'ØªÙ‚Ø±ÙŠØ± Ø£Ø¨Ø±Ø² Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡',
            Subject: 'ØªÙ‚Ø±ÙŠØ± Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡',
            Author: 'IB Competition System',
            CreatedDate: new Date()
        };

        // Generate filename with date and time
        const now = new Date();
        const dateStr = now.toISOString().split('T')[0];
        const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-');
        const filename = `ØªÙ‚Ø±ÙŠØ±_Ø§Ø¨Ø±Ø²_Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡_${dateStr}_${timeStr}.xlsx`;

        // Download file
        XLSX.writeFile(wb, filename);
        
        showToast('ØªÙ… ØªØµØ¯ÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰ Excel! ğŸ“Š', 'success');
    } catch (err) {
        console.error('Failed to export to Excel:', err);
        showToast('ÙØ´Ù„ ØªØµØ¯ÙŠØ± Ø§Ù„Ù…Ù„Ù. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.', 'error');
    }
}

function getStartDateForRange(range) {
    const now = new Date();
    if (range === 'week') {
        const firstDayOfWeek = now.getDate() - now.getDay(); // Sunday is the first day
        const startDate = new Date(now.setDate(firstDayOfWeek));
        startDate.setHours(0, 0, 0, 0);
        return startDate;
    }
    if (range === 'month') {
        const startDate = new Date(now.getFullYear(), now.getMonth(), 1);
        startDate.setHours(0, 0, 0, 0);
        return startDate;
    }
    return new Date(0); // Default for 'all'
}

// == profile.js ==
ï»¿// Profile.js - Updated: 2025-11-13 04:36:56
let competitionCountdownIntervals = [];
let renewalCountdownInterval = null; // For the new renewal countdown
let isRenewing = false; // Flag to prevent renewal race condition
const dayNames = ['Ø§Ù„Ø£Ø­Ø¯', 'Ø§Ù„Ø§Ø«Ù†ÙŠÙ†', 'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡', 'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡', 'Ø§Ù„Ø®Ù…ÙŠØ³', 'Ø§Ù„Ø¬Ù…Ø¹Ø©'];
let profilePageEventListeners = []; // Defensive: To manage event listeners

// Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù†Ø³Ø¨ÙŠ
function getRelativeTime(date) {
    const now = new Date();
    const diff = now - date;
    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);

    if (minutes < 1) return 'Ø§Ù„Ø¢Ù†';
    if (minutes < 60) return `Ù…Ù†Ø° ${minutes} Ø¯Ù‚ÙŠÙ‚Ø©`;
    if (hours < 24) return `Ù…Ù†Ø° ${hours} Ø³Ø§Ø¹Ø©`;
    if (days < 7) return `Ù…Ù†Ø° ${days} ÙŠÙˆÙ…`;
    return `Ù…Ù†Ø° ${Math.floor(days / 7)} Ø£Ø³Ø¨ÙˆØ¹`;
}

function stopCompetitionCountdowns() {
    competitionCountdownIntervals.forEach(clearInterval);
    competitionCountdownIntervals = [];
}

// --- NEW: Agent activity timeline renderer ---
function renderAgentActivityTimeline(agentId, container) {
    fetch(`/api/agents/${agentId}/activity-log`)
    .then(res => res.json())
    .then(logs => {
        if (!logs || logs.length === 0) {
            container.innerHTML = '<div class="alert alert-info">Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø³Ø¬Ù„ Ù†Ø´Ø§Ø· Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„.</div>';
            return;
        }

        const getIconForAction = (action) => {
            if (action.includes('ØªØ­Ø¯ÙŠØ«')) return 'fas fa-pencil-alt';
            if (action.includes('Ø¥Ø¶Ø§ÙØ©') || action.includes('ØªØ¹ÙŠÙŠÙ†')) return 'fas fa-plus-circle';
            if (action.includes('Ø­Ø°Ù')) return 'fas fa-trash-alt';
            if (action.includes('ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„')) return 'fas fa-sign-in-alt';
            if (action.includes('ØªØºÙŠÙŠØ± Ø±ØªØ¨Ø©')) return 'fas fa-level-up-alt';
            return 'fas fa-history'; // Default icon
        };

        const timelineHtml = `
            <div class="professional-timeline">
                ${logs.map(log => {
                    const date = new Date(log.timestamp).toLocaleString('ar-EG', { day: 'numeric', month: 'long', year: 'numeric', hour: 'numeric', minute: '2-digit' });
                    const iconClass = getIconForAction(log.action);
                    const details = log.details ? `<p class="timeline-details">${log.details}</p>` : '';
                    
                    return `
                        <div class="timeline-entry">
                            <div class="timeline-icon">
                                <i class="${iconClass}"></i>
                            </div>
                            <div class="timeline-content">
                                <p class="timeline-action">${log.action}</p>
                                <span class="timeline-timestamp">${date}</span>
                                ${details}
                            </div>
                        </div>
                    `;
                }).join('')}
            </div>
        `;
        
        container.innerHTML = `
            <h3 class="section-title-v2">
                <i class="fas fa-stream icon"></i> Ø³Ø¬Ù„ Ø§Ù„Ù†Ø´Ø§Ø·
            </h3>
            ${timelineHtml}
        `;
    })
    .catch(err => {
        console.error('[AgentActivityTimeline] Error:', err);
        container.innerHTML = '<div class="alert alert-danger">Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø³Ø¬Ù„ Ø§Ù„Ù†Ø´Ø§Ø·.</div>';
    });
}

// --- END: Agent activity timeline renderer ---

function stopAllProfileTimers() {
    // A single function to clean up all timers when leaving the profile page.
    // This ensures complete separation.
    stopCompetitionCountdowns();
    if (renewalCountdownInterval) {
        clearInterval(renewalCountdownInterval);
        renewalCountdownInterval = null;
    }
    // Defensive: Remove all dynamically added event listeners for this page
    profilePageEventListeners.forEach(({ element, type, handler }) => {
        if (element) element.removeEventListener(type, handler);
    });
    profilePageEventListeners = [];

    // --- NEW: Unsubscribe from task store ---
    if (window.taskStore && window.profileStoreSubscription) {
        window.taskStore.unsubscribe(window.profileStoreSubscription);
        window.profileStoreSubscription = null;
    }
}

// Function to show rank change modal with reason and action inputs
function showRankChangeModal(agent, newRank, onConfirm, onCancel) {
    const modalContent = `
        <div class="rank-change-modal-dark" style="direction:rtl;text-align:right;font-family:'Cairo',sans-serif;">
            <div class="rcm-shell" style="background:#181a20;border:1px solid #2a2f38;border-radius:14px;overflow:hidden;box-shadow:0 8px 28px rgba(0,0,0,.55);max-width:640px;margin:0 auto;">
                <div class="rcm-header" style="background:linear-gradient(135deg,#222831,#1b2026);padding:14px 18px;display:flex;align-items:center;gap:8px;border-bottom:1px solid #2d343f;">
                    <i class="fas fa-layer-group" style="color:#4fa3ff;font-size:18px;"></i>
                    <h3 style="margin:0;color:#f2f5f7;font-size:17px;font-weight:700;letter-spacing:.5px;">ØªØºÙŠÙŠØ± Ù…Ø±ØªØ¨Ø© Ø§Ù„ÙˆÙƒÙŠÙ„</h3>
                </div>
                <div class="rcm-body" style="padding:18px 20px;background:#1f2228;max-height:70vh;overflow-y:auto;scrollbar-width:thin;">
                    <section class="rcm-agent" style="background:#22262d;border:1px solid #303841;border-radius:10px;padding:14px 16px;margin-bottom:18px;">
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px 18px;font-size:13.5px;">
                            <div style="color:#c9d3dc;"><span style="color:#7f8ea3;font-weight:600;">Ø§Ø³Ù… Ø§Ù„ÙˆÙƒÙŠÙ„:</span> <strong style="color:#fff;">${agent.name}</strong></div>
                            <div style="color:#c9d3dc;"><span style="color:#7f8ea3;font-weight:600;">Ø±Ù‚Ù… Ø§Ù„ÙˆÙƒØ§Ù„Ø©:</span> <strong style="color:#fff;">${agent.agent_id}</strong></div>
                            <div style="color:#c9d3dc;"><span style="color:#7f8ea3;font-weight:600;">Ø§Ù„ØªØµÙ†ÙŠÙ:</span> <strong style="color:#fff;">${agent.classification || agent.class || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}</strong></div>
                            <div style="color:#c9d3dc;"><span style="color:#7f8ea3;font-weight:600;">Ø§Ù„Ù…Ø±ØªØ¨Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©:</span> <span class="rank-chip" style="background:#39424d;color:#fff;padding:2px 10px;border-radius:20px;font-size:12px;">${agent.rank}</span></div>
                        </div>
                        <div style="margin-top:14px;display:flex;justify-content:space-between;align-items:center;gap:12px;">
                            <div style="flex:1;text-align:center;">
                                <div style="color:#b8c2cc;font-size:11px;margin-bottom:4px;">Ø§Ù„Ù…Ø±ØªØ¨Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©</div>
                                <div style="display:inline-block;background:#ffb347;color:#3a2f00;font-weight:600;padding:4px 14px;border-radius:30px;font-size:13px;min-width:110px;">${agent.rank}</div>
                            </div>
                            <i class="fas fa-chevron-left" style="color:#4fa3ff;font-size:20px;"></i>
                            <div style="flex:1;text-align:center;">
                                <div style="color:#b8c2cc;font-size:11px;margin-bottom:4px;">Ø§Ù„Ù…Ø±ØªØ¨Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©</div>
                                <div style="display:inline-block;background:#2fbf71;color:#fff;font-weight:600;padding:4px 14px;border-radius:30px;font-size:13px;min-width:110px;">${newRank}</div>
                            </div>
                        </div>
                    </section>
                    <section class="rcm-inputs" style="display:flex;flex-direction:column;gap:18px;">
                        <div class="rcm-field" style="display:flex;flex-direction:column;gap:6px;">
                            <label for="rankChangeReason" style="color:#d2d8df;font-weight:600;font-size:13.5px;display:flex;align-items:center;gap:6px;">
                                <i class="fas fa-question-circle" style="color:#4fa3ff;"></i>
                                Ù…Ø§ Ù‡Ùˆ Ø³Ø¨Ø¨ ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø±ØªØ¨Ø©ØŸ
                            </label>
                            <textarea id="rankChangeReason" rows="3" placeholder="Ù…Ø«Ø§Ù„: Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªÙØ§Ø¹Ù„ ÙˆØ§Ù„Ù…Ø´Ø§Ø±ÙƒØ§ØªØŒ Ø¹Ø¯Ù… Ø§Ù„ØªØ¹Ø§ÙˆÙ†ØŒ Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡..." style="background:#272c33;color:#f5f7fa;border:1px solid #323b45;border-radius:8px;padding:10px 12px;font-family:inherit;font-size:13px;resize:vertical;outline:none;transition:border .2s, background .2s;" required></textarea>
                        </div>
                        <div class="rcm-field" style="display:flex;flex-direction:column;gap:6px;">
                            <label for="rankChangeAction" style="color:#d2d8df;font-weight:600;font-size:13.5px;display:flex;align-items:center;gap:6px;">
                                <i class="fas fa-tasks" style="color:#4fa3ff;"></i>
                                Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ù„Ù…ØªØ®Ø°ØŸ
                            </label>
                            <textarea id="rankChangeAction" rows="3" placeholder="Ù…Ø«Ø§Ù„: ØªØ±Ù‚ÙŠØ© Ø§Ù„ØªØµÙ†ÙŠÙ Ù…Ù† C Ø¥Ù„Ù‰ BØŒ Ø­Ø±Ù…Ø§Ù† Ù…Ù† Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§ØªØŒ ØªØ±Ù‚ÙŠØ© Ø§Ù„Ù…Ø±ØªØ¨Ø© Ø¥Ù„Ù‰ Silver..." style="background:#272c33;color:#f5f7fa;border:1px solid #323b45;border-radius:8px;padding:10px 12px;font-family:inherit;font-size:13px;resize:vertical;outline:none;transition:border .2s, background .2s;" required></textarea>
                        </div>
                        <div style="text-align:center;margin-top:-4px;">
                            <span style="color:#ff7675;font-size:12.5px;display:inline-flex;align-items:center;gap:6px;">
                                <i class="fas fa-exclamation-triangle"></i>
                                ÙŠØ¬Ø¨ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø³Ø¨Ø¨ ÙˆØ§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±
                            </span>
                        </div>
                    </section>
                </div>
            </div>
        </div>`;

    showConfirmationModal(modalContent, async () => {
        const reason = document.getElementById('rankChangeReason').value.trim();
        const action = document.getElementById('rankChangeAction').value.trim();

        if (!reason || !action) {
            showToast('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø³Ø¨Ø¨ ÙˆØ§Ù„Ø¥Ø¬Ø±Ø§Ø¡', 'error');
            return false; // Prevent modal from closing
        }

        if (onConfirm) {
            await onConfirm(reason, action);
        }
        return true; // Allow modal to close
    }, {
        title: 'ØªØºÙŠÙŠØ± Ù…Ø±ØªØ¨Ø© Ø§Ù„ÙˆÙƒÙŠÙ„',
        confirmText: '<i class="fas fa-check"></i> Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±',
        cancelText: '<i class="fas fa-times"></i> Ø¥Ù„ØºØ§Ø¡',
        onCancel: onCancel
    });

    // CSP-safe: attach focus/blur styling listeners after modal mounts
    setTimeout(() => {
        const reasonEl = document.getElementById('rankChangeReason');
        const actionEl = document.getElementById('rankChangeAction');
        const bind = (el) => {
            if (!el) return;
            const onFocus = () => (el.style.borderColor = '#4fa3ff');
            const onBlur = () => (el.style.borderColor = '#323b45');
            el.addEventListener('focus', onFocus);
            el.addEventListener('blur', onBlur);
            // track for cleanup when leaving profile page
            if (window.profilePageEventListeners) {
                window.profilePageEventListeners.push({ element: el, type: 'focus', handler: onFocus });
                window.profilePageEventListeners.push({ element: el, type: 'blur', handler: onBlur });
            }
        };
        bind(reasonEl);
        bind(actionEl);
    }, 0);
}

// Function to show classification change modal with reason and action inputs
function showClassificationChangeModal(agent, newClassification, onConfirm, onCancel) {
    console.log('ğŸ¯ [showClassificationChangeModal] ========== FUNCTION CALLED ==========');
    console.log('ğŸ¯ [showClassificationChangeModal] Agent:', agent);
    console.log('ğŸ¯ [showClassificationChangeModal] Agent Name:', agent?.name);
    console.log('ğŸ¯ [showClassificationChangeModal] Old Classification:', agent?.classification);
    console.log('ğŸ¯ [showClassificationChangeModal] New Classification:', newClassification);
    console.log('ğŸ¯ [showClassificationChangeModal] onConfirm type:', typeof onConfirm);
    console.log('ğŸ¯ [showClassificationChangeModal] onCancel type:', typeof onCancel);
    console.log('ğŸ¯ [showClassificationChangeModal] showConfirmationModal exists?', typeof showConfirmationModal);
    console.log('ğŸ¯ [showClassificationChangeModal] =======================================');
    
    const modalContent = `
        <div class="classification-change-modal-dark" style="direction:rtl;text-align:right;font-family:'Cairo',sans-serif;">
            <div class="ccm-shell" style="background:#181a20;border:1px solid #2a2f38;border-radius:14px;overflow:hidden;box-shadow:0 8px 28px rgba(0,0,0,.55);max-width:640px;margin:0 auto;">
                <div class="ccm-header" style="background:linear-gradient(135deg,#222831,#1b2026);padding:14px 18px;display:flex;align-items:center;gap:8px;border-bottom:1px solid #2d343f;">
                    <i class="fas fa-tag" style="color:#4fa3ff;font-size:18px;"></i>
                    <h3 style="margin:0;color:#f2f5f7;font-size:17px;font-weight:700;letter-spacing:.5px;">ØªØºÙŠÙŠØ± ØªØµÙ†ÙŠÙ Ø§Ù„ÙˆÙƒÙŠÙ„</h3>
                </div>
                <div class="ccm-body" style="padding:18px 20px;background:#1f2228;max-height:70vh;overflow-y:auto;scrollbar-width:thin;">
                    <section class="ccm-agent" style="background:#22262d;border:1px solid #303841;border-radius:10px;padding:14px 16px;margin-bottom:18px;">
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px 18px;font-size:13.5px;">
                            <div style="color:#c9d3dc;"><span style="color:#7f8ea3;font-weight:600;">Ø§Ø³Ù… Ø§Ù„ÙˆÙƒÙŠÙ„:</span> <strong style="color:#fff;">${agent.name}</strong></div>
                            <div style="color:#c9d3dc;"><span style="color:#7f8ea3;font-weight:600;">Ø±Ù‚Ù… Ø§Ù„ÙˆÙƒØ§Ù„Ø©:</span> <strong style="color:#fff;">${agent.agent_id}</strong></div>
                            <div style="color:#c9d3dc;"><span style="color:#7f8ea3;font-weight:600;">Ø§Ù„Ù…Ø±ØªØ¨Ø©:</span> <strong style="color:#fff;">${agent.rank || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}</strong></div>
                            <div style="color:#c9d3dc;"><span style="color:#7f8ea3;font-weight:600;">Ø§Ù„ØªØµÙ†ÙŠÙ Ø§Ù„Ø­Ø§Ù„ÙŠ:</span> <span class="classification-chip" style="background:#39424d;color:#fff;padding:2px 10px;border-radius:20px;font-size:12px;">${agent.classification}</span></div>
                        </div>
                        <div style="margin-top:14px;display:flex;justify-content:space-between;align-items:center;gap:12px;">
                            <div style="flex:1;text-align:center;">
                                <div style="color:#b8c2cc;font-size:11px;margin-bottom:4px;">Ø§Ù„ØªØµÙ†ÙŠÙ Ø§Ù„Ù‚Ø¯ÙŠÙ…</div>
                                <div style="display:inline-block;background:#ffb347;color:#3a2f00;font-weight:600;padding:4px 14px;border-radius:30px;font-size:13px;min-width:110px;">${agent.classification}</div>
                            </div>
                            <i class="fas fa-chevron-left" style="color:#4fa3ff;font-size:20px;"></i>
                            <div style="flex:1;text-align:center;">
                                <div style="color:#b8c2cc;font-size:11px;margin-bottom:4px;">Ø§Ù„ØªØµÙ†ÙŠÙ Ø§Ù„Ø¬Ø¯ÙŠØ¯</div>
                                <div style="display:inline-block;background:#2fbf71;color:#fff;font-weight:600;padding:4px 14px;border-radius:30px;font-size:13px;min-width:110px;">${newClassification}</div>
                            </div>
                        </div>
                    </section>
                    <section class="ccm-inputs" style="display:flex;flex-direction:column;gap:18px;">
                        <div class="ccm-field" style="display:flex;flex-direction:column;gap:6px;">
                            <label for="classificationChangeReason" style="color:#d2d8df;font-weight:600;font-size:13.5px;display:flex;align-items:center;gap:6px;">
                                <i class="fas fa-question-circle" style="color:#4fa3ff;"></i>
                                Ù…Ø§ Ù‡Ùˆ Ø³Ø¨Ø¨ ØªØºÙŠÙŠØ± Ø§Ù„ØªØµÙ†ÙŠÙØŸ
                            </label>
                            <textarea id="classificationChangeReason" rows="3" placeholder="Ù…Ø«Ø§Ù„: Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªÙØ§Ø¹Ù„ ÙˆØ§Ù„Ù…Ø´Ø§Ø±ÙƒØ§ØªØŒ Ø¹Ø¯Ù… Ø§Ù„Ø§Ù„ØªØ²Ø§Ù…ØŒ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡..." style="background:#272c33;color:#f5f7fa;border:1px solid #323b45;border-radius:8px;padding:10px 12px;font-family:inherit;font-size:13px;resize:vertical;outline:none;transition:border .2s, background .2s;" required></textarea>
                        </div>
                        <div class="ccm-field" style="display:flex;flex-direction:column;gap:6px;">
                            <label for="classificationChangeAction" style="color:#d2d8df;font-weight:600;font-size:13.5px;display:flex;align-items:center;gap:6px;">
                                <i class="fas fa-tasks" style="color:#4fa3ff;"></i>
                                Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ù„Ù…ØªØ®Ø°ØŸ
                            </label>
                            <textarea id="classificationChangeAction" rows="3" placeholder="Ù…Ø«Ø§Ù„: ØªØ±Ù‚ÙŠØ© Ø§Ù„ØªØµÙ†ÙŠÙ Ù…Ù† C Ø¥Ù„Ù‰ BØŒ ØªØ®ÙÙŠØ¶ Ø§Ù„ØªØµÙ†ÙŠÙ Ù…Ù† A Ø¥Ù„Ù‰ BØŒ ØªØºÙŠÙŠØ± Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª..." style="background:#272c33;color:#f5f7fa;border:1px solid #323b45;border-radius:8px;padding:10px 12px;font-family:inherit;font-size:13px;resize:vertical;outline:none;transition:border .2s, background .2s;" required></textarea>
                        </div>
                        <div style="text-align:center;margin-top:-4px;">
                            <span style="color:#ff7675;font-size:12.5px;display:inline-flex;align-items:center;gap:6px;">
                                <i class="fas fa-exclamation-triangle"></i>
                                ÙŠØ¬Ø¨ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø³Ø¨Ø¨ ÙˆØ§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±
                            </span>
                        </div>
                    </section>
                </div>
            </div>
        </div>`;

    console.log('ğŸ¨ [showClassificationChangeModal] Modal HTML created successfully');
    console.log('ğŸ¨ [showClassificationChangeModal] About to call showConfirmationModal...');
    console.log('ğŸ¨ [showClassificationChangeModal] showConfirmationModal function:', showConfirmationModal);
    
    showConfirmationModal(modalContent, async () => {
        console.log('ğŸ’¾ [Classification Modal] ========== CONFIRM CLICKED ==========');
        const reason = document.getElementById('classificationChangeReason')?.value?.trim();
        const action = document.getElementById('classificationChangeAction')?.value?.trim();

        console.log('ğŸ’¾ [Classification Modal] Reason:', reason);
        console.log('ğŸ’¾ [Classification Modal] Action:', action);

        if (!reason || !action) {
            console.log('âŒ [Classification Modal] Missing reason or action - showing error');
            showToast('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø³Ø¨Ø¨ ÙˆØ§Ù„Ø¥Ø¬Ø±Ø§Ø¡', 'error');
            return false; // Prevent modal from closing
        }

        console.log('âœ… [Classification Modal] Valid input - calling onConfirm callback');
        if (onConfirm) {
            await onConfirm(reason, action);
        }
        console.log('âœ… [Classification Modal] onConfirm completed - closing modal');
        return true; // Allow modal to close
    }, {
        title: 'ØªØºÙŠÙŠØ± ØªØµÙ†ÙŠÙ Ø§Ù„ÙˆÙƒÙŠÙ„',
        confirmText: '<i class="fas fa-check"></i> Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±',
        cancelText: '<i class="fas fa-times"></i> Ø¥Ù„ØºØ§Ø¡',
        onCancel: onCancel
    });

    console.log('ğŸ‰ [showClassificationChangeModal] showConfirmationModal called successfully!');
    console.log('ğŸ‰ [showClassificationChangeModal] Modal should be visible now!');

    // CSP-safe: attach focus/blur styling listeners after modal mounts
    setTimeout(() => {
        const reasonEl = document.getElementById('classificationChangeReason');
        const actionEl = document.getElementById('classificationChangeAction');
        const bind = (el) => {
            if (!el) return;
            const onFocus = () => (el.style.borderColor = '#4fa3ff');
            const onBlur = () => (el.style.borderColor = '#323b45');
            el.addEventListener('focus', onFocus);
            el.addEventListener('blur', onBlur);
            // track for cleanup when leaving profile page
            if (window.profilePageEventListeners) {
                window.profilePageEventListeners.push({ element: el, type: 'focus', handler: onFocus });
                window.profilePageEventListeners.push({ element: el, type: 'blur', handler: onBlur });
            }
        };
        bind(reasonEl);
        bind(actionEl);
    }, 0);
}

async function renderAgentProfilePage(agentId, options = {}) {
    // Defensive: Guard against undefined/empty agentId early
    if (!agentId || agentId === 'undefined') {
        const appContent = document.getElementById('app-content');
        if (appContent) {
                appContent.innerHTML = `<div class="error-card"><i class="fas fa-exclamation-triangle"></i><p>Ù…Ø¹Ø±Ù‘Ù Ø§Ù„ÙˆÙƒÙŠÙ„ ØºÙŠØ± ØµØ§Ù„Ø­ Ø£Ùˆ Ù…ÙÙ‚ÙˆØ¯.</p></div>`;
            }
            console.warn('[Profile] Invalid agentId supplied to renderAgentProfilePage:', agentId);
            return;
        }
    isRenewing = false; // Reset the flag on each render
    const appContent = document.getElementById('app-content');
    appContent.innerHTML = '';

    if (!authedFetch) { // Check if authedFetch is available (it's a placeholder for now)
        appContent.innerHTML = `<p class="error">Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠØŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.</p>`;
        return;
    }

    // Clear any previous timers from other profiles
    stopAllProfileTimers();

    // --- Defensive Programming: Use optional chaining and provide defaults ---
    if (!currentUserProfile) { // Worst-case: profile data not loaded yet
        appContent.innerHTML = `<p class="error">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…. ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø©.</p>`;
        return;
    }
    const isSuperAdmin = currentUserProfile?.role === 'super_admin';
    const isAdmin = currentUserProfile?.role === 'admin';
    const userPerms = currentUserProfile?.permissions || {};

    // Check for edit mode in hash, e.g., #profile/123/edit
    const hashParts = window.location.hash.split('/');
    const startInEditMode = hashParts.includes('edit');
    const defaultTab = options.activeTab || 'action';

    // --- STEP 5: MIGRATION TO CUSTOM BACKEND ---
    let agent = null;
    let error = null;
    try {
        const response = await authedFetch(`/api/agents/${agentId}`);
        if (!response.ok) {
            const result = await response.json();
            throw new Error(result.message || 'ÙØ´Ù„ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„.');
        }
        const result = await response.json();
        agent = result.data;
    } catch (e) {
        error = e;
    }

    // --- Defensive Programming: Handle API failures gracefully ---
    let agentCompetitions = [];
    let agentLogs = [];
    try {
        const compResponse = await authedFetch(`/api/competitions?agentId=${agentId}&limit=100&sort=newest`); // Fetch up to 100 competitions for the agent
        const logUrl = `/api/logs?agent_id=${agentId}&limit=50&populate=user`;
        const logResponse = await authedFetch(logUrl); // Fetch latest 50 logs for the agent

        if (compResponse.ok) {
            const compResult = await compResponse.json();
            agentCompetitions = compResult.data || []; // Default to empty array
        } else {
            console.error("Failed to fetch agent competitions.");
            // Don't block rendering, just show an empty list.
        }
        if (logResponse.ok) {
            const logResult = await logResponse.json();
            agentLogs = logResult.data || []; // Default to empty array
        } else {
            console.error("Failed to fetch agent logs.");
        }
    } catch (compError) {
        console.error("Error fetching secondary profile data:", compError);
        // The page can still render without this data.
    }
    if (error || !agent) {
        appContent.innerHTML = `<p class="error">ÙØ´Ù„ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ÙˆÙƒÙŠÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨.</p>`;
        return;
    }

    // --- NEW: Fetch today's task status for this agent from the central store ---
    const today = new Date();
    const todayDayIndex = today.getDay();
    let isTaskDay = (agent.audit_days || []).includes(todayDayIndex);

    // --- NEW: Ensure task store is initialized and get today's task status ---
    await window.taskStore.init(); // Make sure we have the latest task data
    const agentTaskToday = window.taskStore.state.tasks[agentId]?.[todayDayIndex] || { audited: false, competition_sent: false };
    const isAuditedToday = agentTaskToday.audited;

    // --- NEW: Subscribe to task store updates ---
    if (window.taskStore) {
        // Define the update function
        const updateProfileAuditButton = (newState) => {
            const updatedTask = newState.tasks[agentId]?.[todayDayIndex] || { audited: false };
            const isNowAudited = updatedTask.audited;
            
            const auditBtn = document.getElementById('perform-audit-btn');
            
            if (auditBtn) {
                const auditText = auditBtn.querySelector('.audit-status-text');
                const iconEl = auditBtn.querySelector('i');

                // Update button class
                if (isNowAudited) {
                    auditBtn.classList.add('audited');
                    auditBtn.classList.remove('pending');
                } else {
                    auditBtn.classList.add('pending');
                    auditBtn.classList.remove('audited');
                }
                
                // Update button icon and title
                auditBtn.title = isNowAudited ? 'Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚' : 'ØªÙ…ÙŠÙŠØ² ÙƒÙ€ "ØªÙ… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚"';
                if (iconEl) iconEl.className = `fas fa-${isNowAudited ? 'check-circle' : 'clipboard-check'}`;
                
                // Update text
                if (auditText) auditText.textContent = isNowAudited ? 'ØªÙ… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚' : 'Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚';
            }
        };

        // Subscribe
        window.taskStore.subscribe(updateProfileAuditButton);

        // Store the subscription for cleanup
        if (!window.profileStoreSubscription) {
            window.profileStoreSubscription = updateProfileAuditButton;
        } else {
            // If there was an old subscription, unsubscribe it first (though stopAllProfileTimers should have handled it)
            window.taskStore.unsubscribe(window.profileStoreSubscription);
            window.profileStoreSubscription = updateProfileAuditButton;
        }
    }

    const activeCompetition = agentCompetitions.find(c => c.is_active === true);
    const hasActiveCompetition = !!activeCompetition;
    const hasInactiveCompetition = !hasActiveCompetition && agentCompetitions.length > 0;

    let activeCompetitionCountdownHtml = '';
    if (activeCompetition && activeCompetition.ends_at) {
        const endDate = new Date(activeCompetition.ends_at);
        if (endDate.getTime() > new Date().getTime()) {
            // The content will be filled by the live countdown timer
            activeCompetitionCountdownHtml = `<div class="competition-countdown-header" data-end-date="${activeCompetition.ends_at}">
                <i class="fas fa-clock"></i> 
                <span>Ø¬Ø§Ø±ÙŠ Ø­Ø³Ø§Ø¨ Ø§Ù„ÙˆÙ‚Øª...</span>
            </div>`;
        }
    }

    // --- NEW: Create the audit button for the header ---
    // Modified: Always show audit button, clickable container
    const auditButtonHtml = `
        <button id="perform-audit-btn" class="header-audit-status-btn ${isAuditedToday ? 'audited' : 'pending'}" title="${isAuditedToday ? 'Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚' : 'ØªÙ…ÙŠÙŠØ² ÙƒÙ€ "ØªÙ… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚"'}">
            <i class="fas fa-${isAuditedToday ? 'check-circle' : 'clipboard-check'}"></i>
            <span class="audit-status-text">${isAuditedToday ? 'ØªÙ… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚' : 'Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚'}</span>
        </button>`;

    // Helper for audit days in Action Tab
    // --- ØªØ¹Ø¯ÙŠÙ„: Ø¹Ø±Ø¶ Ø£ÙŠØ§Ù… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© ÙÙ‚Ø· ÙƒØ¹Ù„Ø§Ù…Ø§Øª (tags) ---
    const dayNames = ['Ø§Ù„Ø£Ø­Ø¯', 'Ø§Ù„Ø§Ø«Ù†ÙŠÙ†', 'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡', 'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡', 'Ø§Ù„Ø®Ù…ÙŠØ³', 'Ø§Ù„Ø¬Ù…Ø¹Ø©']; 
    const auditDaysHtml = (agent.audit_days && agent.audit_days.length > 0)
        ? `<div class="audit-days-display">${agent.audit_days.sort().map(dayIndex => `<span class="day-tag">${dayNames[dayIndex]}</span>`).join('')}</div>`
        : '<span class="day-tag-none">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£ÙŠØ§Ù… Ù…Ø­Ø¯Ø¯Ø©</span>';

    // --- Defensive Programming: Centralize permission checks after data loading ---
    const canViewFinancials = isSuperAdmin || isAdmin || userPerms.agents?.view_financials;
    const canEditProfile = isSuperAdmin || isAdmin; // Or a specific permission
    const canViewAgentComps = isSuperAdmin || isAdmin || userPerms.agents?.can_view_competitions_tab;
    const canCreateComp = isSuperAdmin || isAdmin || userPerms.competitions?.can_create;
    const canEditComps = isSuperAdmin || isAdmin || userPerms.competitions?.manage_comps === 'full';
    const canManualRenew = isSuperAdmin || isAdmin; // Define who can manually renew

    // --- NEW: Calculate Renewal Info ---
    let renewalInfoHtml = '';
    if (agent.renewal_period && agent.renewal_period !== 'none') {
        const nextRenewal = calculateNextRenewalDate(agent);
        if (nextRenewal) {
            const now = new Date();
            const diffTime = nextRenewal - now;
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            const dateStr = nextRenewal.toLocaleDateString('ar-EG');
            const timeStr = nextRenewal.toLocaleTimeString('ar-EG', { hour: 'numeric', minute: '2-digit' });
            
            renewalInfoHtml = `ÙŠÙØ¬Ø¯Ø¯ ÙÙŠ ${diffDays} Ø£ÙŠØ§Ù… (${dateStr} Ø§Ù„Ø³Ø§Ø¹Ø© ${timeStr})`;
        }
    }

    appContent.innerHTML = `
        <div class="profile-page-top-bar">
            <button id="back-btn" class="btn-secondary">&larr; Ø¹ÙˆØ¯Ø©</button>
            ${renewalInfoHtml ? `<div id="renewal-date-display" class="countdown-timer">${renewalInfoHtml}</div>` : ''}
        </div>
        
        <div class="profile-header-v2">
            <div class="profile-avatar">
                ${agent.avatar_url ? `<img src="${agent.avatar_url}" alt="Avatar">` : '<i class="fas fa-user-astronaut"></i>'}
            </div>
            <div class="profile-main-info" data-agent-id="${agent._id}">
                <div class="profile-info-header">
                    <h1>${agent.name}</h1>
                    <div class="profile-badges">
                        ${hasActiveCompetition ? `<span class="status-badge active">Ù…Ø³Ø§Ø¨Ù‚Ø© Ù†Ø´Ø·Ø©</span>${activeCompetitionCountdownHtml}` : ''}
                        ${hasInactiveCompetition ? `<span class="status-badge inactive">Ù…Ø³Ø§Ø¨Ù‚Ø© ØºÙŠØ± Ù†Ø´Ø·Ø©</span>` : ''}
                    </div>
                </div>
                
                <div class="profile-info-grid">
                    <div class="info-item">
                        <span class="label">Ø±Ù‚Ù… Ø§Ù„ÙˆÙƒØ§Ù„Ø©</span>
                        <span class="value agent-id-text" title="Ù†Ø³Ø® Ø§Ù„Ø±Ù‚Ù…">${agent.agent_id}</span>
                    </div>
                    <div class="info-item">
                        <span class="label">Ø§Ù„ØªØµÙ†ÙŠÙ</span>
                        <span class="value badge-classification">${agent.classification}</span>
                    </div>
                    <div class="info-item">
                        <span class="label">Ø§Ù„Ù…Ø±ØªØ¨Ø©</span>
                        <span class="value badge-rank">${agent.rank || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}</span>
                    </div>
                    
                    <div class="info-item">
                        <span class="label">Ù…Ø¹Ø±Ù Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©</span>
                        <span class="value">${agent.telegram_chat_id || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}</span>
                    </div>
                    <div class="info-item">
                        <span class="label">Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©</span>
                        <span class="value">${agent.telegram_group_name || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}</span>
                    </div>
                    <div class="info-item">
                        <span class="label">Ø£ÙŠØ§Ù… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚</span>
                        <div class="value audit-days-mini">${auditDaysHtml}</div>
                    </div>

                    <div class="info-item full-width">
                        <span class="label">Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØªÙ„Ø¬Ø±Ø§Ù…</span>
                        <div class="value links-row">
                            ${agent.telegram_channel_url ? `<a href="${agent.telegram_channel_url}" target="_blank" class="telegram-link"><i class="fab fa-telegram-plane"></i> Ø±Ø§Ø¨Ø· Ø§Ù„Ù‚Ù†Ø§Ø©</a>` : '<span class="disabled-link">Ø±Ø§Ø¨Ø· Ø§Ù„Ù‚Ù†Ø§Ø© (ØºÙŠØ± Ù…Ø­Ø¯Ø¯)</span>'}
                            ${agent.telegram_group_url ? `<a href="${agent.telegram_group_url}" target="_blank" class="telegram-link"><i class="fab fa-telegram-plane"></i> Ø±Ø§Ø¨Ø· Ø§Ù„Ø¬Ø±ÙˆØ¨</a>` : '<span class="disabled-link">Ø±Ø§Ø¨Ø· Ø§Ù„Ø¬Ø±ÙˆØ¨ (ØºÙŠØ± Ù…Ø­Ø¯Ø¯)</span>'}
                        </div>
                    </div>
                </div>
                
                <div class="profile-header-actions-row">
                     ${auditButtonHtml}
                     <button id="edit-profile-btn" class="btn-secondary"><i class="fas fa-user-edit"></i> ØªØ¹Ø¯ÙŠÙ„</button>
                </div>
            </div>
        </div>

        <div class="tabs">
            <button class="tab-link active" data-tab="action">Action</button>
            <button class="tab-link" data-tab="details">ØªÙØ§ØµÙŠÙ„</button>
            <button class="tab-link" data-tab="agent-competitions">Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª</button>
            <button class="tab-link" data-tab="log">Ø³Ø¬Ù„</button>
            ${(isSuperAdmin || isAdmin) ? '<button class="tab-link" data-tab="analytics">ØªØ­Ù„ÙŠÙ„Ø§Øª</button>' : ''}
        </div>

        <div id="tab-action" class="tab-content active">
            <div class="action-tab-grid">
                <div class="action-section">
                    <h2><i class="fas fa-info-circle"></i> Ø¨ÙŠØ§Ù†Ø§Øª ØªÙ„Ù‚Ø§Ø¦ÙŠØ©</h2>
                    <div class="action-info-grid">
                        <div class="action-info-card">
                            <i class="fas fa-calendar-check"></i>
                            <div class="info">
                                <label>Ø£ÙŠØ§Ù… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚</label>
                                <div class="value-group">${auditDaysHtml}</div>
                            </div>
                        </div>
                        <div class="action-info-card">
                            <i class="fas fa-wallet"></i>
                            <div class="info">
                                <label>Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ</label>
                                <p>$${Math.max(0, agent.remaining_balance || 0)}</p>
                            </div>
                        </div>
                        <div class="action-info-card">
                            <i class="fas fa-gift"></i>
                            <div class="info">
                                <label>Ø¨ÙˆÙ†Øµ Ø§Ù„Ø¥ÙŠØ¯Ø§Ø¹</label>
                                <p>${Math.max(0, agent.remaining_deposit_bonus || 0)} <span class="sub-value">Ù…Ø±Ø§Øª Ø¨Ù†Ø³Ø¨Ø©</span> ${agent.deposit_bonus_percentage || 0}%</p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="action-section">
                    <h2><i class="fas fa-rocket"></i> Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø³Ø±ÙŠØ¹Ø©</h2>
                    <div class="details-actions">
                        <button id="create-agent-competition" class="btn-primary"><i class="fas fa-magic"></i> Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø©</button>
                        <button id="select-agent-winners" class="btn-winners"><i class="fas fa-trophy"></i> Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†</button>
                        <button id="send-bonus-cliche-btn" class="btn-telegram-bonus"><i class="fas fa-paper-plane"></i> Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ„ÙŠØ´Ø© Ø§Ù„Ø¨ÙˆÙ†Øµ</button>
                        <button id="send-winners-cliche-btn" class="btn-telegram-winners"><i class="fas fa-trophy"></i> Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ„ÙŠØ´Ø© Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†</button>
                        ${canManualRenew ? `<button id="manual-renew-btn" class="btn-renewal"><i class="fas fa-sync-alt"></i> ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø±ØµÙŠØ¯ ÙŠØ¯ÙˆÙŠØ§Ù‹</button>` : ''}
                    </div>
                </div>
            </div>
        </div>
        <div id="tab-details" class="tab-content">
            <!-- Content will be rendered here -->
        </div>
        <div id="tab-agent-competitions" class="tab-content">
            <!-- Content will be rendered here -->
        </div>
        <div id="tab-log" class="tab-content">
            <h2>Ø³Ø¬Ù„ Ø§Ù„Ù†Ø´Ø§Ø·</h2>
            <p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ø³Ø¬Ù„Ø§Øª Ø­Ø§Ù„ÙŠØ§Ù‹ Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„.</p>
        </div>
        <div id="tab-analytics" class="tab-content">
            <!-- Analytics content will be rendered here -->
        </div>
    `;
 
    document.getElementById('back-btn').addEventListener('click', () => {
        window.location.hash = '#manage-agents';
    });

    // Click to copy agent ID from header
    const agentIdEl = appContent.querySelector('.profile-main-info .agent-id-text');
    if (agentIdEl) {
        agentIdEl.addEventListener('click', () => {
            navigator.clipboard.writeText(agent.agent_id).then(() => showToast(`ØªÙ… Ù†Ø³Ø® Ø§Ù„Ø±Ù‚Ù…: ${agent.agent_id}`, 'info'));
        });
    }

    const createCompBtn = document.getElementById('create-agent-competition');
    if (createCompBtn) {
        if (canCreateComp) { // This will be migrated later
            createCompBtn.addEventListener('click', () => {
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ Ù‚Ø¨Ù„ Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø© - REMOVED per user request
                /*
                if (!agent.is_auditing_enabled) {
                    showToast('Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù‚Ø¨Ù„ Ø¥ØªÙ…Ø§Ù… Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„.', 'error');
                    return;
                }
                */
                window.location.hash = `competitions/new?agentId=${agent._id}`;
            });
        } else {
            createCompBtn.addEventListener('click', () => showToast('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø©.', 'error'));
        }
    }

    const selectWinnersBtn = document.getElementById('select-agent-winners');
    if (selectWinnersBtn) {
        selectWinnersBtn.addEventListener('click', () => window.location.hash = `winner-roulette?agent_id=${agent._id}`);
    }

    // --- NEW: Event listener for the new audit button ---
    const auditBtn = document.getElementById('perform-audit-btn');
    if (auditBtn) {
        // --- MODIFICATION: Make the button a toggle ---
        auditBtn.addEventListener('click', async () => {
            // --- REFACTOR: Centralize state management for immediate UI feedback ---
            const wasAudited = auditBtn.classList.contains('audited');
            const newAuditStatus = !wasAudited;
            const statusTextEl = auditBtn.querySelector('.audit-status-text');
            const iconEl = auditBtn.querySelector('i');
 
            auditBtn.disabled = true;
            if (iconEl) iconEl.className = 'fas fa-spinner fa-spin';
 
            // 1. Optimistically update the UI
            auditBtn.classList.toggle('pending', !newAuditStatus);
            auditBtn.classList.toggle('audited', newAuditStatus);
            if (iconEl) iconEl.className = `fas fa-${newAuditStatus ? 'check-circle' : 'clipboard-check'}`;
            if (statusTextEl) statusTextEl.textContent = newAuditStatus ? 'ØªÙ… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚' : 'Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚';
            auditBtn.title = newAuditStatus ? 'Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚' : 'ØªÙ…ÙŠÙŠØ² ÙƒÙ€ "ØªÙ… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚"';
 
            // 2. Call the new backend endpoint to toggle is_auditing_enabled
            try {
                // First, toggle the is_auditing_enabled field in the database
                const auditingResponse = await authedFetch(`/api/agents/${agent._id}/toggle-auditing`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ is_auditing_enabled: newAuditStatus })
                });

                if (!auditingResponse.ok) {
                    const errorData = await auditingResponse.json();
                    throw new Error(errorData.message || 'ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
                }

                // Then, update the daily task status
                await window.taskStore.updateTaskStatus(agent._id, todayDayIndex, 'audited', newAuditStatus);
                
                // Log this important activity
                const logMessage = `ØªÙ… ${newAuditStatus ? 'ØªÙØ¹ÙŠÙ„' : 'Ø¥Ù„ØºØ§Ø¡ ØªÙØ¹ÙŠÙ„'} Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ Ù„Ù„ÙˆÙƒÙŠÙ„ ${agent.name}`;
                await logAgentActivity(currentUserProfile?._id, agent._id, 'TASK_UPDATE', logMessage);

                showToast('ØªÙ… ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                
                // Update local agent object
                agent.is_auditing_enabled = newAuditStatus;
            } catch (error) {
                console.error('[Audit Toggle Error]:', error);
                showToast(error.message || 'ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚.', 'error');
                // Revert UI on error
                auditBtn.classList.toggle('pending', wasAudited);
                auditBtn.classList.toggle('audited', !wasAudited);
                if (iconEl) iconEl.className = `fas fa-${wasAudited ? 'check-circle' : 'clipboard-check'}`;
                if (statusTextEl) statusTextEl.textContent = wasAudited ? 'ØªÙ… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚' : 'Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚';
                auditBtn.title = wasAudited ? 'Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚' : 'ØªÙ…ÙŠÙŠØ² ÙƒÙ€ "ØªÙ… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚"';
            } finally {
                auditBtn.disabled = false; // Re-enable the button
            }
        });
    }

    // --- NEW: Listen for real-time auditing updates ---
    const handleAuditingUpdate = (event) => {
        const data = event.detail;
        // Check if the update is for the currently displayed agent
        if (data.agentId === agent._id) {
            const auditBtn = document.getElementById('perform-audit-btn');
            
            if (auditBtn) {
                const newAuditStatus = data.isAuditingEnabled;
                const iconEl = auditBtn.querySelector('i');
                const statusTextEl = auditBtn.querySelector('.audit-status-text');

                auditBtn.classList.toggle('pending', !newAuditStatus);
                auditBtn.classList.toggle('audited', newAuditStatus);
                if (iconEl) iconEl.className = `fas fa-${newAuditStatus ? 'check-circle' : 'clipboard-check'}`;
                if (statusTextEl) statusTextEl.textContent = newAuditStatus ? 'ØªÙ… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚' : 'Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚';
                auditBtn.title = newAuditStatus ? 'Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚' : 'ØªÙ…ÙŠÙŠØ² ÙƒÙ€ "ØªÙ… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚"';
                
                // Update local agent object to keep state consistent
                agent.is_auditing_enabled = newAuditStatus;
            }
        }
    };
    
    // --- NEW: Listen for real-time competition updates ---
    const handleCompetitionUpdate = (event) => {
        const data = event.detail;
        if (data.agentId === agent._id) {
            // Refresh the profile page to show the new competition status
            // Ideally we would just update the DOM, but reloading the profile function is safer to ensure all state (timers, badges) is correct.
            console.log('[Profile] Received competition update, refreshing view...');
            
            // Update the header badge immediately for better UX
            const headerTitle = document.querySelector('.profile-main-info h1');
            if (headerTitle) {
                if (data.type === 'created') {
                    // Remove existing badges
                    const existingBadges = headerTitle.querySelectorAll('.status-badge');
                    existingBadges.forEach(b => b.remove());
                    
                    // Add active badge
                    const badge = document.createElement('span');
                    badge.className = 'status-badge active';
                    badge.textContent = 'Ù…Ø³Ø§Ø¨Ù‚Ø© Ù†Ø´Ø·Ø©';
                    headerTitle.appendChild(badge);
                } else if (data.type === 'completed') {
                     // Remove existing badges
                    const existingBadges = headerTitle.querySelectorAll('.status-badge');
                    existingBadges.forEach(b => b.remove());
                    
                    // Add inactive badge
                    const badge = document.createElement('span');
                    badge.className = 'status-badge inactive';
                    badge.textContent = 'Ù…Ø³Ø§Ø¨Ù‚Ø© ØºÙŠØ± Ù†Ø´Ø·Ø©';
                    headerTitle.appendChild(badge);
                }
            }

            // Reload the full profile after a short delay to allow backend to settle
            setTimeout(() => {
                renderAgentProfilePage(agent._id, { activeTab: 'agent-competitions' });
            }, 1000);
        }
    };

    window.addEventListener('agent-auditing-update', handleAuditingUpdate);
    window.addEventListener('competition-update', handleCompetitionUpdate);
    
    // Add to cleanup list so it gets removed when navigating away
    if (window.profilePageEventListeners) {
        window.profilePageEventListeners.push({ element: window, type: 'agent-auditing-update', handler: handleAuditingUpdate });
        window.profilePageEventListeners.push({ element: window, type: 'competition-update', handler: handleCompetitionUpdate });
    }

    // --- Manual Renewal Button Logic ---
    const manualRenewBtn = document.getElementById('manual-renew-btn');
    if (manualRenewBtn) {
      manualRenewBtn.addEventListener('click', async () => {
        if (!agent.renewal_period || agent.renewal_period === 'none') {
            showToast('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù†Ø¸Ø§Ù… ØªØ¬Ø¯ÙŠØ¯ Ù…ÙØ¹Ù„ Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„.', 'info');
            return;
        }

        // Calculate next renewal date (same logic as the countdown)
        const renewalBtn = manualRenewBtn;
        const lastRenewal = agent.last_renewal_date ? new Date(agent.last_renewal_date) : new Date(agent.created_at);
        let nextRenewalDate = new Date(lastRenewal);
        const period = agent.renewal_period;
        if (period === 'weekly') nextRenewalDate.setDate(lastRenewal.getDate() + 7);
        else if (period === 'biweekly') nextRenewalDate.setDate(lastRenewal.getDate() + 14);
        else if (period === 'monthly') nextRenewalDate.setMonth(lastRenewal.getMonth() + 1);

        if (new Date() < nextRenewalDate) {
            const remainingTime = nextRenewalDate - new Date();
            const days = Math.ceil(remainingTime / (1000 * 60 * 60 * 24)); // Use ceil to show "1 day" for any remaining time
            showToast(`Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø¢Ù†. Ù…ØªØ¨Ù‚ÙŠ ${days} ÙŠÙˆÙ….`, 'warning');
            return;
        }

        // If eligible, show confirmation
        showConfirmationModal(
            `Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† ØªØ¬Ø¯ÙŠØ¯ Ø±ØµÙŠØ¯ Ø§Ù„ÙˆÙƒÙŠÙ„ <strong>${agent.name}</strong> ÙŠØ¯ÙˆÙŠØ§Ù‹ØŸ`,
            async () => {
                // Defensive: Disable button immediately
                renewalBtn.disabled = true;
                renewalBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

                const updateData = {
                    consumed_balance: 0,
                    remaining_balance: agent.competition_bonus,
                    used_deposit_bonus: 0,
                    remaining_deposit_bonus: agent.deposit_bonus_count,
                    last_renewal_date: new Date().toISOString()
                };

                // --- STEP 5: MIGRATION TO CUSTOM BACKEND ---
                try {
                    const response = await authedFetch(`/api/agents/${agent._id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(updateData)
                    });
                    if (!response.ok) {
                        const result = await response.json();
                        throw new Error(result.message || 'ÙØ´Ù„ ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø±ØµÙŠØ¯.');
                    }
                    // --- FIX: Add correct logging for manual renewal ---
                    await logAgentActivity(currentUserProfile?._id, agent._id, 'MANUAL_RENEWAL', `ØªÙ… ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø±ØµÙŠØ¯ ÙŠØ¯ÙˆÙŠØ§Ù‹ Ù„Ù„ÙˆÙƒÙŠÙ„ ${agent.name}.`, {
                        renewed_by: currentUserProfile?.full_name || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ',
                        new_balance: agent.competition_bonus
                    });
                    showToast('ØªÙ… ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø±ØµÙŠØ¯ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                    renderAgentProfilePage(agent._id, { activeTab: 'action' }); // Re-render the page
                } catch (error) {
                    showToast(`ÙØ´Ù„ ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø±ØµÙŠØ¯: ${error.message}`, 'error');
                    // Defensive: Re-enable button on failure
                    renewalBtn.disabled = false;
                    renewalBtn.innerHTML = '<i class="fas fa-sync-alt"></i> ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø±ØµÙŠØ¯ ÙŠØ¯ÙˆÙŠØ§Ù‹';
                }
            },
            {
                title: 'ØªØ£ÙƒÙŠØ¯ Ø§Ù„ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„ÙŠØ¯ÙˆÙŠ',
                confirmText: 'Ù†Ø¹Ù…ØŒ Ø¬Ø¯Ø¯ Ø§Ù„Ø¢Ù†',
                confirmClass: 'btn-renewal'
            }
        );
      });
    }

    document.getElementById('send-bonus-cliche-btn').addEventListener('click', async () => {
        // 1. Construct the message
        const baseLine = `ÙŠØ³Ø±Ù†Ø§ Ø§Ù† Ù†Ø­ÙŠØ·Ùƒ Ø¹Ù„Ù…Ø§ Ø¨Ø£Ù† Ø­Ø¶Ø±ØªÙƒ ÙƒÙˆÙƒÙŠÙ„ Ù„Ø¯Ù‰ Ø´Ø±ÙƒØ© Ø§Ù†Ø²Ùˆ ØªØªÙ…ØªØ¹ Ø¨Ø±ØµÙŠØ¯ Ù…Ø³Ø§Ø¨Ù‚Ø§Øª:`

        // --- NEW: Add renewal period text ---
        const renewalPeriodMap = {
            'weekly': 'Ø£Ø³Ø¨ÙˆØ¹ÙŠ',
            'biweekly': 'ÙƒÙ„ Ø£Ø³Ø¨ÙˆØ¹ÙŠÙ†',
            'monthly': 'Ø´Ù‡Ø±ÙŠ'
        };
        const renewalValue = (agent.renewal_period && agent.renewal_period !== 'none') 
            ? (renewalPeriodMap[agent.renewal_period] || '')
            : '';

        // --- ØªØ¹Ø¯ÙŠÙ„: Ø¨Ù†Ø§Ø¡ Ù†Øµ Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª Ø­Ø³Ø¨ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯ ---
        let benefitsText = '';
        const remainingBalance = agent.remaining_balance || 0;
        const remainingDepositBonus = agent.remaining_deposit_bonus || 0;

        if (remainingBalance > 0) {
            benefitsText += `ğŸ’° <b>Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ:</b> <code>${remainingBalance}$</code>\n`;
        }
        if (remainingDepositBonus > 0) {
            benefitsText += `ğŸ <b>Ø¨ÙˆÙ†Øµ Ø§ÙŠØ¯Ø§Ø¹:</b> <code>${remainingDepositBonus}</code> Ù…Ø±Ø§Øª Ø¨Ù†Ø³Ø¨Ø© <code>${agent.deposit_bonus_percentage || 0}%</code>\n`;
        }

        // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø£ÙŠ Ù…Ù…ÙŠØ²Ø§ØªØŒ Ù„Ø§ ØªÙ‚Ù… Ø¨Ø§Ù„Ø¥Ø±Ø³Ø§Ù„
        if (!benefitsText.trim()) {
            showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø±ØµØ¯Ø© Ù…ØªØ§Ø­Ø© Ù„Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ„ÙŠØ´Ø© Ø§Ù„Ø¨ÙˆÙ†Øµ Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„.', 'info');
            return;
        }
        
        const clicheText = `<b>Ø¯Ù…Øª Ø¨Ø®ÙŠØ± Ø´Ø±ÙŠÙƒÙ†Ø§ Ø§Ù„Ø¹Ø²ÙŠØ² ${agent.name}</b> ...

${baseLine}
${renewalValue ? `(<b>${renewalValue}</b>):\n\n` : ''}${benefitsText.trim()}

Ø¨Ø§Ù…ÙƒØ§Ù†Ùƒ Ø§Ù„Ø§Ø³ØªÙØ§Ø¯Ø© Ù…Ù†Ù‡ Ù…Ù† Ø®Ù„Ø§Ù„ Ø§Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ø³Ø¨ÙˆØ¹ÙŠØ© Ù„ØªÙ†Ù…ÙŠØ© ÙˆØªØ·ÙˆÙŠØ± Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø§Ù„ØªØ§Ø¨Ø¹ÙŠÙ† Ù„Ù„ÙˆÙƒØ§Ù„Ø©.

Ù‡Ù„ ØªØ±ØºØ¨ Ø¨Ø§Ø±Ø³Ø§Ù„ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù„Ø­Ø¶Ø±ØªÙƒ?`;

        // --- Verification Logic ---
        let targetGroupInfo = 'Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø¹Ø§Ù…Ø©';
        // --- FIX: Check for chat_id first and show a clear error if it's missing ---
        if (!agent.telegram_chat_id) {
            showToast('Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø¥Ø±Ø³Ø§Ù„. Ù…Ø¹Ø±Ù Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„ØªÙ„Ø¬Ø±Ø§Ù… ØºÙŠØ± Ù…Ø³Ø¬Ù„ Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„.', 'error');
            return; // Stop the process
        }

        if (agent.telegram_chat_id && agent.telegram_group_name) {
            try {
                showToast('Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©...', 'info');
                const response = await authedFetch(`/api/get-chat-info?chatId=${agent.telegram_chat_id}`);
                const data = await response.json();
                // --- FIX: Handle 404 Not Found specifically ---
                if (response.status === 404) {
                    throw new Error('Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø© Ø£Ùˆ ØªÙ… Ø·Ø±Ø¯ Ø§Ù„Ø¨ÙˆØª Ù…Ù†Ù‡Ø§.');
                } else if (!response.ok) {
                    throw new Error(data.message || 'ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©.');
                }

                const actualGroupName = data.title;
                if (actualGroupName.trim() !== agent.telegram_group_name.trim()) {
                    showToast(`<b>Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚:</b> Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ù…Ø³Ø¬Ù„ (<b>${agent.telegram_group_name}</b>) Ù„Ø§ ÙŠØ·Ø§Ø¨Ù‚ Ø§Ù„Ø§Ø³Ù… Ø§Ù„ÙØ¹Ù„ÙŠ Ø¹Ù„Ù‰ ØªÙ„Ø¬Ø±Ø§Ù… (<b>${actualGroupName}</b>). ÙŠØ±Ø¬Ù‰ ØªØµØ­ÙŠØ­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.`, 'error');
                    return; // Stop the process
                }
                // Verification successful
                targetGroupInfo = `Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„ÙˆÙƒÙŠÙ„: <strong>${agent.telegram_group_name}</strong> (ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨Ù†Ø¬Ø§Ø­)`;

            } catch (error) {
                showToast(`ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: ${error.message}`, 'error');
                return; // Stop the process
            }
        } else if (agent.telegram_chat_id) {
            showToast('Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ­Ù‚Ù‚. Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© ØºÙŠØ± Ù…Ø³Ø¬Ù„ Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„.', 'warning');
            return;
        }
        // --- End Verification Logic ---

        // Show confirmation modal only after successful verification (if applicable)
        showConfirmationModal(
            `<p>Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰: ${targetGroupInfo}. Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŸ</p>
             <textarea class="modal-textarea-preview" readonly>${clicheText}</textarea>`,
            async () => {
                try {
                    if (!agent.telegram_chat_id) throw new Error('Ù…Ø¹Ø±Ù Ù…Ø¬Ù…ÙˆØ¹Ø© ØªÙ„Ø¬Ø±Ø§Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„.');
                    const response = await authedFetch('/api/post-announcement', { // This will be migrated Ù„Ø§Ø­Ù‚Ø§Ù‹
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json;charset=UTF-8' },
                        body: JSON.stringify({ message: clicheText, chatId: agent.telegram_chat_id })
                    });
                    if (!response.ok) {
                        const result = await response.json();
                        throw new Error(result.message || 'ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø®Ø§Ø¯Ù….');
                    }
                    showToast('ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ„ÙŠØ´Ø© Ø§Ù„Ø¨ÙˆÙ†Øµ Ø¥Ù„Ù‰ ØªÙ„Ø¬Ø±Ø§Ù… Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                    // --- FIX: Add correct logging for sending bonus cliche ---
                    await logAgentActivity(currentUserProfile?._id, agent._id, 'BONUS_CLICHE_SENT', `ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ„ÙŠØ´Ø© ØªØ°ÙƒÙŠØ± Ø§Ù„Ø¨ÙˆÙ†Øµ Ø¥Ù„Ù‰ ØªÙ„Ø¬Ø±Ø§Ù….`, {
                        sent_by: currentUserProfile?.full_name
                    });
                } catch (error) {
                    showToast(`ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙƒÙ„ÙŠØ´Ø©: ${error.message}`, 'error');
                }
            },
            {
                title: 'Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆÙ†Øµ',
                confirmText: 'Ø¥Ø±Ø³Ø§Ù„',
                confirmClass: 'btn-telegram-bonus',
                modalClass: 'modal-wide'
            }
        );
    });

    document.getElementById('send-winners-cliche-btn').addEventListener('click', async () => {
        // --- NEW: Use centralized verification function ---
        const verification = await verifyTelegramChat(agent);
        if (!verification.verified) {
            return;
        }
        const targetGroup = `Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„ÙˆÙƒÙŠÙ„: <strong>${agent.telegram_group_name}</strong> (ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚)`;
        // --- End Verification ---
        // Defensive: Find active competition, but handle if it's not found
        const activeCompetition = agentCompetitions.find(c => c.is_active);

        const clicheText = `Ø§Ù„Ø£Ø³Ø§ØªØ°Ø© Ø§Ù„ÙƒØ±Ø§Ù…ØŒ

Ù†Ø­ÙŠØ·ÙƒÙ… Ø¹Ù„Ù…Ù‹Ø§ Ø¨Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ø¯Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„Ø£Ø®ÙŠØ±Ø©.
ğŸ”¹ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©: ${activeCompetition?.correct_answer || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø©'}

ÙŠØ±Ø¬Ù‰ ØªØ²ÙˆÙŠØ¯Ù†Ø§ Ø¨Ø±Ø§Ø¨Ø· Ù…Ù†Ø´ÙˆØ± Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ù…Ù† Ù‚Ù†Ø§ØªÙƒÙ… Ù„ÙŠÙ‚ÙˆÙ… Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ù…Ø®ØªØµ Ø¨Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ÙŠØ§Ù†Ø§ØªÙ‡Ù…ØŒ Ø«Ù… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ø¥Ù„ÙŠÙƒÙ… Ù„Ù„Ø¥Ø¹Ù„Ø§Ù† Ø¹Ù†Ù‡Ø§.

Ù…Ø¹ Ø®Ø§Ù„Øµ Ø§Ù„ØªÙ‚Ø¯ÙŠØ±ØŒ
Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª â€“ Ø§Ù†Ø²Ùˆ`;

        // Show confirmation modal before sending
        showConfirmationModal(
            `<p>Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰: ${targetGroup}. Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŸ</p>
             <textarea class="modal-textarea-preview" readonly>${clicheText}</textarea>`,
            async () => {
                // Send to backend on confirmation
                try {
                    if (!agent.telegram_chat_id) throw new Error('Ù…Ø¹Ø±Ù Ù…Ø¬Ù…ÙˆØ¹Ø© ØªÙ„Ø¬Ø±Ø§Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„.');
                    const response = await authedFetch('/api/post-announcement', { // This will be migrated Ù„Ø§Ø­Ù‚Ø§Ù‹
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json;charset=UTF-8' },
                        body: JSON.stringify({ message: clicheText, chatId: agent.telegram_chat_id })
                    });
                    const result = await response.json();
                    if (!response.ok) throw new Error(result.message || 'ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø®Ø§Ø¯Ù….');

                    showToast('ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø¥Ù„Ù‰ ØªÙ„Ø¬Ø±Ø§Ù… Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                    // --- FIX: Add correct logging for winner selection request ---
                    await logAgentActivity(currentUserProfile?._id, agent._id, 'WINNERS_SELECTION_REQUESTED', `ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© "${activeCompetition?.name || 'Ø§Ù„Ø£Ø®ÙŠØ±Ø©'}".`, {
                        sent_by: currentUserProfile?.full_name
                    });
                } catch (error) {
                    showToast(`ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø·Ù„Ø¨: ${error.message}`, 'error');
                }
            },
            {
                title: 'Ø·Ù„Ø¨ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†',
                confirmText: 'Ø¥Ø±Ø³Ø§Ù„',
                confirmClass: 'btn-telegram-winners',
                modalClass: 'modal-wide'
            }
        );
    });

    const editBtn = document.getElementById('edit-profile-btn');
    if (editBtn) {
        if (canEditProfile) { // This will be migrated later
            editBtn.addEventListener('click', () => renderEditProfileHeader(agent));
        } else {
            editBtn.addEventListener('click', () => showToast('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„ØªØ¹Ø¯ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„.', 'error'));
        }
    }

    if (startInEditMode) {
        editBtn.click();
    }

    // Tab switching logic
    const tabLinks = appContent.querySelectorAll('.tab-link');
    const tabContents = appContent.querySelectorAll('.tab-content');

    tabLinks.forEach(link => {
        link.addEventListener('click', () => {
            const tabId = link.dataset.tab;

            // If clicking on "Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª" tab, redirect to agent-competitions page
            if (tabId === 'agent-competitions') {
                window.location.href = `/pages/agent-competitions.html?agent_id=${agent._id}`;
                return;
            }

            // Deactivate all
            tabLinks.forEach(l => l.classList.remove('active'));
            tabContents.forEach(c => c.classList.remove('active'));

            // Activate the clicked one
            link.classList.add('active');
            document.getElementById(`tab-${tabId}`).classList.add('active');
        });
    });

    // Set the default active tab
    appContent.querySelector(`.tab-link[data-tab="${defaultTab}"]`)?.click();

    // Render competitions in the log tab
    const detailsTabContent = document.getElementById('tab-details');
    const logTabContent = document.getElementById('tab-log');
    const agentCompetitionsContent = document.getElementById('tab-agent-competitions'); // This will be migrated later
    const analyticsTabContent = document.getElementById('tab-analytics');

    // --- NEW: Render tab content based on permissions ---
    if (detailsTabContent) {
        if (!canViewFinancials) {
            detailsTabContent.innerHTML = `
                <div class="access-denied-container">
                    <i class="fas fa-lock"></i>
                    <h2>Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© ÙˆØµÙˆÙ„</h2>
                    <p>Ø£Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ø¹Ø±Ø¶ Ø§Ù„ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø§Ù„ÙŠØ© Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„.</p>
                </div>`;
        } else {
            renderDetailsView(agent);
            // Removed renderBalanceHistoryChart from here as it is now in Analytics tab
        }
    }

    if (logTabContent) {
        if (agentLogs && agentLogs.length > 0) {
            const { html, initFunction } = generateAgentActivityLogHTML(agentLogs);
            logTabContent.innerHTML = html;
            // Execute initialization function after HTML is inserted
            setTimeout(() => initFunction(), 0);
        } else {
            logTabContent.innerHTML = '<h2>Ø³Ø¬Ù„ Ø§Ù„Ù†Ø´Ø§Ø·</h2><p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ø³Ø¬Ù„Ø§Øª Ø­Ø§Ù„ÙŠØ§Ù‹ Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„.</p>';
        }
    }
    // This will be migrated later
    if (analyticsTabContent && (isSuperAdmin || isAdmin)) {
        // --- FIX: Check if agent exists before rendering analytics ---
        if (agent && agent._id) {
            renderAgentAnalytics(agent, analyticsTabContent);
        } else {
            analyticsTabContent.innerHTML = '<p class="error">Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„ ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©.</p>';
        }
    }
    if (agentCompetitionsContent) {
        if (agentCompetitions && agentCompetitions.length > 0) {
            if (!canViewAgentComps) {
                agentCompetitionsContent.innerHTML = `
                    <div class="access-denied-container"> 
                        <i class="fas fa-lock"></i>
                        <h2>Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© ÙˆØµÙˆÙ„</h2>
                        <p>Ø£Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ø¹Ø±Ø¶ Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„.</p>
                    </div>`;
                // Stop further processing for this tab
                startCompetitionCountdowns(); // Still need to start other timers
                return;
            }
            const activeAndPendingCompetitions = agentCompetitions.filter(c => c.status !== 'completed');
            const completedCompetitions = agentCompetitions.filter(c => c.status === 'completed' || c.status === 'archived'); // Defensive: include archived

            const renderCompetitionList = (competitions) => {
                return competitions.map(comp => {
                    const endDate = comp.ends_at ? new Date(comp.ends_at) : null;
                    let countdownHtml = '';
                    if (endDate && comp.status !== 'completed' && comp.status !== 'awaiting_winners') {
                        const diffTime = endDate.getTime() - new Date().getTime();
                        if (diffTime > 0) {
                            countdownHtml = `<div class="competition-countdown" data-end-date="${comp.ends_at}"><i class="fas fa-hourglass-half"></i> <span>Ø¬Ø§Ø±ÙŠ Ø­Ø³Ø§Ø¨ Ø§Ù„ÙˆÙ‚Øª...</span></div>`;
                        } else {
                            countdownHtml = `<div class="competition-countdown expired"><i class="fas fa-hourglass-end"></i> ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...</div>`;
                        }
                    }

                    const statusSteps = {
                        'sent': { text: 'ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„', step: 1, icon: 'fa-paper-plane' },
                        'awaiting_winners': { text: 'ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†', step: 2, icon: 'fa-user-clock' },
                        'completed': { text: 'Ù…ÙƒØªÙ…Ù„Ø©', step: 3, icon: 'fa-check-double' }
                    };
                    const currentStatus = statusSteps[comp.status] || statusSteps['sent'];

                    const progressBarHtml = `
                        <div class="stepper-wrapper step-${currentStatus.step}">
                            ${Object.values(statusSteps).map((s, index) => {
                                const isLineCompleted = currentStatus.step > index + 1; // Line is complete if the next step is reached
                                return `
                                <div class="stepper-item ${currentStatus.step >= s.step ? 'completed' : ''}" title="${s.text}">
                                    <div class="step-counter">
                                        ${currentStatus.step > s.step ? '<i class="fas fa-check"></i>' : s.step}
                                    </div>
                                    <div class="step-name">${s.text}</div>
                                </div>
                                ${index < Object.values(statusSteps).length - 1 ? `<div class="stepper-line ${isLineCompleted ? 'completed' : ''}"></div>` : ''}
                            `}).join('')}
                        </div>
                    `;

                    return `
                    <div class="competition-card">
                        <div class="competition-card-header">
                            <h3>${comp.name}</h3>
                            <div class="header-right-content">
                                ${countdownHtml}
                                <span class="status-badge-v2 status-${comp.status}">${currentStatus.text}</span>
                            </div>
                        </div>
                        <div class="competition-card-body">
                            <div class="competition-status-tracker">${progressBarHtml}</div>
                            <div class="competition-details-grid">
                                <p class="competition-detail-item"><i class="fas fa-users"></i><strong>Ø¹Ø¯Ø¯ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†:</strong> ${comp.winners_count || 0}</p>
                                <p class="competition-detail-item"><i class="fas fa-dollar-sign"></i><strong>Ø§Ù„Ø¬Ø§Ø¦Ø²Ø© Ù„Ù„ÙØ§Ø¦Ø²:</strong> ${comp.prize_per_winner ? comp.prize_per_winner.toFixed(2) : '0.00'}</p>
                                <!-- NEW: Display both expected and actual winner selection dates -->
                                <p class="competition-detail-item"><i class="fas fa-calendar-alt"></i><strong>ØªØ§Ø±ÙŠØ® Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø²:</strong> ${comp.ends_at ? new Date(comp.ends_at).toLocaleDateString('ar-EG', { dateStyle: 'medium' }) : '<em>ØºÙŠØ± Ù…Ø­Ø¯Ø¯</em>'}</p>
                                ${comp.processed_at ? `
                                    <p class="competition-detail-item"><i class="fas fa-calendar-check"></i><strong>ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙØ¹Ù„ÙŠ:</strong> ${new Date(comp.processed_at).toLocaleString('ar-EG', { dateStyle: 'medium', timeStyle: 'short' })}</p>
                                ` : ''}
                                <p class="competition-detail-item"><i class="fas fa-eye"></i><strong>Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª:</strong> ${formatNumber(comp.views_count)}</p>
                                <p class="competition-detail-item"><i class="fas fa-heart"></i><strong>Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª:</strong> ${formatNumber(comp.reactions_count)}</p>
                                <p class="competition-detail-item"><i class="fas fa-user-check"></i><strong>Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª:</strong> ${formatNumber(comp.participants_count)}</p>
                                <p class="competition-detail-item"><i class="fas fa-gift"></i><strong>Ø¹Ø¯Ø¯ ÙØ§Ø¦Ø²ÙŠÙ† Ø¨ÙˆÙ†Øµ Ø§Ù„Ø¥ÙŠØ¯Ø§Ø¹:</strong> ${comp.deposit_winners_count || 0}</p>
                                <p class="competition-detail-item"><i class="fas fa-percent"></i><strong>Ù†Ø³Ø¨Ø© Ø¨ÙˆÙ†Øµ Ø§Ù„Ø¥ÙŠØ¯Ø§Ø¹:</strong> ${typeof comp.deposit_bonus_percentage === 'number' ? `${comp.deposit_bonus_percentage}%` : '-'}</p>
                                <p class="competition-detail-item"><i class="fas fa-key"></i><strong>Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©:</strong> ${comp.correct_answer || '<em>ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø©</em>'}</p>
                            </div>
                        </div>
                        <div class="competition-card-footer">
                            ${comp.status === 'awaiting_winners' ? `<button class="btn-primary complete-competition-btn" data-id="${comp.id}" data-name="${comp.name}"><i class="fas fa-check-double"></i> ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†</button>` : ''}
                            ${canEditComps ? `<button class="btn-danger delete-competition-btn" data-id="${comp._id}"><i class="fas fa-trash-alt"></i> Ø­Ø°Ù</button>` : ''}
                        </div>
                    </div>
                `}).join('');
            };

            agentCompetitionsContent.innerHTML = `
                <div class="competitions-list-profile">
                    ${renderCompetitionList(activeAndPendingCompetitions)}
                </div>
                ${completedCompetitions.length > 0 ? `
                    <details class="completed-competitions-group">
                        <summary>
                            <i class="fas fa-archive"></i> Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø© (${completedCompetitions.length})
                        </summary>
                        <div class="competitions-list-profile">
                            ${renderCompetitionList(completedCompetitions)}
                        </div>
                    </details>
                ` : ''}
            `;
        } else {
            if (canViewAgentComps) {
                agentCompetitionsContent.innerHTML = '<p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø®Ø§ØµØ© Ø¨Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„ Ø¨Ø¹Ø¯.</p>';
            }
        }
    }

    if (agentCompetitionsContent) {
        agentCompetitionsContent.addEventListener('click', async (e) => {
            const deleteBtn = e.target.closest('.delete-competition-btn');
            const completeBtn = e.target.closest('.complete-competition-btn');

            if (completeBtn) {
                const id = completeBtn.dataset.id;
                const name = completeBtn.dataset.name;

                // --- NEW: Show modal with required fields before completing ---
                const modalContent = `
                    <p>Ù„Ø¥ÙƒÙ…Ø§Ù„ Ù…Ø³Ø§Ø¨Ù‚Ø© "<strong>${name}</strong>"ØŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:</p>
                    <div class="form-layout" style="margin-top: 15px;">
                        <div class="form-group">
                            <label for="comp-views-count">Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª</label>
                            <input type="number" id="comp-views-count" class="modal-input" required min="0">
                        </div>
                        <div class="form-group">
                            <label for="comp-reactions-count">Ø¹Ø¯Ø¯ Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª</label>
                            <input type="number" id="comp-reactions-count" class="modal-input" required min="0">
                        </div>
                        <div class="form-group">
                            <label for="comp-participants-count">Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª</label>
                            <input type="number" id="comp-participants-count" class="modal-input" required min="0">
                        </div>
                    </div>
                `;

                showConfirmationModal(
                    modalContent,
                    async () => {
                        const views = document.getElementById('comp-views-count').value;
                        const reactions = document.getElementById('comp-reactions-count').value;
                        const participants = document.getElementById('comp-participants-count').value;

                        const parsedViews = Number(views);
                        const parsedReactions = Number(reactions);
                        const parsedParticipants = Number(participants);

                        const updateData = {
                            status: 'completed',
                            is_active: false,
                            // Ensure numeric values are valid non-negative integers
                            views_count: Number.isFinite(parsedViews) && parsedViews >= 0 ? parsedViews : 0,
                            reactions_count: Number.isFinite(parsedReactions) && parsedReactions >= 0 ? parsedReactions : 0,
                            participants_count: Number.isFinite(parsedParticipants) && parsedParticipants >= 0 ? parsedParticipants : 0,
                            // Record processing timestamp for analytics and auditing
                            processed_at: new Date().toISOString()
                        };

                        const response = await authedFetch(`/api/competitions/${id}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json;charset=UTF-8' },
                            body: JSON.stringify(updateData)
                        });

                        if (!response.ok) {
                            let serverMsg = 'ÙØ´Ù„ Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©.';
                            try {
                                const txt = await response.text();
                                serverMsg = (JSON.parse(txt).message) || serverMsg;
                            } catch (_) {}
                            showToast(serverMsg, 'error');
                        } else {
                            showToast('ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                            // --- FIX: Add correct logging for competition completion ---
                            await logAgentActivity(currentUserProfile?._id, agent._id, 'COMPETITION_COMPLETED', `ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ù…Ø³Ø§Ø¨Ù‚Ø© "${name}" ÙˆØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø£Ø¯Ø§Ø¡.`, {
                                completed_by: currentUserProfile?.full_name,
                                performance: updateData
                            });
                            renderAgentProfilePage(agent._id, { activeTab: 'agent-competitions' });
                        }
                    }, {
                        title: 'Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© ÙˆØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø£Ø¯Ø§Ø¡',
                        confirmText: 'Ù†Ø¹Ù…ØŒ Ø§ÙƒØªÙ…Ù„Øª',
                        confirmClass: 'btn-primary',
                        onRender: (modal) => {
                            const confirmBtn = modal.querySelector('#confirm-btn');
                            const inputs = modal.querySelectorAll('.modal-input');
                            confirmBtn.disabled = true; // Disable by default

                            inputs.forEach(input => input.addEventListener('input', () => {
                                const allFilled = Array.from(inputs).every(i => i.value.trim() !== '' && parseInt(i.value, 10) >= 0 && i.value !== '');
                                confirmBtn.disabled = !allFilled;
                            }));
                        }
                    }
                );
                return; // Stop further execution
            }

            if (deleteBtn) {
                const id = deleteBtn.dataset.id;
                if (!id) return;
        
                showConfirmationModal(
                    'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©ØŸ<br><small>Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡.</small>',
                    async () => {
                        const response = await authedFetch(`/api/competitions/${id}`, { method: 'DELETE' });
                        if (!response.ok) {
                            const result = await response.json();
                            showToast(result.message || 'ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©.', 'error');
                            return;
                        }
                        showToast('ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                        // --- FIX: Add correct logging for competition deletion ---
                        await logAgentActivity(currentUserProfile?._id, agent._id, 'COMPETITION_DELETED', `ØªÙ… Ø­Ø°Ù Ù…Ø³Ø§Ø¨Ù‚Ø© Ù…Ù† Ø³Ø¬Ù„ Ø§Ù„ÙˆÙƒÙŠÙ„.`, {
                            deleted_by: currentUserProfile?.full_name
                        });
                        renderAgentProfilePage(agent._id, { activeTab: 'agent-competitions' });
                    }, {
                        title: 'ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù',
                        confirmText: 'Ø­Ø°Ù',
                        confirmClass: 'btn-danger'
                    });
            }
        });
    }

    // Start live countdowns for competitions
    startCompetitionCountdowns(); // This will be migrated later

    // Display the next renewal date, which is now fully independent
    displayNextRenewalDate(agent); // This will be migrated later
}

/**
 * NEW: Renders an editor for the main profile header fields.
 * @param {object} agent The agent object to edit.
 */
function renderEditProfileHeader(agent) {
    // Defensive: Check for required permissions
    const canEditProfile = currentUserProfile?.role === 'super_admin' || currentUserProfile?.role === 'admin';
    if (!canEditProfile) {
        showToast('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„ØªØ¹Ø¯ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„.', 'error');
        return;
    }

    const headerContainer = document.querySelector('.profile-main-info');
    // CHANGED: Select the new actions row
    const actionsContainer = document.querySelector('.profile-header-actions-row');
    
    if (!headerContainer || !actionsContainer) return;

    // --- ØªØ¹Ø¯ÙŠÙ„: Ø¥Ø¶Ø§ÙØ© Ù…Ø­Ø¯Ø¯ Ø£ÙŠØ§Ù… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ ---
    const dayNames = ['Ø§Ù„Ø£Ø­Ø¯', 'Ø§Ù„Ø§Ø«Ù†ÙŠÙ†', 'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡', 'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡', 'Ø§Ù„Ø®Ù…ÙŠØ³', 'Ø§Ù„Ø¬Ù…Ø¹Ø©'];
    const auditDaysEditorHtml = `
        <div class="form-group" style="grid-column: 1 / -1; margin-top: 10px;"> 
            <label style="margin-bottom: 10px;">Ø£ÙŠØ§Ù… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚</label>
            <div class="days-selector-v2" id="header-edit-audit-days">
                ${dayNames.map((day, index) => `
                    <div class="day-toggle-wrapper">
                        <input type="checkbox" id="day-header-edit-${index}" value="${index}" class="day-toggle-input" ${(agent.audit_days || []).includes(index) ? 'checked' : ''}>
                        <label for="day-header-edit-${index}" class="day-toggle-btn">${day}</label>
                    </div>`).join('')}
            </div>
        </div>
    `;

    headerContainer.innerHTML = `
        <div class="form-layout-grid" style="gap: 10px;">
            <div class="form-group" style="grid-column: 1 / span 2;"><label>Ø§Ø³Ù… Ø§Ù„ÙˆÙƒÙŠÙ„</label><input type="text" id="header-edit-name" value="${agent.name || ''}"></div>
            <div class="form-group">
                <label>Ø§Ù„ØªØµÙ†ÙŠÙ</label>
                <select id="header-edit-classification">
                    <option value="R" ${agent.classification === 'R' ? 'selected' : ''}>R</option>
                    <option value="A" ${agent.classification === 'A' ? 'selected' : ''}>A</option>
                    <option value="B" ${agent.classification === 'B' ? 'selected' : ''}>B</option>
                    <option value="C" ${agent.classification === 'C' ? 'selected' : ''}>C</option>
                </select>
            </div>
            <div class="form-group"><label>Ù…Ø¹Ø±Ù Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©</label><input type="text" id="header-edit-chatid" value="${agent.telegram_chat_id || ''}"></div>
            <div class="form-group"><label>Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©</label><input type="text" id="header-edit-groupname" value="${agent.telegram_group_name || ''}"></div>
            <div class="form-group" style="grid-column: 1 / -1;"><label>Ø±Ø§Ø¨Ø· Ø§Ù„Ù‚Ù†Ø§Ø©</label><input type="text" id="header-edit-channel" value="${agent.telegram_channel_url || ''}"></div>
            <div class="form-group" style="grid-column: 1 / -1;"><label>Ø±Ø§Ø¨Ø· Ø§Ù„Ø¬Ø±ÙˆØ¨</label><input type="text" id="header-edit-group" value="${agent.telegram_group_url || ''}"></div>
            ${auditDaysEditorHtml}
        </div>
        <div class="profile-header-actions-row" style="justify-content: flex-end; margin-top: 20px;">
            <button id="header-save-btn" class="btn-primary"><i class="fas fa-check"></i> Ø­ÙØ¸</button>
            <button id="header-cancel-btn" class="btn-secondary"><i class="fas fa-times"></i> Ø¥Ù„ØºØ§Ø¡</button>
        </div>
    `;

    const saveBtn = document.getElementById('header-save-btn');
    const cancelBtn = document.getElementById('header-cancel-btn');

    cancelBtn.addEventListener('click', () => {
        // Re-render the page to restore original state and listeners
        renderAgentProfilePage(agent._id);
    });

    saveBtn.addEventListener('click', async () => {
        console.log('ğŸš€ [SAVE BUTTON] Clicked! Starting save process...');
        
        saveBtn.disabled = true;
        saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

        // --- ØªØ¹Ø¯ÙŠÙ„: Ù‚Ø±Ø§Ø¡Ø© Ø£ÙŠØ§Ù… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© ---
        const selectedDays = Array.from(document.querySelectorAll('#header-edit-audit-days .day-toggle-input:checked')).map(input => parseInt(input.value, 10));

        const newClassification = document.getElementById('header-edit-classification').value;
        const oldClassification = agent.classification;

        // Check if classification changed
        if (newClassification !== oldClassification) {
            // Show classification change modal
            showClassificationChangeModal(agent, newClassification, async (reason, action) => {
                
                // --- ØªØ­Ø¯ÙŠØ«: ØªØ­Ø¯ÙŠØ« competitions_per_week ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØªØµÙ†ÙŠÙ Ø§Ù„Ø¬Ø¯ÙŠØ¯ ---
                let competitionsPerWeek = agent.competitions_per_week || 1; // Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
                if (newClassification === 'R' || newClassification === 'A') {
                    competitionsPerWeek = 2;
                } else if (newClassification === 'B' || newClassification === 'C') {
                    competitionsPerWeek = 1;
                }
                
                const updatedData = {
                    name: document.getElementById('header-edit-name').value,
                    telegram_channel_url: document.getElementById('header-edit-channel').value,
                    telegram_group_url: document.getElementById('header-edit-group').value,
                    telegram_chat_id: document.getElementById('header-edit-chatid').value,
                    telegram_group_name: document.getElementById('header-edit-groupname').value,
                    classification: newClassification,
                    competitions_per_week: competitionsPerWeek, // ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©
                    audit_days: selectedDays
                };

                try {
                    const response = await authedFetch(`/api/agents/${agent._id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(updatedData)
                    });

                    if (!response.ok) {
                        const result = await response.json();
                        throw new Error(result.message || 'ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.');
                    }

                    // Record classification change
                    const classificationChangeResponse = await authedFetch(`/api/agents/${agent._id}/classification-change`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            old_classification: oldClassification,
                            new_classification: newClassification,
                            reason: reason,
                            action_taken: action
                        })
                    });

                    if (!classificationChangeResponse.ok) {
                        console.error('Failed to record classification change:', await classificationChangeResponse.text());
                    }

                    showToast('ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØµÙ†ÙŠÙ ÙˆØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø³Ø¨Ø¨ ÙˆØ§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                    renderAgentProfilePage(agent._id);

                } catch (error) {
                    showToast(`ÙØ´Ù„ Ø§Ù„Ø­ÙØ¸: ${error.message}`, 'error');
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = '<i class="fas fa-check"></i> Ø­ÙØ¸';
                }
            }, () => {
                // On cancel, re-enable save button
                saveBtn.disabled = false;
                saveBtn.innerHTML = '<i class="fas fa-check"></i> Ø­ÙØ¸';
            });
            
            return; // IMPORTANT: Stop here and wait for modal
        }

        // Normal save flow (no classification change)
        const updatedData = {
            name: document.getElementById('header-edit-name').value,
            telegram_channel_url: document.getElementById('header-edit-channel').value,
            telegram_group_url: document.getElementById('header-edit-group').value,
            telegram_chat_id: document.getElementById('header-edit-chatid').value,
            telegram_group_name: document.getElementById('header-edit-groupname').value,
            classification: newClassification,
            audit_days: selectedDays
        };

        try {
            const response = await authedFetch(`/api/agents/${agent._id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(updatedData)
            });

            if (!response.ok) {
                const result = await response.json();
                throw new Error(result.message || 'ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.');
            }

            showToast('ØªÙ… ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
            renderAgentProfilePage(agent._id);

        } catch (error) {
            showToast(`ÙØ´Ù„ Ø§Ù„Ø­ÙØ¸: ${error.message}`, 'error');
            saveBtn.disabled = false;
            saveBtn.innerHTML = '<i class="fas fa-check"></i> Ø­ÙØ¸';
        }
    });
}


function startCompetitionCountdowns() {
    const countdownElements = document.querySelectorAll('.competition-countdown, .competition-countdown-header');
    if (countdownElements.length === 0) return;

    stopCompetitionCountdowns(); // Clear any existing intervals before starting new ones

    const updateElements = () => {
        let activeTimers = false;
        countdownElements.forEach(el => {
            if (!document.body.contains(el)) return;

            const endDateStr = el.dataset.endDate;
            if (!endDateStr) {
                el.innerHTML = ''; // Clear if no date
                return;
            }

            const endDate = new Date(endDateStr);
            const diffTime = endDate.getTime() - Date.now();

            if (diffTime <= 0) {
                el.innerHTML = `<i class="fas fa-hourglass-end"></i> <span>ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...</span>`;
                el.classList.add('expired');
            } else {
                activeTimers = true;
                const days = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                let daysText = '';
                if (days > 1) {
                    daysText = `${days} Ø£ÙŠØ§Ù…`;
                } else if (days === 1) {
                    daysText = `ÙŠÙˆÙ… ÙˆØ§Ø­Ø¯`;
                } else { // Fallback for less than a day
                    daysText = 'Ø£Ù‚Ù„ Ù…Ù† ÙŠÙˆÙ…';
                }
                el.innerHTML = `<i class="fas fa-hourglass-half"></i> <span>Ù…ØªØ¨Ù‚ÙŠ: ${daysText}</span>`;
            }
        });
        if (!activeTimers) stopCompetitionCountdowns();
    };

    updateElements();
    const intervalId = setInterval(updateElements, 1000);
    competitionCountdownIntervals.push(intervalId);
}

/**
 * Generates an advanced activity log table with filtering, sorting, pagination, and statistics.
 * @param {Array} logs - The array of log objects for the agent.
 * @returns {Object} Object containing html string and initialization function
 */
function generateAgentActivityLogHTML(logs) {
    const getLogIconDetails = (actionType) => {
        if (actionType.includes('CREATED')) return { icon: 'fa-user-plus', colorClass: 'icon-create', label: 'Ø¥Ù†Ø´Ø§Ø¡', type: 'CREATE', bgColor: '#10b981' };
        if (actionType.includes('DELETED')) return { icon: 'fa-user-slash', colorClass: 'icon-delete', label: 'Ø­Ø°Ù', type: 'DELETE', bgColor: '#ef4444' };
        if (actionType.includes('PROFILE_UPDATE') || actionType.includes('UPDATED')) return { icon: 'fa-user-edit', colorClass: 'icon-update', label: 'ØªØ­Ø¯ÙŠØ«', type: 'UPDATE', bgColor: '#3b82f6' };
        if (actionType.includes('MANUAL_RENEWAL') || actionType.includes('RENEWAL')) return { icon: 'fa-sync-alt', colorClass: 'icon-renewal', label: 'ØªØ¬Ø¯ÙŠØ¯', type: 'RENEWAL', bgColor: '#8b5cf6' };
        if (actionType.includes('DETAILS_UPDATE')) return { icon: 'fa-cogs', colorClass: 'icon-details', label: 'ØªØ¹Ø¯ÙŠÙ„ ØªÙØ§ØµÙŠÙ„', type: 'DETAILS', bgColor: '#f59e0b' };
        if (actionType.includes('COMPETITION')) return { icon: 'fa-trophy', colorClass: 'icon-competition', label: 'Ù…Ø³Ø§Ø¨Ù‚Ø©', type: 'COMPETITION', bgColor: '#f97316' };
        if (actionType.includes('RANK_CHANGE')) return { icon: 'fa-layer-group', colorClass: 'icon-rank', label: 'ØªØºÙŠÙŠØ± Ù…Ø±ØªØ¨Ø©', type: 'RANK', bgColor: '#ec4899' };
        if (actionType.includes('TELEGRAM') || actionType.includes('WINNERS_SELECTION')) return { icon: 'fa-paper-plane', colorClass: 'icon-telegram', label: 'ØªÙ„Ø¬Ø±Ø§Ù…', type: 'TELEGRAM', bgColor: '#06b6d4' };
        if (actionType.includes('VIEWED') || actionType.includes('VIEW')) return { icon: 'fa-eye', colorClass: 'icon-view', label: 'Ù…Ø´Ø§Ù‡Ø¯Ø©', type: 'VIEW', bgColor: '#64748b' };
        return { icon: 'fa-history', colorClass: 'icon-generic', label: 'Ù†Ø´Ø§Ø·', type: 'OTHER', bgColor: '#6b7280' };
    };

    // Generate unique ID for this log instance
    const logId = `activity-log-${Date.now()}`;

    // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø³Ø±ÙŠØ¹Ø© Ù„Ù„Ø£Ù†Ø´Ø·Ø©
    const stats = logs.reduce((acc, log) => {
        const type = getLogIconDetails(log.action_type).type;
        acc[type] = (acc[type] || 0) + 1;
        return acc;
    }, {});

    const totalActivities = logs.length;
    const recentActivities = logs.filter(log => (Date.now() - new Date(log.createdAt).getTime()) < 24 * 60 * 60 * 1000).length;

    const html = `
        <div class="activity-log-header" style="background:linear-gradient(135deg, #1e293b 0%, #334155 100%);border:1px solid #475569;border-radius:12px;padding:20px;margin-bottom:20px;">
            <div style="display:flex;align-items:center;gap:15px;margin-bottom:15px;">
                <div style="width:50px;height:50px;background:linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);border-radius:12px;display:flex;align-items:center;justify-content:center;">
                    <i class="fas fa-history" style="color:#fff;font-size:22px;"></i>
                </div>
                <div>
                    <h3 style="margin:0;color:#fff;font-size:20px;font-weight:600;">Ø³Ø¬Ù„ Ø§Ù„Ø£Ù†Ø´Ø·Ø© ÙˆØ§Ù„Ø¹Ù…Ù„ÙŠØ§Øª</h3>
                    <p style="margin:5px 0 0;color:#94a3b8;font-size:14px;">ØªØªØ¨Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª ÙˆØ§Ù„ØªØºÙŠÙŠØ±Ø§Øª Ø¹Ù„Ù‰ Ø­Ø³Ø§Ø¨ Ø§Ù„ÙˆÙƒÙŠÙ„</p>
                </div>
            </div>

            <div class="activity-stats" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:12px;">
                <div class="stat-item" style="background:#0f172a;border:1px solid #334155;border-radius:8px;padding:12px;text-align:center;">
                    <div style="font-size:20px;font-weight:700;color:#3b82f6;margin-bottom:4px;">${totalActivities}</div>
                    <div style="font-size:12px;color:#94a3b8;">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø£Ù†Ø´Ø·Ø©</div>
                </div>
                <div class="stat-item" style="background:#0f172a;border:1px solid #334155;border-radius:8px;padding:12px;text-align:center;">
                    <div style="font-size:20px;font-weight:700;color:#10b981;margin-bottom:4px;">${recentActivities}</div>
                    <div style="font-size:12px;color:#94a3b8;">Ø¢Ø®Ø± 24 Ø³Ø§Ø¹Ø©</div>
                </div>
                <div class="stat-item" style="background:#0f172a;border:1px solid #334155;border-radius:8px;padding:12px;text-align:center;">
                    <div style="font-size:20px;font-weight:700;color:#f59e0b;margin-bottom:4px;">${stats.UPDATE || 0}</div>
                    <div style="font-size:12px;color:#94a3b8;">Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª</div>
                </div>
                <div class="stat-item" style="background:#0f172a;border:1px solid #334155;border-radius:8px;padding:12px;text-align:center;">
                    <div style="font-size:20px;font-weight:700;color:#8b5cf6;margin-bottom:4px;">${stats.COMPETITION || 0}</div>
                    <div style="font-size:12px;color:#94a3b8;">Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª</div>
                </div>
            </div>
        </div>

        <div class="activity-log-table-container" id="${logId}-container" style="background:#0f172a;border:1px solid #334155;border-radius:12px;padding:20px;margin-bottom:20px;"></div>

        <div class="activity-log-pagination" id="${logId}-pagination" style="display:flex;justify-content:center;gap:10px;padding:15px;"></div>
    `;

    // Initialization function that will be called after HTML is inserted
    const initFunction = () => {
        let currentPage = 1;
        const itemsPerPage = 15;

        function groupLogsByDate(arr) {
            const groups = {};
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            const todayStr = today.toISOString().split('T')[0];
            const yesterdayStr = yesterday.toISOString().split('T')[0];

            arr.forEach(log => {
                try {
                    if (!log.createdAt) return;
                    const logDate = new Date(log.createdAt);
                    if (isNaN(logDate.getTime())) return;
                    const logDateStr = logDate.toISOString().split('T')[0];
                    let dateKey;
                    if (logDateStr === todayStr) dateKey = 'ğŸ“… Ø§Ù„ÙŠÙˆÙ…';
                    else if (logDateStr === yesterdayStr) dateKey = 'ğŸ“… Ø§Ù„Ø£Ù…Ø³';
                    else dateKey = `ğŸ“… ${logDate.toLocaleDateString('ar-EG', { year: 'numeric', month: 'long', day: 'numeric' })}`;
                    if (!groups[dateKey]) groups[dateKey] = [];
                    groups[dateKey].push(log);
                } catch (error) {
                    console.error('Error processing log:', error);
                }
            });
            return groups;
        }

        function renderTable() {
            const container = document.getElementById(logId + '-container');
            if (!container) return;

            // Always sort by newest first
            const sorted = [...logs].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageLogs = sorted.slice(startIndex, endIndex);
            const groupedLogs = groupLogsByDate(pageLogs);

            let tableHtml = '';

            if (Object.keys(groupedLogs).length === 0) {
                tableHtml = `
                    <div class="no-logs-message" style="text-align:center;padding:60px 20px;color:#64748b;">
                        <div style="font-size:48px;margin-bottom:15px;">ğŸ“‹</div>
                        <h4 style="margin:0 0 10px;color:#94a3b8;">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø³Ø¬Ù„Ø§Øª Ù†Ø´Ø§Ø·</h4>
                        <p style="margin:0;font-size:14px;">Ù„Ù… ÙŠØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø£ÙŠ Ø£Ù†Ø´Ø·Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„ Ø¨Ø¹Ø¯</p>
                    </div>`;
            } else {
                for (const date in groupedLogs) {
                    tableHtml += `
                        <div class="log-date-group" style="margin-bottom:25px;">
                            <div class="log-date-header" style="background:linear-gradient(135deg, #374151 0%, #4b5563 100%);color:#fff;padding:12px 20px;border-radius:8px;margin-bottom:15px;font-weight:600;font-size:16px;display:flex;align-items:center;gap:10px;">
                                <span>${date}</span>
                                <span style="background:#6b7280;color:#fff;padding:2px 8px;border-radius:12px;font-size:12px;font-weight:500;">${groupedLogs[date].length} Ù†Ø´Ø§Ø·</span>
                            </div>

                            <div class="activity-cards" style="display:grid;gap:12px;">`;

                    groupedLogs[date].forEach((log) => {
                        const iconDetails = getLogIconDetails(log.action_type);
                        const fullTime = new Date(log.createdAt).toLocaleString('ar-EG', {
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        });
                        const relativeTime = getRelativeTime(new Date(log.createdAt));
                        const isRecent = (Date.now() - new Date(log.createdAt).getTime()) < 5 * 60 * 1000;

                        // ØªØ­Ø³ÙŠÙ† Ø¹Ø±Ø¶ Ø§Ù„ÙˆØµÙ
                        const rawDesc = log.description || '';
                        const cleanDesc = rawDesc.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" rel="noopener" style="color:#3b82f6;text-decoration:underline;">Ø±Ø§Ø¨Ø·</a>');
                        const maxLen = 150;
                        const isLong = cleanDesc.length > maxLen;
                        const shortText = isLong ? cleanDesc.slice(0, maxLen) + '...' : cleanDesc;

                        tableHtml += `
                            <div class="activity-card ${isRecent ? 'activity-recent' : ''}" style="background:linear-gradient(135deg, #1e293b 0%, #334155 100%);border:1px solid #475569;border-radius:12px;padding:20px;position:relative;overflow:hidden;">
                                ${isRecent ? '<div class="recent-indicator" style="position:absolute;top:0;left:0;width:4px;height:100%;background:linear-gradient(to bottom, #10b981, #059669);"></div>' : ''}

                                <div class="activity-header" style="display:flex;align-items:center;gap:15px;margin-bottom:15px;">
                                    <div class="activity-icon" style="width:45px;height:45px;border-radius:10px;display:flex;align-items:center;justify-content:center;background:${iconDetails.bgColor};color:#fff;font-size:18px;">
                                        <i class="fas ${iconDetails.icon}"></i>
                                    </div>
                                    <div style="flex:1;">
                                        <div class="activity-type" style="font-weight:600;color:#fff;font-size:16px;margin-bottom:2px;">${iconDetails.label}</div>
                                        <div class="activity-meta" style="display:flex;gap:15px;font-size:13px;color:#94a3b8;">
                                            <span><i class="fas fa-user"></i> ${log.user_name || 'Ø§Ù„Ù†Ø¸Ø§Ù…'}</span>
                                            <span><i class="fas fa-clock"></i> ${fullTime}</span>
                                            <span style="color:#64748b;">${relativeTime}</span>
                                        </div>
                                    </div>
                                    <button class="activity-details-btn" data-log='${JSON.stringify(log)}' style="background:#374151;border:1px solid #4b5563;color:#e2e8f0;padding:8px 12px;border-radius:6px;font-size:12px;cursor:pointer;transition:all 0.2s;" onmouseover="this.style.background='#4b5563'" onmouseout="this.style.background='#374151'">
                                        <i class="fas fa-info-circle"></i> ØªÙØ§ØµÙŠÙ„
                                    </button>
                                </div>

                                <div class="activity-description" style="color:#cbd5e1;font-size:14px;line-height:1.5;">
                                    ${shortText}
                                    ${isLong ? `<button class="desc-toggle" style="background:none;border:none;color:#3b82f6;font-size:13px;cursor:pointer;margin-left:5px;" data-full="${cleanDesc.replace(/"/g,'&quot;')}" data-short="${shortText}">Ø§Ù„Ù…Ø²ÙŠØ¯</button>` : ''}
                                </div>
                            </div>`;
                    });

                    tableHtml += `
                            </div>
                        </div>`;
                }
            }

            container.innerHTML = tableHtml;

            // Add event listeners for detail buttons
            container.querySelectorAll('.activity-details-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const log = JSON.parse(e.currentTarget.dataset.log);
                    showLogDetailsModal(log);
                });
            });

            // Toggle full/short description
            container.querySelectorAll('.desc-toggle').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const full = e.currentTarget.dataset.full;
                    const short = e.currentTarget.dataset.short;
                    const descDiv = e.currentTarget.parentElement;
                    const isExpanded = descDiv.innerHTML.includes('Ø¥Ø®ÙØ§Ø¡');

                    if (isExpanded) {
                        descDiv.innerHTML = short + ` <button class="desc-toggle" style="background:none;border:none;color:#3b82f6;font-size:13px;cursor:pointer;margin-left:5px;" data-full="${full}" data-short="${short}">Ø§Ù„Ù…Ø²ÙŠØ¯</button>`;
                    } else {
                        descDiv.innerHTML = full + ` <button class="desc-toggle" style="background:none;border:none;color:#3b82f6;font-size:13px;cursor:pointer;margin-left:5px;" data-full="${full}" data-short="${short}">Ø¥Ø®ÙØ§Ø¡</button>`;
                    }
                });
            });

            renderPagination();
        }

        function renderPagination() {
            const pagination = document.getElementById(logId + '-pagination');
            if (!pagination) return;

            const totalPages = Math.ceil(logs.length / itemsPerPage);
            if (totalPages <= 1) {
                pagination.innerHTML = '';
                return;
            }

            let paginationHtml = `
                <div class="pagination-info" style="background:#1e293b;border:1px solid #334155;border-radius:8px;padding:10px 15px;color:#94a3b8;font-size:13px;">
                    Ø¹Ø±Ø¶ ${((currentPage - 1) * itemsPerPage) + 1} - ${Math.min(currentPage * itemsPerPage, logs.length)} Ù…Ù† ${logs.length} Ù†Ø´Ø§Ø·
                </div>
                <div class="pagination-buttons" style="display:flex;gap:5px;">
                    <button class="pagination-btn" data-page="1" ${currentPage === 1 ? 'disabled' : ''} style="background:#374151;border:1px solid #4b5563;color:#e2e8f0;padding:8px 12px;border-radius:6px;font-size:13px;cursor:pointer;${currentPage === 1 ? 'opacity:0.5;cursor:not-allowed;' : ''}">
                        <i class="fas fa-angle-double-right"></i>
                    </button>
                    <button class="pagination-btn" data-page="${currentPage - 1}" ${currentPage === 1 ? 'disabled' : ''} style="background:#374151;border:1px solid #4b5563;color:#e2e8f0;padding:8px 12px;border-radius:6px;font-size:13px;cursor:pointer;${currentPage === 1 ? 'opacity:0.5;cursor:not-allowed;' : ''}">
                        <i class="fas fa-angle-right"></i>
                    </button>`;

            for (let i = Math.max(1, currentPage - 2); i <= Math.min(totalPages, currentPage + 2); i++) {
                paginationHtml += `<button class="pagination-btn ${i === currentPage ? 'active' : ''}" data-page="${i}" style="background:${i === currentPage ? 'linear-gradient(135deg, #3b82f6, #1d4ed8)' : '#374151'};border:1px solid ${i === currentPage ? '#3b82f6' : '#4b5563'};color:#fff;padding:8px 12px;border-radius:6px;font-size:13px;cursor:pointer;font-weight:${i === currentPage ? '600' : '400'};">${i}</button>`;
            }

            paginationHtml += `
                    <button class="pagination-btn" data-page="${currentPage + 1}" ${currentPage === totalPages ? 'disabled' : ''} style="background:#374151;border:1px solid #4b5563;color:#e2e8f0;padding:8px 12px;border-radius:6px;font-size:13px;cursor:pointer;${currentPage === totalPages ? 'opacity:0.5;cursor:not-allowed;' : ''}">
                        <i class="fas fa-angle-left"></i>
                    </button>
                    <button class="pagination-btn" data-page="${totalPages}" ${currentPage === totalPages ? 'disabled' : ''} style="background:#374151;border:1px solid #4b5563;color:#e2e8f0;padding:8px 12px;border-radius:6px;font-size:13px;cursor:pointer;${currentPage === totalPages ? 'opacity:0.5;cursor:not-allowed;' : ''}">
                        <i class="fas fa-angle-double-left"></i>
                    </button>
                </div>`;

            pagination.innerHTML = paginationHtml;

            // Add click handlers for pagination buttons
            pagination.querySelectorAll('.pagination-btn:not([disabled])').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const page = parseInt(e.currentTarget.dataset.page);
                    if (page && page !== currentPage) {
                        currentPage = page;
                        renderTable();
                        document.getElementById(logId + '-container').scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                });
            });
        }

        function showLogDetailsModal(log) {
            const iconDetails = getLogIconDetails(log.action_type);
            const fullTime = new Date(log.createdAt).toLocaleString('ar-EG', {
                dateStyle: 'full',
                timeStyle: 'medium'
            });

            const modalContent = `
                <div class="log-details-modal" style="background:#0f172a;border:1px solid #334155;border-radius:12px;padding:0;">
                    <div class="log-detail-header" style="background:linear-gradient(135deg, #1e293b 0%, #334155 100%);padding:20px;border-radius:12px 12px 0 0;display:flex;align-items:center;gap:15px;">
                        <div style="width:50px;height:50px;border-radius:10px;display:flex;align-items:center;justify-content:center;background:${iconDetails.bgColor};color:#fff;font-size:20px;">
                            <i class="fas ${iconDetails.icon}"></i>
                        </div>
                        <div>
                            <h3 style="margin:0;color:#fff;font-size:18px;">${iconDetails.label}</h3>
                            <p style="margin:5px 0 0;color:#94a3b8;font-size:14px;">ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©</p>
                        </div>
                    </div>
                    <div class="log-detail-body" style="padding:25px;">
                        <div class="detail-row" style="margin-bottom:20px;">
                            <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;">
                                <i class="fas fa-align-right" style="color:#3b82f6;width:16px;"></i>
                                <strong style="color:#fff;font-size:14px;">Ø§Ù„ÙˆØµÙ:</strong>
                            </div>
                            <p style="color:#cbd5e1;font-size:14px;line-height:1.6;margin:0;padding:15px;background:#1e293b;border:1px solid #334155;border-radius:8px;">${log.description}</p>
                        </div>
                        <div class="detail-row" style="margin-bottom:20px;">
                            <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;">
                                <i class="fas fa-user" style="color:#10b981;width:16px;"></i>
                                <strong style="color:#fff;font-size:14px;">Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:</strong>
                            </div>
                            <p style="color:#cbd5e1;font-size:14px;margin:0;">${log.user_name || 'Ø§Ù„Ù†Ø¸Ø§Ù…'}</p>
                        </div>
                        <div class="detail-row" style="margin-bottom:20px;">
                            <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;">
                                <i class="fas fa-clock" style="color:#f59e0b;width:16px;"></i>
                                <strong style="color:#fff;font-size:14px;">Ø§Ù„ØªØ§Ø±ÙŠØ® ÙˆØ§Ù„ÙˆÙ‚Øª:</strong>
                            </div>
                            <p style="color:#cbd5e1;font-size:14px;margin:0;">${fullTime}</p>
                        </div>
                        <div class="detail-row">
                            <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;">
                                <i class="fas fa-tag" style="color:#8b5cf6;width:16px;"></i>
                                <strong style="color:#fff;font-size:14px;">Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡:</strong>
                            </div>
                            <p style="color:#cbd5e1;font-size:14px;margin:0;">${iconDetails.label}</p>
                        </div>
                    </div>
                </div>`;

            showConfirmationModal(modalContent, null, {
                title: 'ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø³Ø¬Ù„',
                showCancel: false,
                confirmText: 'Ø¥ØºÙ„Ø§Ù‚',
                confirmClass: 'btn-secondary'
            });
        }

        // Initial render
        renderTable();
    };

    return { html, initFunction };
}

function renderDetailsView(agent) {
    // --- NEW: Permission Check ---
    const isSuperAdmin = currentUserProfile?.role === 'super_admin';
    const isAdmin = currentUserProfile?.role === 'admin';
    // Local broader edit flag used in other places â€” ensure it's defined here to avoid ReferenceError
    const canEditProfile = isSuperAdmin || isAdmin;
    // --- MODIFICATION: Allow anyone who can view financials to also edit them, as per user request. ---
    const userPerms = currentUserProfile?.permissions || {};
    const canEditFinancials = isSuperAdmin || isAdmin || userPerms.agents?.view_financials;

    const container = document.getElementById('tab-details');
    if (!container) return;

    const createFieldHTML = (label, value, fieldName, isEditable = true) => {
        const numericFields = ['competition_bonus', 'deposit_bonus_count', 'deposit_bonus_percentage', 'consumed_balance', 'remaining_balance', 'used_deposit_bonus', 'remaining_deposit_bonus', 'single_competition_balance', 'winners_count', 'prize_per_winner', 'deposit_bonus_winners_count'];
        // --- NEW: Define which fields are financial ---
        const financialFields = ['rank', 'competition_bonus', 'deposit_bonus_count', 'deposit_bonus_percentage', 'consumed_balance', 'remaining_balance', 'used_deposit_bonus', 'remaining_deposit_bonus', 'single_competition_balance', 'winners_count', 'prize_per_winner', 'renewal_period', 'deposit_bonus_winners_count'];
        const isFinancial = financialFields.includes(fieldName);

        let displayValue;
        let iconHtml = '';

        // --- ØªØ¹Ø¯ÙŠÙ„: Ø¥Ø¸Ù‡Ø§Ø± Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù„Ø£ÙŠØ§Ù… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ ÙˆÙ„Ø­Ù‚Ù„ Ø§Ù„ØªØµÙ†ÙŠÙ Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ---
        const isAuditDays = fieldName === 'audit_days';
        const isClassificationField = fieldName === 'classification';
        // Show edit icon for financial editors OR for audit_days when broader profile edit is allowed
        // Additionally, allow admins/super_admins (canEditProfile) to edit classification
        if (canEditFinancials || (isAuditDays && canEditProfile) || (isClassificationField && canEditProfile)) {
            iconHtml = `<span class="inline-edit-trigger" title="Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„"><i class="fas fa-pen"></i></span>`;
        }

        if (numericFields.includes(fieldName) || fieldName === 'competitions_per_week') {
            displayValue = (value === null || value === undefined) ? 0 : value;
            if (fieldName === 'prize_per_winner' && typeof displayValue === 'number') displayValue = parseFloat(displayValue).toFixed(2);
            if (fieldName === 'deposit_bonus_percentage') displayValue = `${displayValue}%`;
            if (fieldName === 'competition_bonus') displayValue = `$${displayValue}`;
        } else if (fieldName === 'audit_days') {
            // --- ØªØ¹Ø¯ÙŠÙ„: Ø¹Ø±Ø¶ Ø£ÙŠØ§Ù… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ ÙƒØ¹Ù„Ø§Ù…Ø§Øª (tags) ---
            const dayNames = ['Ø§Ù„Ø£Ø­Ø¯', 'Ø§Ù„Ø§Ø«Ù†ÙŠÙ†', 'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡', 'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡', 'Ø§Ù„Ø®Ù…ÙŠØ³', 'Ø§Ù„Ø¬Ù…Ø¹Ø©',];
            displayValue = (value && value.length > 0) ? value.sort().map(dayIndex => `<span class="day-tag">${dayNames[dayIndex]}</span>`).join('') : '<span class="day-tag-none">ØºÙŠØ± Ù…Ø­Ø¯Ø¯</span>';
        } else if (fieldName.includes('_date')) {
            displayValue = value ? new Date(value).toLocaleDateString('ar-EG') : 'Ù„Ù… ÙŠØ­Ø¯Ø¯';
        } else {
            displayValue = value || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
        }
        
        // --- NEW: Add special class for audit_days to span full width ---
        const extraClass = fieldName === 'audit_days' ? 'full-width-card' : '';
        
        return `
            <div class="details-card ${extraClass}" data-field="${fieldName}">
                <div class="details-card-header">
                    <span class="details-label">${label}</span>
                    ${iconHtml}
                </div>
                <div class="details-value">${displayValue}</div>
            </div>
        `;
    };

    const htmlContent = `
        <div class="details-container-v2">
            <div class="details-section-v2">
                <h3 class="details-section-title-v2"><i class="fas fa-sliders-h"></i> Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©</h3>
                <div class="details-grid-v2">
                    ${createFieldHTML('Ø§Ù„Ù…Ø±ØªØ¨Ø©', agent.rank, 'rank')}
                    ${createFieldHTML('Ø§Ù„ØªØµÙ†ÙŠÙ', agent.classification, 'classification')}
                    ${createFieldHTML('Ø¨ÙˆÙ†Øµ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª (ØªØ¯Ø§ÙˆÙ„ÙŠ)', agent.competition_bonus, 'competition_bonus')}
                    ${createFieldHTML('Ù…Ø±Ø§Øª Ø¨ÙˆÙ†Øµ Ø§Ù„Ø¥ÙŠØ¯Ø§Ø¹', agent.deposit_bonus_count, 'deposit_bonus_count')}
                    ${createFieldHTML('Ù†Ø³Ø¨Ø© Ø¨ÙˆÙ†Øµ Ø§Ù„Ø¥ÙŠØ¯Ø§Ø¹', agent.deposit_bonus_percentage, 'deposit_bonus_percentage')}
                </div>
            </div>
            
            <div class="details-section-v2">
                <h3 class="details-section-title-v2"><i class="fas fa-wallet"></i> Ø§Ù„Ø£Ø±ØµØ¯Ø©</h3>
                <div class="details-grid-v2">
                    ${createFieldHTML('Ø±ØµÙŠØ¯ Ù…Ø³ØªÙ‡Ù„Ùƒ', agent.consumed_balance, 'consumed_balance')}
                    ${createFieldHTML('Ø±ØµÙŠØ¯ Ù…ØªØ¨Ù‚ÙŠ', Math.max(0, agent.remaining_balance || 0), 'remaining_balance')}
                    ${createFieldHTML('Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹ Ù…Ø³ØªØ®Ø¯Ù…', agent.used_deposit_bonus, 'used_deposit_bonus')}
                    ${createFieldHTML('Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹ Ù…ØªØ¨Ù‚ÙŠ', Math.max(0, agent.remaining_deposit_bonus || 0), 'remaining_deposit_bonus')}
                </div>
            </div>

            <div class="details-section-v2">
                <h3 class="details-section-title-v2"><i class="fas fa-trophy"></i> Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„ÙˆØ§Ø­Ø¯Ø©</h3>
                <div class="details-grid-v2">
                    ${createFieldHTML('Ø±ØµÙŠØ¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„ÙˆØ§Ø­Ø¯Ø©', agent.single_competition_balance, 'single_competition_balance')}
                    ${createFieldHTML('Ø¹Ø¯Ø¯ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†', agent.winners_count, 'winners_count')}
                    ${createFieldHTML('Ø¬Ø§Ø¦Ø²Ø© ÙƒÙ„ ÙØ§Ø¦Ø²', agent.prize_per_winner, 'prize_per_winner')}
                    ${createFieldHTML('Ø¹Ø¯Ø¯ ÙØ§Ø¦Ø²ÙŠÙ† Ø¨ÙˆÙ†Øµ Ø§ÙŠØ¯Ø§Ø¹', agent.deposit_bonus_winners_count, 'deposit_bonus_winners_count')}
                </div>
            </div>
            
            <div class="details-section-v2">
                <h3 class="details-section-title-v2"><i class="fas fa-clock"></i> Ø§Ù„ØªØ¬Ø¯ÙŠØ¯ ÙˆØ§Ù„Ù…Ø¯Ø©</h3>
                <div class="details-grid-v2">
                    ${createFieldHTML('ÙŠØ¬Ø¯Ø¯ ÙƒÙ„', agent.renewal_period, 'renewal_period')}
                    ${createFieldHTML('Ù…Ø¯Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©', agent.competition_duration, 'competition_duration')}
                    ${createFieldHTML('Ø£ÙŠØ§Ù… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚', agent.audit_days, 'audit_days')}
                    ${createFieldHTML('ØªØ§Ø±ÙŠØ® Ø¢Ø®Ø± Ù…Ø³Ø§Ø¨Ù‚Ø©', agent.last_competition_date, 'last_competition_date')}
                    ${createFieldHTML('Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª ÙƒÙ„ Ø£Ø³Ø¨ÙˆØ¹', agent.competitions_per_week, 'competitions_per_week')}
                </div>
            </div>
        </div>
        ${isSuperAdmin ? `
            <div class="details-actions" style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
                <button id="trigger-renewal-test-btn" class="btn-danger"><i class="fas fa-history"></i> ØªØ¬Ø±Ø¨Ø© Ø§Ù„ØªØ¬Ø¯ÙŠØ¯ (3 Ø«ÙˆØ§Ù†ÙŠ)</button>
            </div>
        ` : ''}
    `;



    // --- FIX V3: Stable content update ---
    // Clear the container's content and re-add the event listener.
    // This prevents replacing the container itself, which caused content to leak across pages.
    container.innerHTML = htmlContent;
    // Debug helper: log classification to confirm render and help debug caching issues
    try { console.debug(`[Profile] renderDetailsView: agent ${agent?._id || '<no-id>'} classification=`, agent?.classification); } catch (_) {}
    const eventHandler = (e) => {
        const trigger = e.target.closest('.inline-edit-trigger'); // Defensive: Use closest to handle clicks on icon
        if (trigger) { // Permission is checked inside renderInlineEditor
            const group = trigger.closest('.details-group'); 
            // FIX: Add a null check to prevent race condition errors after a save.
            if (!group) return;
            renderInlineEditor(group, agent);
        }
    };
    
    // Defensive: Manage event listener to prevent duplicates
    container.addEventListener('click', eventHandler);
    profilePageEventListeners.push({ element: container, type: 'click', handler: eventHandler });


    // --- NEW: Add listener for the test renewal button ---
    const testRenewalBtn = document.getElementById('trigger-renewal-test-btn');
    if (testRenewalBtn) {
        testRenewalBtn.addEventListener('click', () => {
            if (testRenewalBtn.disabled) return; // Prevent double clicks
            testRenewalBtn.disabled = true;
            testRenewalBtn.innerHTML = '<i class="fas fa-hourglass-half"></i> Ø¬Ø§Ø±Ù Ø§Ù„ØªÙ†ÙÙŠØ°...';
            setTimeout(async () => {
                try {
                    const response = await authedFetch(`/api/agents/${agent._id}/renew`, { method: 'POST' });
                    const result = await response.json();
                    
                    // Normalize message for comparison
                    const msg = result && result.message ? result.message.trim() : '';
                    
                    // Fix: Check response.ok or result.message for success
                    if (response.ok || (msg && msg.includes('Agent balance renewed successfully'))) {
                        showToast('ØªÙ… ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„ÙˆÙƒÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­!', 'success');
                        renderAgentProfilePage(agent._id, { activeTab: 'details' });
                    } else {
                        throw new Error(msg || 'ÙØ´Ù„ Ø§Ù„ØªØ¬Ø¯ÙŠØ¯');
                    }
                } catch (error) {
                    console.error('Renewal test error:', error);
                    showToast(`Ø®Ø·Ø£: ${error.message}`, 'error');
                } finally {
                    if (testRenewalBtn) {
                        testRenewalBtn.disabled = false;
                        testRenewalBtn.innerHTML = '<i class="fas fa-history"></i> ØªØ¬Ø±Ø¨Ø© Ø§Ù„ØªØ¬Ø¯ÙŠØ¯ (3 Ø«ÙˆØ§Ù†ÙŠ)';
                    }
                }
            }, 3000);
        });
    }
}

function enableInlineEdit(groupElement, fieldName, agent) {
    const currentValue = agent[fieldName];
    const label = groupElement.querySelector('label').textContent;
    let editorHtml = '';

    switch (fieldName) {
        case 'rank':
            // ØªØ¹Ø¯ÙŠÙ„: ØªÙˆØ­ÙŠØ¯ Ø´ÙƒÙ„ ÙˆØªØ±ØªÙŠØ¨ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø±Ø§ØªØ¨ Ù…Ø¹ ØµÙØ­Ø© Ø§Ù„Ø¥Ø¶Ø§ÙØ©
            editorHtml = `<select id="inline-edit-input">
                <optgroup label="â• Ù…Ø±Ø§ØªØ¨ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ø§Ø¹ØªÙŠØ§Ø¯ÙŠØ© â–">
                    ${Object.keys(RANKS_DATA).filter(r => ['BEGINNING', 'GROWTH', 'PRO', 'ELITE'].includes(r)).map(rank => `<option value="${rank}" ${currentValue === rank ? 'selected' : ''}>ğŸ”¸ ${rank}</option>`).join('')}
                </optgroup>
                <optgroup label="â• Ù…Ø±Ø§ØªØ¨ Ø§Ù„ÙˆÙƒØ§Ù„Ø© Ø§Ù„Ø­ØµØ±ÙŠØ© â–">
                    <option value="ÙˆÙƒÙŠÙ„ Ø­ØµØ±ÙŠ Ø¨Ø¯ÙˆÙ† Ù…Ø±ØªØ¨Ø©" ${currentValue === 'ÙˆÙƒÙŠÙ„ Ø­ØµØ±ÙŠ Ø¨Ø¯ÙˆÙ† Ù…Ø±ØªØ¨Ø©' ? 'selected' : ''}>â­ ÙˆÙƒÙŠÙ„ Ø­ØµØ±ÙŠ Ø¨Ø¯ÙˆÙ† Ù…Ø±ØªØ¨Ø©</option>
                    <option disabled>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</option>
                    ${Object.keys(RANKS_DATA).filter(r => ['BRONZE', 'SILVER', 'GOLD', 'PLATINUM', 'DIAMOND', 'SAPPHIRE', 'EMERALD', 'KING', 'LEGEND'].includes(r)).map(rank => `<option value="${rank}" ${currentValue === rank ? 'selected' : ''}>â­ ${rank}</option>`).join('')}
                </optgroup>
                <optgroup label="â• Ø§Ù„Ù…Ø±Ø§ÙƒØ² â–">
                    <option value="CENTER" ${currentValue === 'CENTER' ? 'selected' : ''}>ğŸ¢ CENTER</option>
                </optgroup>
            </select>`;
            break;
        case 'classification':
            editorHtml = `<select id="inline-edit-input">
                <option value="R" ${currentValue === 'R' ? 'selected' : ''}>R</option>
                <option value="A" ${currentValue === 'A' ? 'selected' : ''}>A</option>
                <option value="B" ${currentValue === 'B' ? 'selected' : ''}>B</option>
                <option value="C" ${currentValue === 'C' ? 'selected' : ''}>C</option>
            </select>`;
            break;
        case 'renewal_period':
            editorHtml = `<select id="inline-edit-input">
                <option value="none" ${currentValue === 'none' ? 'selected' : ''}>Ø¨Ø¯ÙˆÙ† ØªØ¬Ø¯ÙŠØ¯</option>
                <option value="weekly" ${currentValue === 'weekly' ? 'selected' : ''}>Ø£Ø³Ø¨ÙˆØ¹</option>
                <option value="biweekly" ${currentValue === 'biweekly' ? 'selected' : ''}>Ø£Ø³Ø¨ÙˆØ¹ÙŠÙ†</option>
                <option value="monthly" ${currentValue === 'monthly' ? 'selected' : ''}>Ø´Ù‡Ø±</option>
            </select>`;
            break;
        case 'last_competition_date': // ØªØ¹Ø¯ÙŠÙ„: Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨ØªØ¹Ø¯ÙŠÙ„ ØªØ§Ø±ÙŠØ® Ø¢Ø®Ø± Ù…Ø³Ø§Ø¨Ù‚Ø©
        case 'winner_selection_date': // ØªØ¹Ø¯ÙŠÙ„: Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨ØªØ¹Ø¯ÙŠÙ„ ØªØ§Ø±ÙŠØ® Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø²
            editorHtml = `<input type="date" id="inline-edit-input" value="${currentValue || ''}">`;
            break;
        case 'competition_duration': // ØªØ¹Ø¯ÙŠÙ„: Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨ØªØ¹Ø¯ÙŠÙ„ Ù…Ø¯Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© (Ø¥Ø¶Ø§ÙØ© 5 Ø«ÙˆØ§Ù†ÙŠ Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±)
            editorHtml = `<select id="inline-edit-input">
                <optgroup label="âš¡ ØªØ¬Ø±ÙŠØ¨ÙŠ">
                    <option value="5s" ${currentValue === '5s' ? 'selected' : ''}>5 Ø«ÙˆØ§Ù†ÙŠ (Ø§Ø®ØªØ¨Ø§Ø± Ø³Ø±ÙŠØ¹)</option>
                </optgroup>
                <optgroup label="â³ Ù…Ø¯Ø© Ù‚ÙŠØ§Ø³ÙŠØ©">
                    <option value="24h" ${currentValue === '24h' ? 'selected' : ''}>24 Ø³Ø§Ø¹Ø©</option>
                    <option value="48h" ${currentValue === '48h' ? 'selected' : ''}>48 Ø³Ø§Ø¹Ø©</option>
                </optgroup>
            </select>`;
            break;
        case 'audit_days':
            editorHtml = `
                <div class="days-selector-v2" id="inline-edit-input">
                    ${['Ø§Ù„Ø£Ø­Ø¯', 'Ø§Ù„Ø§Ø«Ù†ÙŠÙ†', 'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡', 'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡', 'Ø§Ù„Ø®Ù…ÙŠØ³', 'Ø§Ù„Ø¬Ù…Ø¹Ø©'].map((day, index) => `
                        <div class="day-toggle-wrapper">
                            <input type="checkbox" id="day-edit-inline-${index}" value="${index}" class="day-toggle-input" ${(currentValue || []).includes(index) ? 'checked' : ''}>
                            <label for="day-edit-inline-${index}" class="day-toggle-btn">${day}</label>
                        </div>`).join('')}
                </div>`;
            break;
        default: // for text/number inputs
            editorHtml = `<input type="number" id="inline-edit-input" value="${currentValue || ''}" placeholder="${label}">`;
            break;
    }

    groupElement.innerHTML = `
        <label>${label}</label>
        ${editorHtml}
        <div class="inline-edit-actions">
            <button id="inline-save-btn" class="btn-primary"><i class="fas fa-check"></i></button>
            <button id="inline-cancel-btn" class="btn-secondary"><i class="fas fa-times"></i></button>
        </div>
    `;

    // --- ØªØ¹Ø¯ÙŠÙ„: Ø¥Ø¶Ø§ÙØ© ØªØ­Ø¯ÙŠØ« ÙÙˆØ±ÙŠ Ù„ØªØ§Ø±ÙŠØ® Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø² ---
    const inputElement = groupElement.querySelector('#inline-edit-input');
    if (inputElement && (fieldName === 'last_competition_date' || fieldName === 'competition_duration')) {
        const liveUpdateWinnerDate = () => {
            // --- Ø¥ØµÙ„Ø§Ø­: Ø¬Ù„Ø¨ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù…Ù† Ø§Ù„ØµÙØ­Ø© Ù…Ø¨Ø§Ø´Ø±Ø© ---
            // Ø§Ø¨Ø­Ø« Ø¹Ù† Ø­Ù‚Ù„ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†Ø´Ø· Ù„ØªØ§Ø±ÙŠØ® Ø¢Ø®Ø± Ù…Ø³Ø§Ø¨Ù‚Ø©ØŒ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø¹Ø±ÙˆØ¶Ø© Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„.
            const lastCompDateInput = document.querySelector('.details-group[data-field="last_competition_date"] #inline-edit-input');
            const lastCompDateValue = lastCompDateInput ? lastCompDateInput.value : agent.last_competition_date;

            // Ø§Ø¨Ø­Ø« Ø¹Ù† Ø­Ù‚Ù„ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†Ø´Ø· Ù„Ù…Ø¯Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©ØŒ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø¹Ø±ÙˆØ¶Ø©.
            const durationInput = document.querySelector('.details-group[data-field="competition_duration"] #inline-edit-input');
            const durationValue = durationInput ? durationInput.value : agent.competition_duration;
            
            // Ø§Ø¨Ø­Ø« Ø¹Ù† Ø¹Ù†ØµØ± Ø¹Ø±Ø¶ ØªØ§Ø±ÙŠØ® Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø² Ù„ØªØ­Ø¯ÙŠØ«Ù‡.
            const winnerDateElement = document.querySelector('.details-group[data-field="winner_selection_date"] p');

            if (lastCompDateValue && durationValue && winnerDateElement) {
                const durationMap = { '24h': 1, '48h': 2, 'monthly': 30 };
                const durationDays = durationMap[durationValue] || 0;
                if (durationDays > 0) {
                    try {
                        const newDate = new Date(lastCompDateValue);
                        newDate.setDate(newDate.getDate() + durationDays);
                        winnerDateElement.textContent = newDate.toLocaleDateString('ar-EG');
                    } catch (e) {
                        // ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù†Ø§ØªØ¬Ø© Ø¹Ù† Ø¥Ø¯Ø®Ø§Ù„ ØªØ§Ø±ÙŠØ® ØºÙŠØ± ØµØ§Ù„Ø­ Ù…Ø¤Ù‚ØªØ§Ù‹
                    }
                }
            }
        };

        // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ø¯Ø§Ù„Ø© Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ù‚ÙŠÙ…Ø©
        inputElement.addEventListener('change', liveUpdateWinnerDate);
    }

    groupElement.querySelector('#inline-cancel-btn').addEventListener('click', () => {
        renderDetailsView(agent);
    });

    groupElement.querySelector('#inline-save-btn').addEventListener('click', async () => {
        const input = groupElement.querySelector('#inline-edit-input');
        let newValue = input.value;
        const updateData = {};

        // --- DEBUG: Log the field and new value ---
        console.log(`[Inline Edit] Field: "${fieldName}", New Value from input: "${newValue}"`);

        
        // --- STEP 5: MIGRATION TO CUSTOM BACKEND ---
        let currentAgent;
        try {
            const response = await authedFetch(`/api/agents/${agent._id}`);
            if (!response.ok) throw new Error('Failed to fetch latest agent data.');
            const result = await response.json();
            currentAgent = result.data;
        } catch (fetchError) {
            showToast('ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„ Ø§Ù„Ù…Ø­Ø¯Ø«Ø©.', 'error');
            console.error(fetchError);
            return;
        }

        if (fieldName === 'rank') {
            // Check if rank actually changed
            if (newValue === currentAgent.rank) {
                showToast('Ø§Ù„Ù…Ø±ØªØ¨Ø© Ù„Ù… ØªØªØºÙŠØ±.', 'info');
            console.log('[Rank Change] Showing modal for rank change from', currentAgent.rank, 'to', newValue);
            
                renderDetailsView(agent);
                return;
            }

            // Show modal to get reason and action before saving
            showRankChangeModal(currentAgent, newValue, async (reason, action) => {
                console.log('[Rank Change] Modal confirmed with reason:', reason, 'action:', action);
                const rankData = RANKS_DATA[newValue] || {};
                updateData.rank = newValue;
                updateData.competition_bonus = rankData.competition_bonus;
                updateData.deposit_bonus_percentage = rankData.deposit_bonus_percentage;
                updateData.deposit_bonus_count = rankData.deposit_bonus_count;
                // When rank changes, it might affect balances
                // --- ØªØ¹Ø¯ÙŠÙ„: Ù…Ù†Ø·Ù‚ Ø®Ø§Øµ Ù„Ù…Ø±ØªØ¨Ø© "Ø¨Ø¯ÙˆÙ† Ù…Ø±ØªØ¨Ø© Ø­ØµØ±ÙŠØ©" ---
                if (newValue === 'Ø¨Ø¯ÙˆÙ† Ù…Ø±ØªØ¨Ø© Ø­ØµØ±ÙŠØ©') {
                    updateData.competition_bonus = 60;
                    updateData.remaining_balance = 60 - (currentAgent.consumed_balance || 0)
                    updateData.deposit_bonus_percentage = null;
                    updateData.deposit_bonus_count = null;
                } else {
                    updateData.competition_bonus = rankData.competition_bonus;
                    updateData.remaining_balance = (rankData.competition_bonus || 0) - (currentAgent.consumed_balance || 0);
                }
                updateData.remaining_deposit_bonus = (rankData.deposit_bonus_count || 0) - (currentAgent.used_deposit_bonus || 0);

                // Save the agent update first
                try {
                    const response = await authedFetch(`/api/agents/${agent._id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(updateData)
                    });
                    if (!response.ok) throw new Error((await response.json()).message || 'ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø±ØªØ¨Ø©.');
                    const { data: updatedAgent } = await response.json();

                    // Record the rank change with reason and action
                    const rankChangeResponse = await authedFetch(`/api/agents/${agent._id}/rank-change`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            old_rank: currentAgent.rank,
                            new_rank: newValue,
                            reason: reason,
                            action_taken: action
                        })
                    });

                    if (!rankChangeResponse.ok) {
                        console.error('Failed to record rank change:', await rankChangeResponse.text());
                    }

                    showToast('ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø±ØªØ¨Ø© ÙˆØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø³Ø¨Ø¨ ÙˆØ§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                    renderAgentProfilePage(agent._id, { activeTab: 'details' });
                } catch (e) {
                    showToast(`ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø±ØªØ¨Ø©: ${e.message}`, 'error');
                    renderDetailsView(agent);
                }
            }, () => {
                // On cancel, revert to original view
                renderDetailsView(agent);
            });
            return; // Don't proceed with normal save flow
        } else if (fieldName === 'classification') {
            // Check if classification actually changed
            if (newValue === currentAgent.classification) {
                showToast('Ø§Ù„ØªØµÙ†ÙŠÙ Ù„Ù… ÙŠØªØºÙŠØ±.', 'info');
                renderDetailsView(agent);
                return;
            }

            // Show modal to get reason and action before saving
            showClassificationChangeModal(currentAgent, newValue, async (reason, action) => {
                console.log('[Classification Change] Modal confirmed with reason:', reason, 'action:', action);
                
                updateData.classification = newValue;
                // --- Automatically update competitions_per_week based on classification ---
                const newClassification = newValue.toUpperCase();
                if (newClassification === 'R' || newClassification === 'A') {
                    updateData.competitions_per_week = 2;
                } else if (newClassification === 'B' || newClassification === 'C') {
                    updateData.competitions_per_week = 1;
                }

                // Save the agent update first
                try {
                    const response = await authedFetch(`/api/agents/${agent._id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(updateData)
                    });

                    if (!response.ok) {
                        throw new Error('ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØµÙ†ÙŠÙ.');
                    }

                    // Now record the classification change with reason and action
                    const classificationChangeResponse = await authedFetch(`/api/agents/${currentAgent._id}/classification-change`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            old_classification: currentAgent.classification,
                            new_classification: newValue,
                            reason: reason,
                            action_taken: action
                        })
                    });

                    if (!classificationChangeResponse.ok) {
                        console.error('Failed to record classification change:', await classificationChangeResponse.text());
                    }

                    showToast('ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØµÙ†ÙŠÙ ÙˆØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø³Ø¨Ø¨ ÙˆØ§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                    renderAgentProfilePage(agent._id, { activeTab: 'details' });
                } catch (e) {
                    showToast(`ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØµÙ†ÙŠÙ: ${e.message}`, 'error');
                    renderDetailsView(agent);
                }
            }, () => {
                // On cancel, revert to original view
                renderDetailsView(agent);
            });
            return; // Don't proceed with normal save flow
        } else {
            // --- NEW: Automatically update competition_duration when competitions_per_week changes ---
            if (fieldName === 'competitions_per_week') {
                const compsPerWeek = parseInt(newValue, 10);
                if (compsPerWeek === 1) {
                    updateData.competition_duration = '48h';
                } else if (compsPerWeek === 2) {
                    updateData.competition_duration = '24h';
                } else if (compsPerWeek === 3) {
                    updateData.competition_duration = '24h'; // Fallback for 16h
                }
            }

            let finalValue;
            if (fieldName === 'audit_days') {
                finalValue = Array.from(groupElement.querySelectorAll('.day-toggle-input:checked')).map(input => parseInt(input.value, 10));
            } else if (fieldName.includes('_date')) {
                finalValue = newValue === '' ? null : newValue;
            } else {
                // --- REWRITE: Professional and robust value parsing ---
                // Define which fields should be treated as integers vs floats
                const integerFields = ['deposit_bonus_count', 'used_deposit_bonus', 'remaining_deposit_bonus', 'winners_count', 'competitions_per_week', 'deposit_bonus_winners_count'];
                const floatFields = ['competition_bonus', 'consumed_balance', 'remaining_balance', 'single_competition_balance', 'prize_per_winner', 'deposit_bonus_percentage'];

                if (integerFields.includes(fieldName)) {
                    const parsedInt = parseInt(newValue, 10);
                    finalValue = isNaN(parsedInt) ? null : parsedInt;
                } else if (floatFields.includes(fieldName)) {
                    const parsedFloat = parseFloat(newValue);
                    finalValue = isNaN(parsedFloat) ? null : parsedFloat;
                } else {
                    // For all other fields (like rank, renewal_period, etc.)
                    finalValue = newValue;
                }
            }

            // --- DEBUG: Log the final parsed value ---
            console.log(`[Inline Edit] Final parsed value for "${fieldName}":`, finalValue);

            // --- NEW: Automatically calculate single_competition_balance ---
            const winnersCount = parseInt(fieldName === 'winners_count' ? finalValue : currentAgent.winners_count, 10) || 0;
            const prizePerWinner = parseFloat(fieldName === 'prize_per_winner' ? finalValue : currentAgent.prize_per_winner) || 0;

            if (fieldName === 'winners_count' || fieldName === 'prize_per_winner') {
                updateData.single_competition_balance = winnersCount * prizePerWinner;
            }

            // --- FIX: Smart updates for financial fields ---
            // Start with the direct update
            updateData[fieldName] = finalValue;

            // Get current values for calculation, defaulting to 0 if null/undefined
            const competitionBonus = parseFloat(fieldName === 'competition_bonus' ? finalValue : currentAgent.competition_bonus) || 0;
            const consumedBalance = parseFloat(fieldName === 'consumed_balance' ? finalValue : currentAgent.consumed_balance) || 0;
            const remainingBalance = parseFloat(fieldName === 'remaining_balance' ? finalValue : currentAgent.remaining_balance) || 0;
            
            const depositBonusCount = parseInt(fieldName === 'deposit_bonus_count' ? finalValue : currentAgent.deposit_bonus_count, 10) || 0;
            const usedDepositBonus = parseInt(fieldName === 'used_deposit_bonus' ? finalValue : currentAgent.used_deposit_bonus, 10) || 0;
            const remainingDepositBonus = parseInt(fieldName === 'remaining_deposit_bonus' ? finalValue : currentAgent.remaining_deposit_bonus, 10) || 0;

            // Recalculate related fields based on which field was edited
            // This logic is now primarily handled by the backend, but we keep it for immediate UI feedback if needed.
            if (fieldName === 'competition_bonus' || fieldName === 'consumed_balance') {
                updateData.remaining_balance = competitionBonus - consumedBalance;
            } else if (fieldName === 'remaining_balance') {
                updateData.consumed_balance = competitionBonus - remainingBalance;
            }

            if (fieldName === 'deposit_bonus_count' || fieldName === 'used_deposit_bonus') {
                updateData.remaining_deposit_bonus = depositBonusCount - usedDepositBonus;
            } else if (fieldName === 'remaining_deposit_bonus') {
                updateData.used_deposit_bonus = depositBonusCount - remainingDepositBonus;
            }

            // --- FIX: Ensure deposit_bonus_winners_count is handled ---
            if (fieldName === 'deposit_bonus_winners_count') {
                updateData.deposit_bonus_winners_count = finalValue;
            }

            // Ensure no negative values are saved for balances
            if (updateData.remaining_balance < 0) updateData.remaining_balance = 0;
            if (updateData.consumed_balance < 0) updateData.consumed_balance = 0;
            if (updateData.remaining_deposit_bonus < 0) updateData.remaining_deposit_bonus = 0;
            if (updateData.used_deposit_bonus < 0) updateData.used_deposit_bonus = 0;
        }

        // --- DEBUG: Log the complete data payload being sent to the server ---
        console.log('[Inline Edit] Sending update payload to server:', updateData);
        // --- NEW DEBUG: Log to show why the number is not being saved ---
        console.log(`[DEBUG] The payload for the server is being prepared. Field being edited: "${fieldName}". Does the payload include "deposit_bonus_winners_count"?`, 'deposit_bonus_winners_count' in updateData);


        try {
            const response = await authedFetch(`/api/agents/${agent._id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(updateData)
            });
            if (!response.ok) throw new Error((await response.json()).message || 'ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ù‚Ù„.');
            const { data: updatedAgent } = await response.json();

            // --- ACTIVATED: Log the activity from the frontend to ensure user context is captured. ---
            const oldValue = currentAgent[fieldName];
            const description = `ØªÙ… ØªØ­Ø¯ÙŠØ« "${label}" Ù…Ù† "${oldValue || 'ÙØ§Ø±Øº'}" Ø¥Ù„Ù‰ "${newValue || 'ÙØ§Ø±Øº'}".`;
            await logAgentActivity(currentUserProfile?._id, agent._id, 'DETAILS_UPDATE', description, { field: label, from: oldValue, to: newValue });

            showToast('ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ± Ø¨Ù†Ø¬Ø§Ø­.', 'success');
            // FIX: Always re-render the full profile page to ensure all tabs (especially the log) are updated.
            // This is more reliable than partial updates.
            renderAgentProfilePage(agent._id, { activeTab: 'details' });
        } catch (e) {
            showToast(`ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ù‚Ù„: ${e.message}`, 'error');
            renderDetailsView(agent); // Revert on error
        }
    });
}

// FIX: Missing function referenced by inline edit trigger
function renderInlineEditor(groupElement, agent) {
    if (!groupElement) return;
    const fieldName = groupElement.dataset.field;
    if (!fieldName) return;
    enableInlineEdit(groupElement, fieldName, agent);
}

function calculateNextRenewalDate(agent) {
    if (!agent || !agent.renewal_period || agent.renewal_period === 'none') {
        return null;
    }
    const lastRenewal = agent.last_renewal_date ? new Date(agent.last_renewal_date) : new Date(agent.createdAt);
    let nextRenewalDate = new Date(lastRenewal);

    switch (agent.renewal_period) {
        case 'weekly':
            nextRenewalDate.setDate(nextRenewalDate.getDate() + 7);
            break;
        case 'biweekly':
            nextRenewalDate.setDate(nextRenewalDate.getDate() + 14);
            break;
        case 'monthly':
            nextRenewalDate.setMonth(nextRenewalDate.getMonth() + 1);
            break;
        default:
            return null;
    }
    // Ensure it is set to 5:00 AM
    nextRenewalDate.setHours(5, 0, 0, 0);
    return nextRenewalDate;
}

// --- NEW: Detailed Countdown Modal ---
function showDetailedCountdownModal(targetDate) {
    const modalId = 'countdown-modal-' + Date.now();
    
    const modalContent = `
        <div style="text-align:center; padding: 20px;">
            <h3 style="color:#fff; margin-bottom: 20px; font-family:'Cairo', sans-serif;">Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ù„Ù„ØªØ¬Ø¯ÙŠØ¯</h3>
            <div id="${modalId}-timer" style="display:flex; justify-content:center; gap:15px; direction:ltr;">
                <!-- Timer parts will go here -->
            </div>
            <p style="margin-top:20px; color:#94a3b8; font-size:0.9em;">Ø³ÙŠØªÙ… Ø§Ù„ØªØ¬Ø¯ÙŠØ¯ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ÙˆÙ‚Øª</p>
        </div>
    `;

    const overlay = document.createElement('div');
    overlay.className = 'custom-modal-overlay';
    overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.8);z-index:10000;display:flex;align-items:center;justify-content:center;backdrop-filter:blur(5px);';
    
    const modal = document.createElement('div');
    modal.style.cssText = 'background:#1e293b; border:1px solid #334155; border-radius:16px; padding:20px; width:90%; max-width:500px; box-shadow:0 20px 50px rgba(0,0,0,0.5); position:relative;';
    
    modal.innerHTML = `
        <button id="${modalId}-close" style="position:absolute; top:15px; right:15px; background:none; border:none; color:#64748b; font-size:18px; cursor:pointer;"><i class="fas fa-times"></i></button>
        ${modalContent}
    `;
    
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    
    const createTimerUnit = (value, label) => `
        <div style="display:flex; flex-direction:column; align-items:center;">
            <div style="background:#0f172a; color:#3b82f6; font-size:28px; font-weight:bold; width:70px; height:70px; border-radius:12px; display:flex; align-items:center; justify-content:center; border:1px solid #1e40af; box-shadow:0 0 15px rgba(59,130,246,0.2); margin-bottom:8px; font-family:monospace;">
                ${value.toString().padStart(2, '0')}
            </div>
            <span style="color:#94a3b8; font-size:12px;">${label}</span>
        </div>
    `;

    const updateModalTimer = () => {
        const now = new Date();
        const diff = targetDate - now;
        
        if (diff <= 0) {
            cleanup();
            return;
        }
        
        const days = Math.floor(diff / (1000 * 60 * 60 * 24));
        const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);
        
        const timerContainer = document.getElementById(`${modalId}-timer`);
        if (timerContainer) {
            timerContainer.innerHTML = `
                ${createTimerUnit(days, 'Ø£ÙŠØ§Ù…')}
                ${createTimerUnit(hours, 'Ø³Ø§Ø¹Ø§Øª')}
                ${createTimerUnit(minutes, 'Ø¯Ù‚Ø§Ø¦Ù‚')}
                ${createTimerUnit(seconds, 'Ø«ÙˆØ§Ù†ÙŠ')}
            `;
        }
    };
    
    updateModalTimer();
    const intervalId = setInterval(updateModalTimer, 1000);
    
    const cleanup = () => {
        clearInterval(intervalId);
        if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
    };
    
    document.getElementById(`${modalId}-close`).onclick = cleanup;
    overlay.onclick = (e) => {
        if (e.target === overlay) cleanup();
    };
}

function updateManualRenewButtonState(agent) {
    const renewalBtn = document.getElementById('manual-renew-btn');
    if (!renewalBtn) return;

    const nextRenewalDate = calculateNextRenewalDate(agent);

    if (!nextRenewalDate) {
        renewalBtn.style.display = 'none';
        return;
    }

    renewalBtn.style.display = 'inline-flex';

    if (new Date() >= nextRenewalDate) {
        renewalBtn.disabled = false;
        renewalBtn.classList.add('ready');
    } else {
        renewalBtn.disabled = true;
        renewalBtn.classList.remove('ready');
    }
}

function formatDuration(ms) {
    if (ms < 0) ms = -ms;
    const time = {
        day: Math.floor(ms / 86400000),
        hour: Math.floor(ms / 3600000) % 24,
        minute: Math.floor(ms / 60000) % 60,
        second: Math.floor(ms / 1000) % 60
    };
    return Object.entries(time).filter(val => val[1] !== 0).map(([key, val]) => `${val} ${key}${val !== 1 ? 's' : ''}`).join(', ');
}

function displayNextRenewalDate(agent) {
    const displayElement = document.getElementById('renewal-date-display');
    if (!displayElement) return;

    const nextRenewalDate = calculateNextRenewalDate(agent);

    if (!nextRenewalDate) {
        displayElement.style.display = 'none';
        updateManualRenewButtonState(agent);
        return;
    }

    displayElement.style.display = 'flex';

    const updateCountdown = () => {
        const now = new Date();
        const diff = nextRenewalDate - now;

        if (diff <= 0) {
            console.log('[Renewal] Countdown finished. Checking renewal status...');
            if (isRenewing) {
                console.log('[Renewal] Blocked: A renewal process is already in progress.');
                return;
            }
            console.log('[Renewal] Starting renewal process...');
            isRenewing = true; // Set flag

            if (renewalCountdownInterval) clearInterval(renewalCountdownInterval);
            
            displayElement.innerHTML = `<i class="fas fa-spinner fa-spin"></i> <span>Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ¬Ø¯ÙŠØ¯...</span>`;
            displayElement.classList.add('due');

            // Trigger the renewal immediately
            (async () => {
                try {
                    console.log(`[Renewal] Calling API to renew agent ${agent._id}`);
                    const response = await authedFetch(`/api/agents/${agent._id}/renew`, { method: 'POST' });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.message || 'ÙØ´Ù„ Ø§Ù„ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ.');
                    }
                    console.log('[Renewal] API call successful. Re-rendering page.');
                    showToast(`ØªÙ… ØªØ¬Ø¯ÙŠØ¯ Ø±ØµÙŠØ¯ Ø§Ù„ÙˆÙƒÙŠÙ„ ${agent.name} Ø¨Ù†Ø¬Ø§Ø­!`, 'success');
                    // Re-render the page to show updated values
                    renderAgentProfilePage(agent._id, { activeTab: 'details' });
                } catch (error) {
                    console.error('[Renewal] API call failed:', error.message);
                    showToast(`ÙØ´Ù„ Ø§Ù„ØªØ¬Ø¯ÙŠØ¯: ${error.message}`, 'error');
                    // Re-render to show the 'due' state again if it fails
                    renderAgentProfilePage(agent._id, { activeTab: 'details' });
                }
            })();
            return;
        }

        if (diff < 86400000) { // Less than 24 hours
            const hours = Math.floor(diff / (1000 * 60 * 60)).toString().padStart(2, '0');
            const minutes = Math.floor((diff / (1000 * 60)) % 60).toString().padStart(2, '0');
            const seconds = Math.floor((diff / 1000) % 60).toString().padStart(2, '0');
            
            const absoluteDateString = nextRenewalDate.toLocaleDateString('ar-EG', {
                year: 'numeric',
                month: 'numeric',
                day: 'numeric'
            });
            const fullDateTimeString = `${absoluteDateString} Ø§Ù„Ø³Ø§Ø¹Ø© 5:00 Øµ`;
            
            // Show countdown above the standard text
            displayElement.innerHTML = `
                <div style="display:flex;flex-direction:column;align-items:center;line-height:1.2;">
                    <div style="font-size:1.2em;font-weight:bold;color:#fbbf24;margin-bottom:2px;">
                        <i class="fas fa-hourglass-half fa-spin"></i> ${hours}:${minutes}:${seconds}
                    </div>
                    <div style="font-size:0.85em;opacity:0.9;">
                        <i class="fas fa-calendar-alt"></i> ÙŠÙØ¬Ø¯Ø¯ Ø®Ù„Ø§Ù„ ÙŠÙˆÙ… (${fullDateTimeString})
                    </div>
                </div>
            `;
            displayElement.classList.add('imminent');
        } else {
            // More than 24 hours, show relative time
            const days = Math.ceil(diff / (1000 * 60 * 60 * 24));
            let relativeTime = `ÙÙŠ ${days} Ø£ÙŠØ§Ù…`;

            const absoluteDateString = nextRenewalDate.toLocaleDateString('ar-EG', {
                year: 'numeric',
                month: 'numeric',
                day: 'numeric'
            });
            const fullDateTimeString = `${absoluteDateString} Ø§Ù„Ø³Ø§Ø¹Ø© 5:00 Øµ`;

            displayElement.innerHTML = `<span class="renewal-details-trigger" style="cursor:pointer;margin-left:8px;display:inline-flex;align-items:center;justify-content:center;width:28px;height:28px;background:rgba(255,255,255,0.1);border-radius:50%;transition:all 0.2s;" title="Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªÙØµÙŠÙ„ÙŠ" onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'"><i class="fas fa-clock"></i></span> <span>ÙŠÙØ¬Ø¯Ø¯ ${relativeTime} (${fullDateTimeString})</span>`;
            displayElement.classList.remove('imminent', 'due');
            
            // Ensure click listener is attached (idempotent)
            if (!displayElement.hasAttribute('data-click-attached')) {
                displayElement.addEventListener('click', (e) => {
                    if (e.target.closest('.renewal-details-trigger')) {
                        showDetailedCountdownModal(nextRenewalDate);
                    }
                });
                displayElement.setAttribute('data-click-attached', 'true');
            }
        }
    };

    if (renewalCountdownInterval) clearInterval(renewalCountdownInterval);
    updateCountdown(); // Initial call
    renewalCountdownInterval = setInterval(updateCountdown, 1000); // Update every second

    updateManualRenewButtonState(agent);
}

// --- NEW: Agent Analytics Section ---
async function renderAgentAnalytics(agent, container, dateRange = 'all') {
    // Loader while fetching
    container.innerHTML = '<div class="loader-container"><div class="spinner"></div></div>';
    let data = null;
    try {
        const queryParams = new URLSearchParams({ dateRange });
        const resp = await authedFetch(`/api/stats/agent-analytics/${agent._id}?${queryParams.toString()}`);
        const json = await resp.json();
        if (!resp.ok) throw new Error(json.message || 'Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„');
        data = json.data;
    } catch (e) {
        console.error('[AgentAnalytics] Failed:', e);
        container.innerHTML = '<p class="error">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª.</p>';
        return;
    }

    if (!data || !data.stats) {
        container.innerHTML = '<p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª ØªØ­Ù„ÙŠÙ„ÙŠØ© ÙÙŠ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ø²Ù…Ù†ÙŠ Ø§Ù„Ù…Ø­Ø¯Ø¯.</p>';
        return;
    }

    const competitions = (data.stats.competitions || []).sort((a,b) => new Date(b.createdAt) - new Date(a.createdAt));
    const latest = competitions.slice(0, 10);

    const analyticsHeaderHtml = `
        <div class="analytics-header" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;padding:20px;background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);border-radius:12px;border:1px solid #2a2d3a;">
            <div style="display:flex;align-items:center;gap:12px;">
                <div style="width:40px;height:40px;background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);border-radius:10px;display:flex;align-items:center;justify-content:center;">
                    <i class="fas fa-chart-line" style="color:#fff;font-size:18px;"></i>
                </div>
                <div>
                    <h3 style="margin:0;color:#fff;font-size:18px;font-weight:600;">ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©</h3>
                    <p style="margin:4px 0 0;color:#a1a1aa;font-size:13px;">Ø¨ÙŠØ§Ù†Ø§Øª Ø´Ø§Ù…Ù„Ø© ÙˆÙ…ÙØµÙ„Ø© Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„ÙˆÙƒÙŠÙ„</p>
                </div>
            </div>
            <div class="date-range-selector" style="display:flex;gap:8px;flex-wrap:wrap;">
                <button class="range-btn dark-range-btn ${dateRange === '30' ? 'active' : ''}" data-range="30" style="background:#2a2d3a;color:#e2e8f0;border:1px solid #404040;padding:8px 16px;border-radius:8px;font-size:13px;font-weight:500;transition:all 0.2s;cursor:pointer;">Ø¢Ø®Ø± 30 ÙŠÙˆÙ…</button>
                <button class="range-btn dark-range-btn ${dateRange === '90' ? 'active' : ''}" data-range="90" style="background:#2a2d3a;color:#e2e8f0;border:1px solid #404040;padding:8px 16px;border-radius:8px;font-size:13px;font-weight:500;transition:all 0.2s;cursor:pointer;">Ø¢Ø®Ø± 90 ÙŠÙˆÙ…</button>
                <button class="range-btn dark-range-btn ${dateRange === '365' ? 'active' : ''}" data-range="365" style="background:#2a2d3a;color:#e2e8f0;border:1px solid #404040;padding:8px 16px;border-radius:8px;font-size:13px;font-weight:500;transition:all 0.2s;cursor:pointer;">Ø¢Ø®Ø± Ø³Ù†Ø©</button>
                <button class="range-btn dark-range-btn ${dateRange === 'all' ? 'active' : ''}" data-range="all" style="background:#2a2d3a;color:#e2e8f0;border:1px solid #404040;padding:8px 16px;border-radius:8px;font-size:13px;font-weight:500;transition:all 0.2s;cursor:pointer;">ÙƒÙ„ Ø§Ù„ÙˆÙ‚Øª</button>
            </div>
        </div>`;

    const kpisHtml = `
        <div class="agent-kpis" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:16px;margin-bottom:24px;">
            <div class="kpi-card dark-kpi-card" style="background:linear-gradient(135deg, #1e293b 0%, #334155 100%);border:1px solid #475569;border-radius:12px;padding:20px;text-align:center;position:relative;overflow:hidden;">
                <div class="kpi-icon" style="width:48px;height:48px;background:linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);border-radius:12px;display:flex;align-items:center;justify-content:center;margin:0 auto 12px;position:relative;z-index:2;">
                    <i class="fas fa-trophy" style="color:#fff;font-size:20px;"></i>
                </div>
                <div class="kpi-glow" style="position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(45deg, rgba(59,130,246,0.1) 0%, rgba(29,78,216,0.05) 100%);border-radius:12px;"></div>
                <div style="font-size:13px;color:#94a3b8;font-weight:500;margin-bottom:8px;position:relative;z-index:2;">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª</div>
                <div style="font-weight:700;font-size:28px;color:#f1f5f9;position:relative;z-index:2;">${data.stats.total_competitions}</div>
                <div style="position:absolute;top:-20px;right:-20px;width:60px;height:60px;background:radial-gradient(circle, rgba(59,130,246,0.1) 0%, transparent 70%);border-radius:50%;"></div>
            </div>
            <div class="kpi-card dark-kpi-card" style="background:linear-gradient(135deg, #1e293b 0%, #334155 100%);border:1px solid #475569;border-radius:12px;padding:20px;text-align:center;position:relative;overflow:hidden;">
                <div class="kpi-icon" style="width:48px;height:48px;background:linear-gradient(135deg, #10b981 0%, #059669 100%);border-radius:12px;display:flex;align-items:center;justify-content:center;margin:0 auto 12px;position:relative;z-index:2;">
                    <i class="fas fa-play-circle" style="color:#fff;font-size:20px;"></i>
                </div>
                <div class="kpi-glow" style="position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(45deg, rgba(16,185,129,0.1) 0%, rgba(5,150,105,0.05) 100%);border-radius:12px;"></div>
                <div style="font-size:13px;color:#94a3b8;font-weight:500;margin-bottom:8px;position:relative;z-index:2;">Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©</div>
                <div style="font-weight:700;font-size:28px;color:#f1f5f9;position:relative;z-index:2;">${data.stats.active_competitions}</div>
                <div style="position:absolute;top:-20px;right:-20px;width:60px;height:60px;background:radial-gradient(circle, rgba(16,185,129,0.1) 0%, transparent 70%);border-radius:50%;"></div>
            </div>
            <div class="kpi-card dark-kpi-card" style="background:linear-gradient(135deg, #1e293b 0%, #334155 100%);border:1px solid #475569;border-radius:12px;padding:20px;text-align:center;position:relative;overflow:hidden;">
                <div class="kpi-icon" style="width:48px;height:48px;background:linear-gradient(135deg, #f59e0b 0%, #d97706 100%);border-radius:12px;display:flex;align-items:center;justify-content:center;margin:0 auto 12px;position:relative;z-index:2;">
                    <i class="fas fa-eye" style="color:#fff;font-size:20px;"></i>
                </div>
                <div class="kpi-glow" style="position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(45deg, rgba(245,158,11,0.1) 0%, rgba(217,119,6,0.05) 100%);border-radius:12px;"></div>
                <div style="font-size:13px;color:#94a3b8;font-weight:500;margin-bottom:8px;position:relative;z-index:2;">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª</div>
                <div style="font-weight:700;font-size:28px;color:#f1f5f9;position:relative;z-index:2;">${data.stats.total_views}</div>
                <div style="position:absolute;top:-20px;right:-20px;width:60px;height:60px;background:radial-gradient(circle, rgba(245,158,11,0.1) 0%, transparent 70%);border-radius:50%;"></div>
            </div>
            <div class="kpi-card dark-kpi-card" style="background:linear-gradient(135deg, #1e293b 0%, #334155 100%);border:1px solid #475569;border-radius:12px;padding:20px;text-align:center;position:relative;overflow:hidden;">
                <div class="kpi-icon" style="width:48px;height:48px;background:linear-gradient(135deg, #ec4899 0%, #be185d 100%);border-radius:12px;display:flex;align-items:center;justify-content:center;margin:0 auto 12px;position:relative;z-index:2;">
                    <i class="fas fa-heart" style="color:#fff;font-size:20px;"></i>
                </div>
                <div class="kpi-glow" style="position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(45deg, rgba(236,72,153,0.1) 0%, rgba(190,24,93,0.05) 100%);border-radius:12px;"></div>
                <div style="font-size:13px;color:#94a3b8;font-weight:500;margin-bottom:8px;position:relative;z-index:2;">Ø¹Ø¯Ø¯ Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª</div>
                <div style="font-weight:700;font-size:28px;color:#f1f5f9;position:relative;z-index:2;">${data.stats.total_reactions || 0}</div>
                <div style="position:absolute;top:-20px;right:-20px;width:60px;height:60px;background:radial-gradient(circle, rgba(236,72,153,0.1) 0%, transparent 70%);border-radius:50%;"></div>
            </div>
            <div class="kpi-card dark-kpi-card" style="background:linear-gradient(135deg, #1e293b 0%, #334155 100%);border:1px solid #475569;border-radius:12px;padding:20px;text-align:center;position:relative;overflow:hidden;">
                <div class="kpi-icon" style="width:48px;height:48px;background:linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);border-radius:12px;display:flex;align-items:center;justify-content:center;margin:0 auto 12px;position:relative;z-index:2;">
                    <i class="fas fa-users" style="color:#fff;font-size:20px;"></i>
                </div>
                <div class="kpi-glow" style="position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(45deg, rgba(139,92,246,0.1) 0%, rgba(124,58,237,0.05) 100%);border-radius:12px;"></div>
                <div style="font-size:13px;color:#94a3b8;font-weight:500;margin-bottom:8px;position:relative;z-index:2;">Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†</div>
                <div style="font-weight:700;font-size:28px;color:#f1f5f9;position:relative;z-index:2;">${data.stats.total_participants}</div>
                <div style="position:absolute;top:-20px;right:-20px;width:60px;height:60px;background:radial-gradient(circle, rgba(139,92,246,0.1) 0%, transparent 70%);border-radius:50%;"></div>
            </div>
            <div class="kpi-card dark-kpi-card" style="background:linear-gradient(135deg, #1e293b 0%, #334155 100%);border:1px solid #475569;border-radius:12px;padding:20px;text-align:center;position:relative;overflow:hidden;">
                <div class="kpi-icon" style="width:48px;height:48px;background:linear-gradient(135deg, #ef4444 0%, #dc2626 100%);border-radius:12px;display:flex;align-items:center;justify-content:center;margin:0 auto 12px;position:relative;z-index:2;">
                    <i class="fas fa-medal" style="color:#fff;font-size:20px;"></i>
                </div>
                <div class="kpi-glow" style="position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(45deg, rgba(239,68,68,0.1) 0%, rgba(220,38,38,0.05) 100%);border-radius:12px;"></div>
                <div style="font-size:13px;color:#94a3b8;font-weight:500;margin-bottom:8px;position:relative;z-index:2;">Ø¹Ø¯Ø¯ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†</div>
                <div style="font-weight:700;font-size:28px;color:#f1f5f9;position:relative;z-index:2;">${data.stats.total_winners}</div>
                <div style="position:absolute;top:-20px;right:-20px;width:60px;height:60px;background:radial-gradient(circle, rgba(239,68,68,0.1) 0%, transparent 70%);border-radius:50%;"></div>
            </div>
            <div class="kpi-card dark-kpi-card" style="background:linear-gradient(135deg, #1e293b 0%, #334155 100%);border:1px solid #475569;border-radius:12px;padding:20px;text-align:center;position:relative;overflow:hidden;">
                <div class="kpi-icon" style="width:48px;height:48px;background:linear-gradient(135deg, #22c55e 0%, #16a34a 100%);border-radius:12px;display:flex;align-items:center;justify-content:center;margin:0 auto 12px;position:relative;z-index:2;">
                    <i class="fas fa-rocket" style="color:#fff;font-size:20px;"></i>
                </div>
                <div class="kpi-glow" style="position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(45deg, rgba(34,197,94,0.1) 0%, rgba(22,163,74,0.05) 100%);border-radius:12px;"></div>
                <div style="font-size:13px;color:#94a3b8;font-weight:500;margin-bottom:8px;position:relative;z-index:2;">Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ù…Ùˆ</div>
                <div style="font-weight:700;font-size:28px;color:#f1f5f9;position:relative;z-index:2;">${(() => {
                    const views = data.stats.total_views || 0;
                    const participants = data.stats.total_participants || 0;
                    const reactions = data.stats.total_reactions || 0;
                    const competitions = data.stats.total_competitions || 1;
                    
                    // Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ù…Ùˆ Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠ
                    // 1. Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ù…Ù† Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª (40% Ù…Ù† Ø§Ù„ÙˆØ²Ù†)
                    const participationRate = views > 0 ? (participants / views) * 100 : 0;
                    
                    // 2. Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªÙØ§Ø¹Ù„ Ù„ÙƒÙ„ Ù…Ø´Ø§Ù‡Ø¯Ø© (30% Ù…Ù† Ø§Ù„ÙˆØ²Ù†)
                    const reactionRate = views > 0 ? (reactions / views) * 100 : 0;
                    
                    // 3. Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ† Ù„ÙƒÙ„ Ù…Ø³Ø§Ø¨Ù‚Ø© (30% Ù…Ù† Ø§Ù„ÙˆØ²Ù†)
                    const avgParticipantsPerComp = competitions > 0 ? participants / competitions : 0;
                    
                    // 4. Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù…Ùˆ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ ÙƒÙ…ØªÙˆØ³Ø· Ù…Ø±Ø¬Ø­
                    const growthScore = (participationRate * 0.4) + (reactionRate * 0.3) + (avgParticipantsPerComp * 2 * 0.3);
                    
                    return growthScore.toFixed(1) + '%';
                })()}</div>
                <div style="font-size:11px;color:#64748b;margin-top:6px;position:relative;z-index:2;">Ù†Ù…Ùˆ Ø§Ø­ØªØ±Ø§ÙÙŠ Ø´Ø§Ù…Ù„</div>
                <div style="position:absolute;top:-20px;right:-20px;width:60px;height:60px;background:radial-gradient(circle, rgba(34,197,94,0.1) 0%, transparent 70%);border-radius:50%;"></div>
            </div>
        </div>`;

    const tableHtml = `
        <div class="agent-competitions dark-table-container" style="background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);border:1px solid #2a2d3a;border-radius:12px;padding:24px;margin-bottom:24px;position:relative;overflow:hidden;">
            <div class="table-header" style="display:flex;align-items:center;gap:12px;margin-bottom:20px;">
                <div style="width:40px;height:40px;background:linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);border-radius:10px;display:flex;align-items:center;justify-content:center;">
                    <i class="fas fa-list" style="color:#fff;font-size:18px;"></i>
                </div>
                <div>
                    <h4 style="margin:0;color:#fff;font-size:18px;font-weight:600;">Ø¢Ø®Ø± 10 Ù…Ø³Ø§Ø¨Ù‚Ø§Øª</h4>
                    <p style="margin:4px 0 0;color:#a1a1aa;font-size:13px;">ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ø£Ø®ÙŠØ±Ø© ÙˆØ§Ù„Ø£Ø¯Ø§Ø¡</p>
                </div>
            </div>
            <div class="table-glow" style="position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(45deg, rgba(255,107,107,0.05) 0%, transparent 70%);pointer-events:none;"></div>
            ${latest.length === 0 ? '<p style="margin:0;color:#94a3b8;text-align:center;padding:40px;">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³Ø§Ø¨Ù‚Ø§Øª.</p>' : `
            <div style="overflow-x:auto;border-radius:8px;background:#0f172a;border:1px solid #334155;">
            <table style="width:100%;border-collapse:collapse;min-width:720px;">
                <thead>
                    <tr style="background:linear-gradient(135deg, #1e293b 0%, #334155 100%);color:#f1f5f9;font-size:13px;font-weight:600;">
                        <th style="padding:16px 20px;text-align:right;border-bottom:1px solid #475569;">Ø§Ù„Ø³Ø¤Ø§Ù„ / Ø§Ù„Ø§Ø³Ù…</th>
                        <th style="padding:16px 20px;text-align:right;border-bottom:1px solid #475569;">Ø§Ù„ØªØ§Ø±ÙŠØ®</th>
                        <th style="padding:16px 20px;text-align:right;border-bottom:1px solid #475569;">Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª</th>
                        <th style="padding:16px 20px;text-align:right;border-bottom:1px solid #475569;">Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙˆÙ†</th>
                        <th style="padding:16px 20px;text-align:right;border-bottom:1px solid #475569;">Ø§Ù„ÙØ§Ø¦Ø²ÙˆÙ†</th>
                        <th style="padding:16px 20px;text-align:right;border-bottom:1px solid #475569;">Ø§Ù„Ø­Ø§Ù„Ø©</th>
                    </tr>
                </thead>
                <tbody>
                    ${latest.map(c => {
                        const title = c.name || c.question || 'Ø¨Ø¯ÙˆÙ† Ø¹Ù†ÙˆØ§Ù†';
                        const safeTitle = title.replace(/[<>]/g, s => ({'<':'&lt;','>':'&gt;'}[s]));
                        const statusText = c.status === 'completed' ? 'Ù…ÙƒØªÙ…Ù„Ø©' : (c.status === 'active' ? 'Ù†Ø´Ø·Ø©' : 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯');
                        const statusColor = c.status === 'completed' ? '#10b981' : (c.status === 'active' ? '#f59e0b' : '#6b7280');
                        return `
                        <tr style="border-bottom:1px solid #334155;font-size:13px;background:#1e293b;color:#e2e8f0;" class="table-row">
                            <td class="comp-title-cell" data-full="${safeTitle}" style="padding:14px 20px;white-space:nowrap;max-width:220px;overflow:hidden;text-overflow:ellipsis;cursor:pointer;color:#60a5fa;" title="Ø§Ù†Ù‚Ø± Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù†Øµ Ø§Ù„ÙƒØ§Ù…Ù„">${safeTitle}</td>
                            <td style="padding:14px 20px;color:#cbd5e1;">${c.createdAt ? new Date(c.createdAt).toLocaleDateString('ar-EG') : '-'}</td>
                            <td style="padding:14px 20px;font-weight:600;color:#3b82f6;">${c.views_count || 0}</td>
                            <td style="padding:14px 20px;color:#cbd5e1;">${c.participants_count || 0}</td>
                            <td style="padding:14px 20px;color:#cbd5e1;">${c.winners_count || 0}</td>
                            <td style="padding:14px 20px;">
                                <span style="display:inline-flex;align-items:center;gap:6px;padding:6px 12px;border-radius:20px;font-size:12px;font-weight:500;background:${statusColor}20;color:${statusColor};border:1px solid ${statusColor}30;">
                                    <div style="width:6px;height:6px;border-radius:50%;background:${statusColor};"></div>
                                    ${statusText}
                                </span>
                            </td>
                        </tr>`;
                    }).join('')}
                </tbody>
            </table>
            </div>`}
        </div>`;

    const series = competitions.filter(c => c.createdAt).slice(-30).map(c => ({
        date: new Date(c.createdAt).toLocaleDateString('ar-EG'),
        views: c.views_count || 0,
        participants: c.participants_count || 0
    }));
    const chartHtml = series.length > 1 ? `
        <div class="chart-container dark-chart-container" style="background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);border:1px solid #2a2d3a;border-radius:12px;padding:24px;margin-bottom:24px;position:relative;overflow:hidden;">
            <div class="chart-header" style="display:flex;align-items:center;gap:12px;margin-bottom:20px;">
                <div style="width:40px;height:40px;background:linear-gradient(135deg, #a855f7 0%, #9333ea 100%);border-radius:10px;display:flex;align-items:center;justify-content:center;">
                    <i class="fas fa-chart-bar" style="color:#fff;font-size:18px;"></i>
                </div>
                <div>
                    <h4 style="margin:0;color:#fff;font-size:18px;font-weight:600;">ØªØ·ÙˆØ± Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª ÙˆØ§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª</h4>
                    <p style="margin:4px 0 0;color:#a1a1aa;font-size:13px;">ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø¹Ø¨Ø± Ø§Ù„ÙˆÙ‚Øª</p>
                </div>
            </div>
            <div class="chart-glow" style="position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(45deg, rgba(168,85,247,0.05) 0%, transparent 70%);pointer-events:none;"></div>
            <div style="position:relative;z-index:2;background:#0f172a;border-radius:8px;padding:16px;border:1px solid #334155;">
                <canvas id="agentCompetitionsTrend" height="220"></canvas>
            </div>
        </div>` : '';

    // --- NEW: Balance History Chart Container ---
    const balanceChartHtml = `
        <div class="chart-container dark-chart-container" style="background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);border:1px solid #2a2d3a;border-radius:12px;padding:24px;margin-bottom:24px;position:relative;overflow:hidden;">
            <div class="chart-header" style="display:flex;align-items:center;gap:12px;margin-bottom:20px;">
                <div style="width:40px;height:40px;background:linear-gradient(135deg, #10b981 0%, #059669 100%);border-radius:10px;display:flex;align-items:center;justify-content:center;">
                    <i class="fas fa-wallet" style="color:#fff;font-size:18px;"></i>
                </div>
                <div>
                    <h4 style="margin:0;color:#fff;font-size:18px;font-weight:600;">Ø³Ø¬Ù„ Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ Ø§Ù„Ø±ØµÙŠØ¯</h4>
                    <p style="margin:4px 0 0;color:#a1a1aa;font-size:13px;">ØªØªØ¨Ø¹ Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ Ø§Ù„Ø±ØµÙŠØ¯ Ø¹Ø¨Ø± Ø§Ù„ÙˆÙ‚Øª</p>
                </div>
            </div>
            <div class="chart-glow" style="position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(45deg, rgba(16,185,129,0.05) 0%, transparent 70%);pointer-events:none;"></div>
            <div id="balanceHistoryChartContainer" style="position:relative;z-index:2;background:#0f172a;border-radius:8px;padding:16px;border:1px solid #334155;height:300px;">
                <canvas id="balanceHistoryChart"></canvas>
            </div>
        </div>`;

    container.innerHTML = analyticsHeaderHtml + kpisHtml + chartHtml + balanceChartHtml + tableHtml;

    // --- NEW: Render Balance History Chart ---
    renderBalanceHistoryChart(agent._id, document.getElementById('balanceHistoryChartContainer'));

    // Add event listeners for range buttons
    container.querySelectorAll('.dark-range-btn').forEach(btn => {
        // Set initial active state styling
        if (btn.classList.contains('active')) {
            btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            btn.style.borderColor = '#667eea';
            btn.style.color = '#fff';
            btn.style.boxShadow = '0 4px 12px rgba(102, 126, 234, 0.3)';
        }
        
        btn.addEventListener('click', () => {
            // Remove active styling from all buttons
            container.querySelectorAll('.dark-range-btn').forEach(b => {
                b.classList.remove('active');
                b.style.background = '#2a2d3a';
                b.style.borderColor = '#404040';
                b.style.color = '#e2e8f0';
                b.style.boxShadow = 'none';
            });
            // Add active styling to clicked button
            btn.classList.add('active');
            btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            btn.style.borderColor = '#667eea';
            btn.style.color = '#fff';
            btn.style.boxShadow = '0 4px 12px rgba(102, 126, 234, 0.3)';
            // Re-render analytics with new date range
            renderAgentAnalytics(agent, container, btn.dataset.range);
        });
    });

    // Add hover effects for KPI cards
    container.querySelectorAll('.dark-kpi-card').forEach(card => {
        card.addEventListener('mouseenter', () => {
            card.style.transform = 'translateY(-4px)';
            card.style.boxShadow = '0 12px 24px rgba(0, 0, 0, 0.3)';
            card.style.borderColor = '#64748b';
        });
        card.addEventListener('mouseleave', () => {
            card.style.transform = 'translateY(0)';
            card.style.boxShadow = 'none';
            card.style.borderColor = '#475569';
        });
    });

    // Add hover effects for table rows
    container.querySelectorAll('.table-row').forEach(row => {
        row.addEventListener('mouseenter', () => {
            row.style.background = '#334155';
        });
        row.addEventListener('mouseleave', () => {
            row.style.background = '#1e293b';
        });
    });

    // Attach click handlers for competition question/name expansion
    container.querySelectorAll('.comp-title-cell').forEach(cell => {
        cell.addEventListener('click', () => {
            const full = cell.getAttribute('data-full');
            if (!full) return;
            if (typeof showConfirmationModal === 'function') {
                const body = `
                    <div class='dark-expand-modal-wrapper'>
                        <div class='dark-expand-modal'>
                            <div class='dark-expand-modal-header'>
                                <i class='fas fa-question-circle' style='color:#ff9800'></i> Ø§Ù„Ø³Ø¤Ø§Ù„ / Ø§Ù„Ø§Ø³Ù… Ø§Ù„ÙƒØ§Ù…Ù„
                            </div>
                            <div class='dark-expand-modal-body'>
                                <pre>${full}</pre>
                            </div>
                        </div>
                    </div>`;
                showConfirmationModal(body, async () => true, { title:'', confirmText:'<i class="fas fa-times"></i> Ø¥ØºÙ„Ø§Ù‚', showCancel:false });
            } else { alert(full); }
        });
    });

    if (chartHtml) {
        try {
            const ctx = document.getElementById('agentCompetitionsTrend').getContext('2d');
            new Chart(ctx, {
                type: 'line',
                data: { 
                    labels: series.map(p => p.date), 
                    datasets: [
                        { 
                            label: 'Ù…Ø´Ø§Ù‡Ø¯Ø§Øª', 
                            data: series.map(p => p.views), 
                            borderColor: '#3b82f6', 
                            backgroundColor: 'rgba(59,130,246,0.1)', 
                            tension: 0.4, 
                            fill: true,
                            pointBackgroundColor: '#3b82f6',
                            pointBorderColor: '#1e40af',
                            pointBorderWidth: 2,
                            pointRadius: 4,
                            pointHoverRadius: 6
                        },
                        { 
                            label: 'Ù…Ø´Ø§Ø±ÙƒÙˆÙ†', 
                            data: series.map(p => p.participants), 
                            borderColor: '#f59e0b', 
                            backgroundColor: 'rgba(245,158,11,0.1)', 
                            tension: 0.4, 
                            fill: true,
                            pointBackgroundColor: '#f59e0b',
                            pointBorderColor: '#d97706',
                            pointBorderWidth: 2,
                            pointRadius: 4,
                            pointHoverRadius: 6
                        }
                    ]
                },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: { 
                        legend: { 
                            position: 'top',
                            labels: {
                                color: '#e2e8f0',
                                font: {
                                    size: 12,
                                    weight: '500'
                                },
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(15, 23, 42, 0.95)',
                            titleColor: '#f1f5f9',
                            bodyColor: '#cbd5e1',
                            borderColor: '#334155',
                            borderWidth: 1,
                            cornerRadius: 8,
                            padding: 12
                        }
                    }, 
                    scales: { 
                        x: { 
                            grid: { 
                                color: 'rgba(51, 65, 85, 0.3)',
                                borderColor: '#334155'
                            },
                            ticks: {
                                color: '#94a3b8',
                                font: {
                                    size: 11
                                }
                            }
                        }, 
                        y: { 
                            beginAtZero: true, 
                            grid: { 
                                color: 'rgba(51, 65, 85, 0.3)',
                                borderColor: '#334155'
                            },
                            ticks: {
                                color: '#94a3b8',
                                font: {
                                    size: 11
                                }
                            }
                        } 
                    },
                    elements: {
                        point: {
                            hoverBorderWidth: 3
                        }
                    }
                }
            });
        } catch (e) { console.warn('Chart render failed', e); }
    }
}

function renderAgentAnalyticsChart(competitions, dateRange, agent) {
    const ctx = document.getElementById('agent-analytics-chart')?.getContext('2d');
    if (!ctx) return;

    // --- FIX: Ensure competitions is always an array ---
    if (!Array.isArray(competitions)) {
        competitions = [];
    }

    // --- FIX: Ensure agent exists ---
    if (!agent) {
        console.warn('[Analytics] Agent is undefined, cannot render chart');
        return;
    }

    // Determine the date range for the chart labels
    const chartLabels = [];
    const dailyData = {};
    const today = new Date();
    let daysInChart = 7; // Default for 'all' or '7d'

    if (dateRange === '30d') daysInChart = 30;
    else if (dateRange === 'month') daysInChart = today.getDate();
    else if (dateRange === 'all') {
        // --- FIX: Check if agent.created_at exists ---
        if (agent.created_at) {
            const oldestDate = new Date(agent.created_at); // Use agent creation date
            const diffTime = Math.abs(today - oldestDate);
            daysInChart = Math.max(7, Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1); // +1 to include today
        }
    }

    for (let i = daysInChart - 1; i >= 0; i--) {
        const date = new Date();
        date.setDate(today.getDate() - i);
        const dateString = date.toISOString().split('T')[0];
        chartLabels.push(date.toLocaleDateString('ar-EG', { day: 'numeric', month: 'short' }));
        dailyData[dateString] = { views: 0, reactions: 0, participants: 0 };
    }

    competitions.forEach(comp => {
        if (comp.createdAt) { // Check if createdAt exists
            const dateString = new Date(comp.createdAt).toISOString().split('T')[0];
            if (dailyData[dateString]) {
                dailyData[dateString].views += comp.views_count || 0;
                dailyData[dateString].reactions += comp.reactions_count || 0;
                dailyData[dateString].participants += comp.participants_count || 0;
            }
        }
    });

    const dailyViews = Object.values(dailyData).map(d => d.views);
    const dailyReactions = Object.values(dailyData).map(d => d.reactions);
    const dailyParticipants = Object.values(dailyData).map(d => d.participants);

    new Chart(ctx, {
        type: 'line',
        data: {
            labels: chartLabels,
            datasets: [
                { label: 'Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª', data: dailyViews, borderColor: 'rgba(54, 162, 235, 1)', backgroundColor: 'rgba(54, 162, 235, 0.2)', fill: true, tension: 0.3 },
                { label: 'Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª', data: dailyReactions, borderColor: 'rgba(255, 206, 86, 1)', backgroundColor: 'rgba(255, 206, 86, 0.2)', fill: true, tension: 0.3 },
                { label: 'Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª', data: dailyParticipants, borderColor: 'rgba(75, 192, 192, 1)', backgroundColor: 'rgba(75, 192, 192, 0.2)', fill: true, tension: 0.3 }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: { grid: { display: false } },
                y: { beginAtZero: true, grid: { color: 'rgba(255, 255, 255, 0.05)' } }
            },
            plugins: { legend: { position: 'top' } },
            interaction: { mode: 'index', intersect: false }
        }
    });
}

// --- NEW: Render Balance History Chart ---
async function renderBalanceHistoryChart(agentId, container) {
    // If container is passed as an element (from analytics tab), use it directly.
    // If passed as a parent container (from details tab), create the section.
    let chartCanvas;
    let chartContainerDiv;

    if (container.id === 'balanceHistoryChartContainer') {
        // Called from Analytics Tab
        chartCanvas = container.querySelector('canvas');
        chartContainerDiv = container;
    } else {
        // Called from Details Tab (Legacy/Fallback)
        // Create container for the chart
        const chartSection = document.createElement('div');
        chartSection.className = 'action-section';
        chartSection.style.marginTop = '20px';
        chartSection.innerHTML = `
            <h2><i class="fas fa-chart-line"></i> Ø³Ø¬Ù„ Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ Ø§Ù„Ø±ØµÙŠØ¯</h2>
            <div class="chart-container" style="position: relative; height: 300px; width: 100%;">
                <canvas id="balanceHistoryChartDetails"></canvas>
            </div>
        `;
        container.appendChild(chartSection);
        chartCanvas = chartSection.querySelector('canvas');
        chartContainerDiv = chartSection.querySelector('.chart-container');
    }

    try {
        const response = await authedFetch(`/api/agents/${agentId}/transactions?limit=12`);
        if (!response.ok) throw new Error('Failed to fetch transactions');
        
        const result = await response.json();
        const transactions = result.data || [];

        if (transactions.length === 0) {
            chartContainerDiv.innerHTML = '<p class="no-data-message" style="color:#94a3b8;text-align:center;padding:20px;">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª ÙƒØ§ÙÙŠØ© Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ.</p>';
            return;
        }

        // Process data for chart
        // We want to show the "amount restored" (consumption) over time
        // Sort by date ascending for the chart
        const sortedTx = transactions.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
        
        const labels = sortedTx.map(tx => new Date(tx.createdAt).toLocaleDateString('ar-EG', { month: 'short', day: 'numeric' }));
        const dataPoints = sortedTx.map(tx => tx.amount); // Amount restored = consumption

        new Chart(chartCanvas, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…Ø³ØªÙ‡Ù„Ùƒ ($)',
                    data: dataPoints,
                    backgroundColor: 'rgba(16, 185, 129, 0.6)', // Green to match wallet theme
                    borderColor: 'rgba(16, 185, 129, 1)',
                    borderWidth: 1,
                    borderRadius: 4,
                    barThickness: 20
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(255, 255, 255, 0.05)'
                        },
                        ticks: {
                            color: '#94a3b8',
                            font: { family: 'Cairo' }
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            color: '#94a3b8',
                            font: { family: 'Cairo' }
                        }
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            color: '#e2e8f0',
                            font: {
                                family: 'Cairo'
                            }
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(15, 23, 42, 0.9)',
                        titleColor: '#f1f5f9',
                        bodyColor: '#e2e8f0',
                        borderColor: '#334155',
                        borderWidth: 1,
                        padding: 10,
                        callbacks: {
                            label: function(context) {
                                return `ØªÙ… Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ: $${context.raw}`;
                            }
                        }
                    }
                }
            }
        });

    } catch (error) {
        console.error('Error rendering balance chart:', error);
        chartContainerDiv.innerHTML = '<p class="error-message" style="color:#ef4444;text-align:center;">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ.</p>';
    }
}


// == users.js ==
ï»¿// --- NEW: Handler for presence updates ---
const handlePresenceUpdateForUsersPage = () => {
    if (window.updateUserPresenceIndicators) {
        window.updateUserPresenceIndicators();
    }
};

async function renderUsersPage() {
    // --- NEW: Clean up previous listener and add a new one for this page instance ---
    window.removeEventListener('presence-update', handlePresenceUpdateForUsersPage);
    window.addEventListener('presence-update', handlePresenceUpdateForUsersPage);

    const appContent = document.getElementById('app-content');

    // --- MODIFICATION: Allow both super_admin and admin to access this page ---
    const isSuperAdmin = currentUserProfile?.role === 'super_admin';
    const isAdmin = currentUserProfile?.role === 'admin';
    if (!isSuperAdmin && !isAdmin) {
        appContent.innerHTML = `
            <div class="access-denied-container">
                <i class="fas fa-lock"></i>
                <h2>Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© ÙˆØµÙˆÙ„</h2>
                <p>Ø£Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø¯ÙŠØ±.</p>
            </div>`;
        return;
    }

    // --- MODIFICATION: Only show the "Add User" button if the user has permission (admin or super_admin) ---
    const canAddUser = isSuperAdmin || isAdmin;
    const addUserButtonHtml = canAddUser ? `<button id="add-new-user-btn" class="btn-primary"><i class="fas fa-user-plus"></i> Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯</button>` : '';
    
    // --- NEW: Purge all users button (super_admin only) ---
    const purgeUsersButtonHtml = isSuperAdmin ? `<button id="purge-all-users-btn" class="btn-danger" style="margin-right: 10px;"><i class="fas fa-trash-alt"></i> Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª</button>` : '';

    appContent.innerHTML = `
        <!-- NEW: Stats Cards Section -->
        <div class="dashboard-grid-v2" id="user-stats-container" style="margin-bottom: 20px;">
            <div class="stat-card-v2 color-1"><div class="stat-card-v2-icon-bg"><i class="fas fa-users"></i></div><p id="total-users-stat" class="stat-card-v2-value">0</p><h3 class="stat-card-v2-title">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†</h3></div>
            <div class="stat-card-v2 color-2"><div class="stat-card-v2-icon-bg"><i class="fas fa-user-check"></i></div><p id="active-users-stat" class="stat-card-v2-value">0</p><h3 class="stat-card-v2-title">Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø§Ù„Ù†Ø´Ø·ÙˆÙ†</h3></div>
            <div class="stat-card-v2 color-3"><div class="stat-card-v2-icon-bg"><i class="fas fa-user-shield"></i></div><p id="admin-users-stat" class="stat-card-v2-value">0</p><h3 class="stat-card-v2-title">Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙˆÙ†</h3></div>
            <div class="stat-card-v2 color-4"><div class="stat-card-v2-icon-bg"><i class="fas fa-user-slash"></i></div><p id="inactive-users-stat" class="stat-card-v2-value">0</p><h3 class="stat-card-v2-title">Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø§Ù„Ù…Ø¹Ø·Ù„ÙˆÙ†</h3></div>
        </div>

        <div class="page-header column-header">
            <div class="header-top-row">
                <h1><i class="fas fa-users-cog"></i> Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†</h1>
                <div style="display: flex; gap: 10px;">
                    ${purgeUsersButtonHtml}
                    ${addUserButtonHtml}
                </div>
            </div>
            <div class="filters-container">
                <div class="filter-search-container">
                    <input type="search" id="user-search-input" placeholder="Ø¨Ø­Ø« Ø¨Ø§Ù„Ø§Ø³Ù… Ø£Ùˆ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ..." autocomplete="off">
                    <i class="fas fa-search"></i>
                    <i class="fas fa-times-circle search-clear-btn" id="user-search-clear"></i>
                </div>
                <div class="filter-buttons">
                    <button class="filter-btn active" data-status-filter="all">Ø§Ù„ÙƒÙ„</button>
                    <button class="filter-btn" data-status-filter="active">Ø§Ù„Ù†Ø´Ø·ÙˆÙ†</button>
                    <button class="filter-btn" data-status-filter="inactive">Ø§Ù„Ù…Ø¹Ø·Ù„ÙˆÙ†</button>
                </div>
                <div id="user-count" class="item-count-display"></div>
            </div>
        </div>
        <div id="users-list-container">
            <div class="loader-container"><div class="spinner"></div></div>
        </div>
    `;

    // Add listener for the new user button
    const addUserBtn = document.getElementById('add-new-user-btn');
    if (addUserBtn) {
        addUserBtn.addEventListener('click', renderCreateUserModal);
    }
    
    // Add listener for purge all users button (super_admin only)
    const purgeUsersBtn = document.getElementById('purge-all-users-btn');
    if (purgeUsersBtn) {
        purgeUsersBtn.addEventListener('click', handlePurgeAllUsers);
    }
    
    // Attach event listeners for actions (delete, role change) to the persistent container
    attachUserActionListeners();

    // Attach search listeners
    setupUserPageFilters([]); // Setup with empty array initially

    // NEW: Fetch data asynchronously
    fetchUsersData();
}

async function fetchUsersData() {
    try {
        const response = await authedFetch('/api/users');
        if (!response.ok) {
            const result = await response.json();
            throw new Error(result.message);
        }
        const { users } = await response.json();

        setupUserPageFilters(users); // Re-setup filters with the complete data
    } catch (error) {
        document.getElementById('users-list-container').innerHTML = `<p class="error">ÙØ´Ù„ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: ${error.message}</p>`;
    }
}

function renderUserRow(user) {
    // --- Ø¥ØµÙ„Ø§Ø­: Ø§Ø³ØªØ®Ø¯Ø§Ù… _id Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† id ---
    const isCurrentUser = currentUserProfile && user._id === currentUserProfile.userId;
    const isTargetAdmin = user.role === 'admin';
    const isCurrentUserAdmin = currentUserProfile?.role === 'admin';
    const isCurrentUserSuperAdmin = currentUserProfile?.role === 'super_admin';
    const isTargetSuperAdmin = user.role === 'super_admin'; // Ù†Ø­ØªÙØ¸ Ø¨Ù‡Ø°Ø§ ÙÙ‚Ø· Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø´Ø§Ø±Ø©

    // --- Ø¥ØµÙ„Ø§Ø­: ØªØ¹Ø±ÙŠÙ Ù…ØªØºÙŠØ± Ø§Ù„Ø­Ø§Ù„Ø© ÙÙŠ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø¯Ø§Ù„Ø© Ù„ØªØ¬Ù†Ø¨ Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ÙˆØµÙˆÙ„ ---
    const isInactive = user.status === 'inactive';

    // --- Ø¥ØµÙ„Ø§Ø­: Ø§Ø³ØªØ®Ø¯Ø§Ù… updatedAt ÙƒØ¨Ø¯ÙŠÙ„ Ù…Ø¤Ù‚Øª Ù„Ø¢Ø®Ø± ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ ---
    const lastLogin = user.updatedAt 
        ? new Date(user.updatedAt).toLocaleString('ar-EG', { dateStyle: 'medium', timeStyle: 'short' })
        : 'Ù„Ù… ÙŠØ³Ø¬Ù„ Ø¯Ø®ÙˆÙ„';

    const avatarName = encodeURIComponent(user.full_name || user.email || 'User');
    const avatarHtml = user.avatar_url
        ? `<img src="${user.avatar_url}" alt="Avatar" class="avatar-small" loading="lazy">`
        : `<img src="https://ui-avatars.com/api/?name=${avatarName}&background=8A2BE2&color=fff" alt="Avatar" class="avatar-small" loading="lazy">`;

    // NEW: Add a crown icon for admins
    const adminIconHtml = isTargetSuperAdmin ? '<div class="admin-crown-icon super-admin" title="Ù…Ø¯ÙŠØ± Ø¹Ø§Ù…"><i class="fas fa-gem"></i></div>' : (isTargetAdmin ? '<div class="admin-crown-icon" title="Ù…Ø³Ø¤ÙˆÙ„"><i class="fas fa-crown"></i></div>' : '');
    // NEW: Add a badge for admins
    const adminBadgeHtml = isTargetSuperAdmin ? '<span class="admin-badge super-admin">Ù…Ø¯ÙŠØ± Ø¹Ø§Ù…</span>' : (isTargetAdmin ? '<span class="admin-badge">Ù…Ø³Ø¤ÙˆÙ„</span>' : null);
    // NEW: Add a badge for employees
    const employeeBadgeHtml = user.role === 'employee' ? '<span class="employee-badge">Ù…ÙˆØ¸Ù</span>' : '';

    // NEW: Add status badge and styles for inactive users
    const statusBadgeHtml = isInactive ? '<span class="status-badge inactive">Ù…Ø¹Ø·Ù„</span>' : '';
    
    // NEW: Realtime presence indicator
    const onlineIndicatorHtml = `<div class="online-status-indicator" id="online-status-${user._id}" title="ØºÙŠØ± Ù…ØªØµÙ„"></div>`;

    return `
        <tr data-user-id="${user._id}" data-user-name="${user.full_name || 'Ù…Ø³ØªØ®Ø¯Ù…'}" data-user-email="${user.email || ''}" class="${isInactive ? 'inactive-row' : ''}">
            <td data-label="Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…">
                <div class="table-user-cell">
                    <div class="user-avatar-container">
                        ${onlineIndicatorHtml}
                        ${avatarHtml}
                        ${adminIconHtml}
                    </div>
                    <div class="user-details">
                        <span class="user-name">${user.full_name || '<em>Ù„Ù… ÙŠØ­Ø¯Ø¯</em>'} ${adminBadgeHtml || employeeBadgeHtml} ${statusBadgeHtml}</span>
                        <span class="user-email">${user.email || '<em>ØºÙŠØ± Ù…ØªÙˆÙØ±</em>'}</span>
                    </div>
                </div>
            </td>
            <td data-label="Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©">
                ${(() => {
                    // --- ØªØ¹Ø¯ÙŠÙ„: ÙÙ‚Ø· Ø§Ù„Ù…Ø¯ÙŠØ± Ø§Ù„Ø¹Ø§Ù… ÙŠÙ…ÙƒÙ†Ù‡ ØªØºÙŠÙŠØ± Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª ---
                    const canChangeRoles = isCurrentUserSuperAdmin;
                    const roleSelectDisabled = isCurrentUser || !canChangeRoles; // Ø§Ù„Ù…Ø¯ÙŠØ± Ø§Ù„Ø¹Ø§Ù… ÙŠÙ…ÙƒÙ†Ù‡ ØªØºÙŠÙŠØ± ØµÙ„Ø§Ø­ÙŠØ© Ø£ÙŠ Ø´Ø®Øµ Ø¥Ù„Ø§ Ù†ÙØ³Ù‡
                    const roleSelectTitle = canChangeRoles ? 'ØªØºÙŠÙŠØ± Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©' : 'ÙÙ‚Ø· Ø§Ù„Ù…Ø¯ÙŠØ± Ø§Ù„Ø¹Ø§Ù… ÙŠÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ØªØºÙŠÙŠØ±';

                    if (isTargetSuperAdmin) {
                        return `<span class="role-display super-admin" title="Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØºÙŠÙŠØ± ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù…Ø¯ÙŠØ± Ø§Ù„Ø¹Ø§Ù…">Ù…Ø¯ÙŠØ± Ø¹Ø§Ù…</span>`;
                    }
                    return `<select class="role-select" data-user-id="${user._id}" ${roleSelectDisabled ? 'disabled' : ''} title="${roleSelectTitle}">
                        <option value="employee" ${user.role === 'employee' ? 'selected' : ''}>Ù…ÙˆØ¸Ù</option>
                        <option value="admin" ${user.role === 'admin' ? 'selected' : ''}>Ù…Ø³Ø¤ÙˆÙ„</option>
                    </select>`;
                })()}
            </td>
            <td data-label="Ø¢Ø®Ø± ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„">${lastLogin}</td>
            ${(() => {
                const isAdmin = isCurrentUserAdmin || isCurrentUserSuperAdmin;
                if (!isAdmin) return ''; // Ù„Ø§ ØªØ¹Ø±Ø¶ Ø¹Ù…ÙˆØ¯ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ù„ØºÙŠØ± Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ†

                // --- ØªØ¹Ø¯ÙŠÙ„: Ø¹Ø±Ø¶ Ø®Ù„ÙŠØ© ÙØ§Ø±ØºØ© Ù„Ù„Ù…Ø¯ÙŠØ± Ø§Ù„Ø¹Ø§Ù… Ù„Ù…Ù†Ø¹ Ø£ÙŠ Ø¥Ø¬Ø±Ø§Ø¡ ---
                // --- NEW: Admins cannot edit other admins or super admins ---
                if (isTargetSuperAdmin || (isCurrentUserAdmin && isTargetAdmin)) {
                    return `<td class="actions-cell"><span class="no-actions-text">${isCurrentUserSuperAdmin ? 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ¹Ø¯ÙŠÙ„' : 'ØµÙ„Ø§Ø­ÙŠØ© Ù„Ù„Ù…Ø¯ÙŠØ± Ø§Ù„Ø¹Ø§Ù…'}</span></td>`;
                }

                // Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø¹Ø§Ø¯ÙŠÙŠÙ† ÙˆØ§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ† Ø§Ù„Ø¢Ø®Ø±ÙŠÙ†
                return `<td class="actions-cell">
                    <button class="btn-secondary edit-user-btn" data-user-id="${user._id}" title="ØªØ¹Ø¯ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"><i class="fas fa-edit"></i></button>
                    ${/* --- MODIFICATION: Allow admins to manage permissions for users, but not other admins. --- */ ''}
                    <button class="btn-primary permissions-user-btn" data-user-id="${user._id}" title="Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª" 
                        ${(isCurrentUserAdmin && isTargetAdmin) || (!isCurrentUserSuperAdmin && !isCurrentUserAdmin) ? 'disabled' : ''}>
                        <i class="fas fa-shield-alt"></i></button>
                    ${/* --- MODIFICATION: Allow admins to delete users, but not other admins. Super admins can delete anyone except themselves. --- */ ''}
                    <button class="btn-danger delete-user-btn" data-user-id="${user._id}" title="Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹" 
                        ${(isCurrentUserAdmin && isTargetAdmin) || !isCurrentUserSuperAdmin && !isCurrentUserAdmin ? 'disabled' : ''}>
                        <i class="fas fa-trash-alt"></i></button>
                    <label class="custom-checkbox toggle-switch small-toggle" title="${isInactive ? 'ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨' : 'ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨'}" ${!isCurrentUserSuperAdmin ? 'style="display:none;"' : ''}>
                        <input type="checkbox" class="status-toggle" data-user-id="${user._id}" ${!isInactive ? 'checked' : ''}><span class="slider round"></span>
                    </label>
                </td>`;
            })()}
        </tr>
    `;
}

let allUsersCache = []; // Cache for user data
function setupUserPageFilters(allUsers) {
    const searchInput = document.getElementById('user-search-input');
    const clearBtn = document.getElementById('user-search-clear');
    const userCountEl = document.getElementById('user-count');
    const statusFilterButtons = document.querySelectorAll('.filter-buttons .filter-btn');
    const container = document.getElementById('users-list-container'); // The persistent container

    if (!searchInput || !container) return;
    allUsersCache = allUsers; // Store users in cache

    // --- Ø¥ØµÙ„Ø§Ø­: ØªØ¹Ø±ÙŠÙ Ù…ØªØºÙŠØ± ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù…Ø¯ÙŠØ± Ø§Ù„Ø¹Ø§Ù… ÙÙŠ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„ØµØ­ÙŠØ­ ---
    const isCurrentUserSuperAdmin = currentUserProfile?.role === 'super_admin';
    const isCurrentUserAdmin = currentUserProfile?.role === 'admin';

    const applyFilters = () => {
        if (clearBtn) {
            clearBtn.style.display = searchInput.value ? 'block' : 'none';
        }

        const searchTerm = searchInput.value.toLowerCase().trim();
        const activeStatusFilter = document.querySelector('.filter-buttons .filter-btn.active').dataset.statusFilter;

        const filteredUsers = allUsers.filter(user => {
            const name = (user.full_name || '').toLowerCase();
            const email = (user.email || '').toLowerCase();
            const matchesSearch = name.includes(searchTerm) || email.includes(searchTerm);
            const matchesStatus = activeStatusFilter === 'all' || (user.status || 'active') === activeStatusFilter;
            return matchesSearch && matchesStatus;
        });

        // Re-render the table with filtered users
        if (filteredUsers.length === 0) {
            container.innerHTML = '<p class="no-results-message">Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† ÙŠØ·Ø§Ø¨Ù‚ÙˆÙ† Ø¨Ø­Ø«Ùƒ.</p>';
        } else {
            container.innerHTML = `
                <div class="table-responsive-container">
                    <table class="modern-table">
                        <thead>
                            <tr>
                            <th class="user-column">Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…</th>
                                <th>Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©</th>
                                <th>Ø¢Ø®Ø± ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„</th>
                                ${isCurrentUserSuperAdmin || isCurrentUserAdmin ? '<th class="actions-column">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</th>' : ''}
                            </tr>
                        </thead>
                        <tbody>
                            ${filteredUsers.map(user => renderUserRow(user)).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }
        
        // Update user count
        if (userCountEl) {
            userCountEl.textContent = `Ø¥Ø¬Ù…Ø§Ù„ÙŠ: ${filteredUsers.length} Ù…Ø³ØªØ®Ø¯Ù…`;
        }

        // NEW: Update stats cards based on the full user list
        document.getElementById('total-users-stat').textContent = formatNumber(allUsers.length);
        document.getElementById('active-users-stat').textContent = formatNumber(allUsers.filter(u => u.status !== 'inactive').length);
        document.getElementById('admin-users-stat').textContent = formatNumber(allUsers.filter(u => u.role === 'admin').length);
        document.getElementById('inactive-users-stat').textContent = formatNumber(allUsers.filter(u => u.status === 'inactive').length);

    };

    searchInput.addEventListener('input', applyFilters);

    if (clearBtn) {
        clearBtn.addEventListener('click', () => {
            searchInput.value = '';
            applyFilters();
            searchInput.focus();
        });
    }

    if (statusFilterButtons.length) {
        statusFilterButtons.forEach(button => {
            button.addEventListener('click', () => {
                statusFilterButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                applyFilters();
            });
        });
    }

    // Initial call to set up the count and table
    applyFilters();

    // NEW: Function to update online status indicators on the page
    window.updateUserPresenceIndicators = () => {
        if (!window.onlineUsers) return;
        allUsersCache.forEach(user => {
            const indicator = document.getElementById(`online-status-${user._id}`);
            if (indicator) {
                if (window.onlineUsers.has(user._id)) {
                    indicator.classList.add('online');
                    indicator.title = 'Ù…ØªØµÙ„ Ø§Ù„Ø¢Ù†';
                } else {
                    indicator.classList.remove('online');
                    indicator.title = 'ØºÙŠØ± Ù…ØªØµÙ„';
                }
            }
        });
    };
    window.updateUserPresenceIndicators(); // Initial update
}

function attachUserActionListeners() {
    const container = document.getElementById('users-list-container');

    container.addEventListener('click', async (e) => {
        const deleteBtn = e.target.closest('.delete-user-btn');
        const editBtn = e.target.closest('.edit-user-btn');
        const permissionsBtn = e.target.closest('.permissions-user-btn');

        if (editBtn && !editBtn.disabled) {
            const userId = editBtn.dataset.userId;
            const userToEdit = allUsersCache.find(u => u._id === userId);
            if (userToEdit) renderEditUserModal(userToEdit);
        }

        if (permissionsBtn && !permissionsBtn.disabled) {
            const userId = permissionsBtn.dataset.userId;
            const userToManage = allUsersCache.find(u => u._id === userId);
            if (userToManage) renderPermissionsModal(userToManage);
        }

        if (deleteBtn && !deleteBtn.disabled) {
            const userId = deleteBtn.dataset.userId;
            const row = deleteBtn.closest('tr');
            const userName = row.dataset.userName;

            showConfirmationModal(
                `Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… "<strong>${userName}</strong>"ØŸ<br><small>Ø³ÙŠØªÙ… Ø­Ø°ÙÙ‡ Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„Ù†Ø¸Ø§Ù… ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡.</small>`,
                async () => {
                    try {
                        const response = await authedFetch(`/api/users/${userId}`, { method: 'DELETE' });
                        if (!response.ok) {
                            const result = await response.json();
                            throw new Error(result.message);
                        }
                        showToast('ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                        await fetchUsersData(); // Refresh list to show changes
                    } catch (error) {
                        showToast(`ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${error.message}`, 'error');
                    }
                },
                { title: 'ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ', confirmText: 'Ø­Ø°Ù', confirmClass: 'btn-danger' }
            );
        }
    });

    container.addEventListener('change', async (e) => {
        const roleSelect = e.target.closest('.role-select');
        if (roleSelect && !roleSelect.disabled) {
            const userId = roleSelect.dataset.userId;
            const newRole = roleSelect.value;
            const originalRole = allUsersCache.find(u => u._id === userId)?.role;

            try {
                const response = await authedFetch(`/api/users/${userId}/role`, {
                    method: 'PUT',
                    body: JSON.stringify({ role: newRole })
                });
                if (!response.ok) {
                    const result = await response.json();
                    throw new Error(result.message);
                }

                showToast('ØªÙ… ØªØ­Ø¯ÙŠØ« ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                // NEW: Notify the user whose role was changed in real-time
                // This requires a WebSocket setup to be effective.
                notifyUserOfRoleChange(userId, newRole);
            } catch (error) {
                showToast(`ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©: ${error.message}`, 'error');
                // Revert the select box to the previous value on error without a full page reload
                if (originalRole) {
                    roleSelect.value = originalRole;
                }
            }
        }

        // NEW: Handle status toggle change
        const statusToggle = e.target.closest('.status-toggle');
        if (statusToggle && !statusToggle.disabled) {
            const userId = statusToggle.dataset.userId;
            const newStatus = statusToggle.checked ? 'active' : 'inactive';

            try {
                const response = await authedFetch(`/api/users/${userId}`, {
                    method: 'PUT',
                    body: JSON.stringify({ status: newStatus }) // Send status update to backend
                });
                const result = await response.json();
                if (!response.ok) throw new Error(result.message);

                showToast(`ØªÙ… ${newStatus === 'active' ? 'ØªÙØ¹ÙŠÙ„' : 'ØªØ¹Ø·ÙŠÙ„'} Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù….`, 'success');
                await fetchUsersData(); // Refresh list to show changes
            } catch (error) {
                showToast(`ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø©: ${error.message}`, 'error');
                statusToggle.checked = !statusToggle.checked; // Revert on error
            }
        }
    });
}

/**
 * NEW: Notifies a specific user that their role has been changed.
 * This function should send a message via WebSocket to the server,
 * which then relays it to the target user.
 * @param {string} userId The ID of the user to notify.
 * @param {string} newRole The new role assigned to the user.
 */
function notifyUserOfRoleChange(userId, newRole) {
    // This is a placeholder for a real WebSocket implementation.
    // In a real app, you would have a global WebSocket instance, e.g., `socket`.
    // if (socket && socket.readyState === WebSocket.OPEN) {
    //     socket.send(JSON.stringify({
    //         type: 'role_change',
    //         payload: {
    //             targetUserId: userId,
    //             newRole: newRole
    //         }
    //     }));
    // }

    // For now, we can simulate this by logging to the console.
    console.log(`[SIMULATION] Notifying user ${userId} of role change to ${newRole}. This would be sent via WebSocket.`);
}

function renderCreateUserModal() {
    // --- NEW: Professional Create User Modal ---
    const overlay = document.createElement('div');
    const isSuperAdmin = currentUserProfile?.role === 'super_admin';

    overlay.className = 'modal-overlay';
    
    const modal = document.createElement('div');
    modal.className = 'form-modal-content modal-wide';
    
    modal.innerHTML = `
        <div class="form-modal-header">
            <h2><i class="fas fa-user-plus"></i> Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯</h2>
            <button id="close-modal-btn" class="btn-icon-action" title="Ø¥ØºÙ„Ø§Ù‚">&times;</button>
        </div>
        <div class="form-modal-body">
            <form id="create-user-form" class="form-layout-grid">
                <!-- Avatar Section -->
                <div class="form-grid-avatar">
                    <div class="profile-avatar-edit large-avatar">
                        <img src="https://ui-avatars.com/api/?name=?&background=8A2BE2&color=fff&size=128" alt="Avatar" id="avatar-preview">
                        <input type="file" id="avatar-upload" accept="image/*" style="display: none;">
                    </div>
                    <!-- NEW: Action buttons for avatar moved outside -->
                    <div class="avatar-action-buttons" id="avatar-action-buttons" style="display: none;">
                        <button type="button" id="change-avatar-btn" class="btn-secondary btn-small"><i class="fas fa-edit"></i> ØªØºÙŠÙŠØ±</button>
                        <button type="button" id="delete-avatar-btn" class="btn-danger btn-small"><i class="fas fa-trash"></i> Ø­Ø°Ù</button>
                    </div>
                </div>
                <!-- Fields Section -->
                <div class="form-grid-fields">
                    <div class="form-group">
                        <label for="new-user-fullname">Ø§Ù„Ø§Ø³Ù… Ø§Ù„ÙƒØ§Ù…Ù„</label>
                        <input type="text" id="new-user-fullname" required>
                    </div>
                    <div class="form-group">
                        <label for="new-user-email">Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ</label>
                        <input type="email" id="new-user-email" required>
                    </div>
                    <div class="form-group">
                        <label for="new-user-password">ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±</label>
                        <div class="password-input-wrapper">
                            <input type="password" id="new-user-password" required minlength="8">
                            <button type="button" id="password-toggle-btn" class="password-toggle-btn" title="Ø¥Ø¸Ù‡Ø§Ø±/Ø¥Ø®ÙØ§Ø¡ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±"><i class="fas fa-eye"></i></button>
                        </div>
                        <div class="password-strength-meter">
                            <div class="strength-bar"></div>
                        </div>
                        <div class="password-actions">
                            <button type="button" id="generate-password-btn" class="btn-secondary btn-small">Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± Ù‚ÙˆÙŠØ©</button>
                        </div>
                    </div>
                    ${isSuperAdmin ? `
                        <div class="form-group">
                            <label for="new-user-role">Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©</label>
                            <select id="new-user-role">
                                <option value="employee" selected>Ù…ÙˆØ¸Ù</option>
                                <option value="admin">Ù…Ø³Ø¤ÙˆÙ„</option>
                            </select>
                        </div>
                    ` : '<input type="hidden" id="new-user-role" value="employee">'
                    }
                </div>
                <!-- Actions Section -->
                <div class="form-grid-actions">
                    <button type="submit" id="create-user-submit-btn" class="btn-primary">
                        <i class="fas fa-check"></i> Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
                    </button>
                    <button type="button" id="cancel-create-modal" class="btn-secondary">Ø¥Ù„ØºØ§Ø¡</button>
                </div>
            </form>
        </div>
    `;
    
    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    const closeModal = () => overlay.remove();
    modal.querySelector('#close-modal-btn').addEventListener('click', closeModal);
    modal.querySelector('#cancel-create-modal').addEventListener('click', closeModal);

    // --- NEW: Add logic for password features ---
    const passwordInput = modal.querySelector('#new-user-password');
    const passwordToggleBtn = modal.querySelector('#password-toggle-btn');
    const generatePasswordBtn = modal.querySelector('#generate-password-btn');
    const strengthBar = modal.querySelector('.strength-bar');

    passwordToggleBtn.addEventListener('click', () => {
        const isPassword = passwordInput.type === 'password';
        passwordInput.type = isPassword ? 'text' : 'password';
        passwordToggleBtn.querySelector('i').className = `fas ${isPassword ? 'fa-eye-slash' : 'fa-eye'}`;
    });

    passwordInput.addEventListener('input', () => {
        const password = passwordInput.value;
        let strength = 0;
        if (password.length >= 8) strength++;
        if (password.match(/[a-z]/) && password.match(/[A-Z]/)) strength++;
        if (password.match(/\d/)) strength++;
        if (password.match(/[^a-zA-Z\d]/)) strength++;
        
        strengthBar.className = 'strength-bar';
        if (strength > 0) strengthBar.classList.add(`strength-${strength}`);
    });

    generatePasswordBtn.addEventListener('click', () => {
        // --- NEW: Guaranteed strong password generation ---
        const lower = 'abcdefghijklmnopqrstuvwxyz';
        const upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const numbers = '0123456789';
        const symbols = '!@#$%^&*()_+-=[]{}|;:,.<>?';
        const all = lower + upper + numbers + symbols;

        let newPassword = '';
        // Ensure at least one of each type
        newPassword += lower.charAt(Math.floor(Math.random() * lower.length));
        newPassword += upper.charAt(Math.floor(Math.random() * upper.length));
        newPassword += numbers.charAt(Math.floor(Math.random() * numbers.length));
        newPassword += symbols.charAt(Math.floor(Math.random() * symbols.length));

        // Fill the rest of the password
        for (let i = newPassword.length; i < 14; i++) {
            newPassword += all.charAt(Math.floor(Math.random() * all.length));
        }

        // Shuffle the password to make it random
        newPassword = newPassword.split('').sort(() => 0.5 - Math.random()).join('');

        passwordInput.value = newPassword;
        passwordInput.dispatchEvent(new Event('input')); // Trigger strength check
        navigator.clipboard.writeText(newPassword).then(() => {
            showToast('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ÙˆÙ†Ø³Ø® ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± Ù‚ÙˆÙŠØ©.', 'success');
        });
    });

    // Avatar preview logic
    const avatarUploadInput = modal.querySelector('#avatar-upload');
    const avatarPreview = modal.querySelector('#avatar-preview');
    const avatarActions = modal.querySelector('#avatar-action-buttons');
    const changeAvatarBtn = modal.querySelector('#change-avatar-btn');
    const deleteAvatarBtn = modal.querySelector('#delete-avatar-btn');

    // NEW: Allow clicking the entire avatar container (including the camera icon overlay) to trigger file upload
    const openFileDialog = () => avatarUploadInput.click();
    avatarPreview.closest('.profile-avatar-edit').addEventListener('click', openFileDialog);
    changeAvatarBtn.addEventListener('click', openFileDialog);

    deleteAvatarBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent re-opening the file dialog
        avatarUploadInput.value = null; // Clear the file input
        avatarPreview.src = 'https://ui-avatars.com/api/?name=?&background=8A2BE2&color=fff&size=128';
        avatarActions.style.display = 'none';
    });

    avatarUploadInput.addEventListener('change', () => {
        const file = avatarUploadInput.files[0];
        if (file) {
            avatarPreview.src = URL.createObjectURL(file);
            avatarActions.style.display = 'flex';
        }
        avatarUploadInput.click();
    });

    // Form submission logic
    modal.querySelector('#create-user-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const submitBtn = modal.querySelector('#create-user-submit-btn');
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡...';

        const newUser = {
            full_name: modal.querySelector('#new-user-fullname').value,
            email: modal.querySelector('#new-user-email').value,
            password: modal.querySelector('#new-user-password').value,
            role: modal.querySelector('#new-user-role').value,
        };

        try {
            const response = await authedFetch('/api/users', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(newUser),
            });
            const result = await response.json();
            if (!response.ok || !result.user) throw new Error(result.message || 'ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù….');

            // Avatar upload logic will be implemented later

            showToast('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­.', 'success');
            closeModal();
            await fetchUsersData();
        } catch (error) {
            showToast(`ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${error.message}`, 'error');
            submitBtn.disabled = false;
            submitBtn.innerHTML = '<i class="fas fa-check"></i> Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…';
        }
    });
}

function renderEditUserModal(user) {
    // --- NEW: Professional Edit User Modal ---
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    
    const modal = document.createElement('div');
    modal.className = 'form-modal-content modal-wide';
    
    const originalAvatarUrl = user.avatar_url || `https://ui-avatars.com/api/?name=${user.full_name || user.email}&background=8A2BE2&color=fff&size=128`;
    const isCurrentUserSuperAdmin = currentUserProfile?.role === 'super_admin';
    const isSelf = (currentUserProfile?._id === user._id) || (currentUserProfile?.userId === user._id);
    const canEditAvatar = isCurrentUserSuperAdmin || isSelf;

    modal.innerHTML = `
        <div class="form-modal-header">
            <h2><i class="fas fa-user-edit"></i> ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${user.full_name}</h2>
            <button id="close-modal-btn" class="btn-icon-action" title="Ø¥ØºÙ„Ø§Ù‚">&times;</button>
        </div>
        <div class="form-modal-body">
            <form id="edit-user-form" class="form-layout-grid">
                <!-- Avatar Section -->
                <div class="form-grid-avatar">
                    <div class="profile-avatar-edit large-avatar">
                        <img src="${originalAvatarUrl}" alt="Avatar" id="avatar-preview">
                        <input type="file" id="avatar-upload" accept="image/*" style="display: none;">
                    </div>
                    <!-- NEW: Action buttons for avatar moved outside -->
                    <div class="avatar-action-buttons" id="avatar-action-buttons" style="display: none;">
                        <button type="button" id="change-avatar-btn" class="btn-secondary btn-small"><i class="fas fa-edit"></i> ØªØºÙŠÙŠØ±</button>
                        <button type="button" id="delete-avatar-btn" class="btn-danger btn-small"><i class="fas fa-trash"></i> Ø­Ø°Ù</button>
                    </div>
                </div>
                <!-- Fields Section -->
                <div class="form-grid-fields">
                    <div class="form-group">
                        <label for="edit-user-fullname">Ø§Ù„Ø§Ø³Ù… Ø§Ù„ÙƒØ§Ù…Ù„</label>
                        <input type="text" id="edit-user-fullname" value="${user.full_name || ''}" required>
                    </div>
                    <div class="form-group">
                        <label for="edit-user-email">Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ</label>
                        <input type="email" id="edit-user-email" value="${user.email || ''}" disabled>
                    </div>
                    <div class="form-group">
                        <label for="edit-user-password">ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©</label>
                        <input type="password" id="edit-user-password" minlength="8" placeholder="${isCurrentUserSuperAdmin ? 'Ø§ØªØ±ÙƒÙ‡ ÙØ§Ø±ØºØ§Ù‹ Ù„Ø¹Ø¯Ù… Ø§Ù„ØªØºÙŠÙŠØ±' : 'Ø§Ù„Ø³ÙˆØ¨Ø± Ø£Ø¯Ù…Ù† ÙÙ‚Ø·'}" ${isCurrentUserSuperAdmin ? '' : 'disabled'}>
                    </div>
                </div>
                <!-- Actions Section -->
                <div class="form-grid-actions">
                    <button type="submit" id="edit-user-submit-btn" class="btn-primary">
                        <i class="fas fa-save"></i> Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª
                    </button>
                    <button type="button" id="cancel-edit-modal" class="btn-secondary">Ø¥Ù„ØºØ§Ø¡</button>
                </div>
            </form>
        </div>
    `;
    
    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    const closeModal = () => overlay.remove();
    modal.querySelector('#close-modal-btn').addEventListener('click', closeModal);
    modal.querySelector('#cancel-edit-modal').addEventListener('click', closeModal);

    // --- Avatar Logic ---
    const avatarUploadInput = modal.querySelector('#avatar-upload');
    const avatarPreview = modal.querySelector('#avatar-preview');
    const avatarActions = modal.querySelector('#avatar-action-buttons');
    const changeAvatarBtn = modal.querySelector('#change-avatar-btn');
    const deleteAvatarBtn = modal.querySelector('#delete-avatar-btn');

    const openFileDialog = (e) => {
        e.stopPropagation(); // Prevent event bubbling if needed
        avatarUploadInput.click();
    };
    if (canEditAvatar) {
        // Allow clicking the entire avatar container to open the file dialog
        avatarPreview.closest('.profile-avatar-edit').addEventListener('click', openFileDialog);
        changeAvatarBtn.addEventListener('click', openFileDialog);

        deleteAvatarBtn.addEventListener('click', () => {
            avatarUploadInput.value = null; // Clear the file input
            avatarPreview.src = originalAvatarUrl;
            avatarActions.style.display = 'none';
        });

        avatarUploadInput.addEventListener('change', () => {
            const file = avatarUploadInput.files[0];
            if (file) {
                avatarPreview.src = URL.createObjectURL(file);
                avatarActions.style.display = 'flex';
            }
        });
    } else {
        // Hide actions and disable click for non-super-admin editors
        avatarActions.style.display = 'none';
        avatarPreview.closest('.profile-avatar-edit').style.cursor = 'not-allowed';
    }

    // --- Form Submission Logic ---
    modal.querySelector('#edit-user-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const submitBtn = modal.querySelector('#edit-user-submit-btn');
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...';

        try {
            const avatarFile = modal.querySelector('#avatar-upload').files[0];
            if (avatarFile && canEditAvatar) {
                const formData = new FormData();
                formData.append('avatar', avatarFile);

                const avatarResponse = await authedFetch(`/api/users/${user._id}/avatar`, {
                    method: 'POST',
                    body: formData
                });
                if (!avatarResponse.ok) {
                    throw new Error('ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø±Ù…Ø²ÙŠØ©.');
                }
            }

            const userData = {
                full_name: modal.querySelector('#edit-user-fullname').value,
            };
            if (isCurrentUserSuperAdmin) {
                const newPwd = modal.querySelector('#edit-user-password').value;
                if (newPwd) {
                    userData.password = newPwd;
                }
            }

            // Send other user data update request
            const response = await authedFetch(`/api/users/${user._id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(userData)
            });
            if (!response.ok) throw new Error((await response.json()).message);

            showToast('ØªÙ… ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­.', 'success');
            closeModal();
            await fetchUsersData(); // Refresh the user list
        } catch (error) {
            showToast(`ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${error.message}`, 'error');
            submitBtn.disabled = false;
            submitBtn.innerHTML = '<i class="fas fa-save"></i> Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª';
        }
    });
}

function renderPermissionsModal(user) {
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    
    const modal = document.createElement('div');
    modal.className = 'form-modal-content modal-fullscreen'; // ØªØ¹Ø¯ÙŠÙ„: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø­Ø¬Ù… Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø©
    
    const p = user.permissions || {}; // Short alias for permissions
    // Set defaults for any missing permission structures
    p.agents = p.agents || { view_financials: false, edit_profile: false, edit_financials: false, can_view_competitions_tab: false, can_renew_all_balances: false };
    p.competitions = p.competitions || { manage_comps: 'none', manage_templates: 'none', can_create: false };

    modal.innerHTML = `
        <div class="form-modal-header">
            <h2><i class="fas fa-shield-alt"></i> Ø¥Ø¯Ø§Ø±Ø© ØµÙ„Ø§Ø­ÙŠØ§Øª: ${user.full_name} ${user.role === 'super_admin' ? '<span class="admin-badge super-admin" style="font-size: 1rem; vertical-align: middle; margin-right: 10px;">Ù…Ø¯ÙŠØ± Ø¹Ø§Ù…</span>' : ''}</h2>
            <button id="close-modal-btn" class="btn-icon-action" title="Ø¥ØºÙ„Ø§Ù‚">&times;</button>
        </div>
        <div class="form-modal-body" ${user.role === 'super_admin' ? 'style="pointer-events: none; opacity: 0.7;"' : ''}>
            <form id="permissions-form">
                <div class="table-responsive-container">
                    <table class="permissions-table">
                        <thead>
                            <tr>
                                <th>Ø§Ù„Ù‚Ø³Ù…</th>
                                <th>Ø¨Ø¯ÙˆÙ† ØµÙ„Ø§Ø­ÙŠØ©</th>
                                <th>Ù…Ø´Ø§Ù‡Ø¯Ø© ÙÙ‚Ø·</th>
                                <th>ØªØ­ÙƒÙ… ÙƒØ§Ù…Ù„</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="permission-name">
                                    <i class="fas fa-trophy"></i>
                                    <strong>Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª</strong>
                                    <small>Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø¹Ø±Ø¶ ÙˆØªØ¹Ø¯ÙŠÙ„ ÙˆØ­Ø°Ù Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª.</small>
                                </td>
                                <td><label class="custom-radio"><input type="radio" name="perm_manage_comps" value="none" ${p.competitions.manage_comps === 'none' || !p.competitions.manage_comps || user.role === 'super_admin' ? 'checked' : ''}><span></span></label></td>
                                <td><label class="custom-radio"><input type="radio" name="perm_manage_comps" value="view" ${p.competitions.manage_comps === 'view' && user.role !== 'super_admin' ? 'checked' : ''}><span></span></label></td>
                                <td><label class="custom-radio"><input type="radio" name="perm_manage_comps" value="full" ${p.competitions.manage_comps === 'full' || user.role === 'super_admin' ? 'checked' : ''}><span></span></label></td>
                            </tr>
                            <tr>
                                <td class="permission-name">
                                    <i class="fas fa-file-alt"></i>
                                    <strong>Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨</strong>
                                    <small>Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø¹Ø±Ø¶ ÙˆØªØ¹Ø¯ÙŠÙ„ ÙˆØ­Ø°Ù Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª.</small>
                                </td>
                                <td><label class="custom-radio"><input type="radio" name="perm_manage_templates" value="none" ${p.competitions.manage_templates === 'none' || !p.competitions.manage_templates || user.role === 'super_admin' ? 'checked' : ''}><span></span></label></td>
                                <td><label class="custom-radio"><input type="radio" name="perm_manage_templates" value="view" ${p.competitions.manage_templates === 'view' && user.role !== 'super_admin' ? 'checked' : ''}><span></span></label></td>
                                <td><label class="custom-radio"><input type="radio" name="perm_manage_templates" value="full" ${p.competitions.manage_templates === 'full' || user.role === 'super_admin' ? 'checked' : ''}><span></span></label></td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="permissions-table" style="margin-top: 20px;">
                         <thead>
                            <tr>
                                <th>ØµÙ„Ø§Ø­ÙŠØ§Øª Ø®Ø§ØµØ©</th>
                                <th>ØªÙØ¹ÙŠÙ„ / Ø¥Ù„ØºØ§Ø¡</th>
                            </tr>
                        </thead>
                        <tbody>
                             <tr>
                                <td class="permission-name">
                                    <i class="fas fa-sync-alt"></i>
                                    <strong>ØªØ¬Ø¯ÙŠØ¯ Ø±ØµÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡</strong>
                                    <small>Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù…ÙˆØ¸Ù Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø²Ø± "ØªØ¬Ø¯ÙŠØ¯ Ø±ØµÙŠØ¯ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡" ÙÙŠ ØµÙØ­Ø© Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡.</small>
                                </td>
                                <td><label class="custom-checkbox toggle-switch"><input type="checkbox" id="perm-agents-renew-all" ${p.agents.can_renew_all_balances || user.role === 'super_admin' ? 'checked' : ''}><span class="slider round"></span></label></td>
                            </tr>
                             <tr>
                                <td class="permission-name">
                                    <i class="fas fa-magic"></i>
                                    <strong>Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù„Ù„ÙˆÙƒÙŠÙ„</strong>
                                    <small>Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù…ÙˆØ¸Ù Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„ÙˆÙƒÙ„Ø§Ø¡.</small>
                                </td>
                                <td><label class="custom-checkbox toggle-switch"><input type="checkbox" id="perm-competitions-can-create" ${p.competitions.can_create || user.role === 'super_admin' ? 'checked' : ''}><span class="slider round"></span></label></td>
                            </tr>
                            <tr>
                                <td class="permission-name">
                                    <i class="fas fa-list-alt"></i>
                                    <strong>Ø¹Ø±Ø¶ ØªØ¨ÙˆÙŠØ¨ Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„</strong>
                                    <small>Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù…ÙˆØ¸Ù Ø¨Ø±Ø¤ÙŠØ© ØªØ¨ÙˆÙŠØ¨ "Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª" Ø¯Ø§Ø®Ù„ ØµÙØ­Ø© Ù…Ù„Ù Ø§Ù„ÙˆÙƒÙŠÙ„.</small>
                                </td>
                                <td><label class="custom-checkbox toggle-switch"><input type="checkbox" id="perm-agents-view-competitions" ${p.agents.can_view_competitions_tab || user.role === 'super_admin' ? 'checked' : ''}><span class="slider round"></span></label></td>
                            </tr>
                            <tr>
                                <td class="permission-name">
                                    <i class="fas fa-eye"></i>
                                    <strong>Ø¹Ø±Ø¶ Ø§Ù„ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø§Ù„ÙŠØ© Ù„Ù„ÙˆÙƒÙŠÙ„</strong>
                                    <small>Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù…ÙˆØ¸Ù Ø¨Ø±Ø¤ÙŠØ© ØªØ¨ÙˆÙŠØ¨ "ØªÙØ§ØµÙŠÙ„" Ø§Ù„Ù…Ø§Ù„ÙŠ Ù„Ù„ÙˆÙƒÙŠÙ„.</small>
                                </td>
                                <td><label class="custom-checkbox toggle-switch"><input type="checkbox" id="perm-agents-view-financials" ${p.agents.view_financials || user.role === 'super_admin' ? 'checked' : ''}><span class="slider round"></span></label></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div class="form-actions" style="margin-top: 20px;" ${user.role === 'super_admin' ? 'hidden' : ''}>
                    <button type="submit" id="save-permissions-btn" class="btn-primary"><i class="fas fa-save"></i> Ø­ÙØ¸ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª</button>
                    <button type="button" id="cancel-permissions-modal" class="btn-secondary">Ø¥Ù„ØºØ§Ø¡</button>
                </div>
            </form>
        </div>
    `;

    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    const closeModal = () => overlay.remove();
    modal.querySelector('#close-modal-btn').addEventListener('click', closeModal);
    modal.querySelector('#cancel-permissions-modal').addEventListener('click', closeModal);

    modal.querySelector('#permissions-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const submitBtn = modal.querySelector('#save-permissions-btn');
        if (!submitBtn) return;

        // Get original permissions for logging
        const originalPermissions = user.permissions || {};

        submitBtn.disabled = true;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...';

        const permissionsData = {
            agents: {
                view_financials: modal.querySelector('#perm-agents-view-financials')?.checked || false,
                edit_profile: false, 
                edit_financials: false, // This permission is not implemented in the UI yet
                can_view_competitions_tab: modal.querySelector('#perm-agents-view-competitions')?.checked || false, // This will be read from the new toggle
                can_renew_all_balances: modal.querySelector('#perm-agents-renew-all')?.checked || false,
            },
            competitions: {
                manage_comps: modal.querySelector('input[name="perm_manage_comps"]:checked')?.value || 'none',
                manage_templates: modal.querySelector('input[name="perm_manage_templates"]:checked')?.value || 'none',
                can_create: modal.querySelector('#perm-competitions-can-create')?.checked || false,
            }
        };

        try {
            // The backend will log the change, including old and new values.
            const response = await authedFetch(`/api/users/${user._id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ permissions: permissionsData })
            });
            if (!response.ok) {
                const result = await response.json();
                throw new Error(result.message || 'ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª.');
            }

            showToast('ØªÙ… ØªØ­Ø¯ÙŠØ« ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­.', 'success');
            closeModal();
            
            // Important: We must refetch the entire user list so the local cache (`allUsersCache`)
            // is updated with the new permissions. This ensures that if we open the modal
            // again for the same user, it shows the correct, most recent data.
            await fetchUsersData(); // Refresh the user list to reflect changes
        } catch (error) {
            showToast(`ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª: ${error.message}`, 'error');
            submitBtn.disabled = false;
            submitBtn.innerHTML = '<i class="fas fa-save"></i> Ø­ÙØ¸ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª';
        }
    });
}

// NEW: Function to render the user's own profile settings page
async function renderProfileSettingsPage() {
    const appContent = document.getElementById('app-content');

    if (!currentUserProfile) {
        appContent.innerHTML = `<p class="error">ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©.</p>`;
        return;
    }

    const isSuperAdmin = currentUserProfile.role === 'super_admin';
    const isAdmin = currentUserProfile.role === 'admin';
    const roleBadge = isSuperAdmin ? '<span class="admin-badge super-admin">Ù…Ø¯ÙŠØ± Ø¹Ø§Ù…</span>' : (isAdmin ? '<span class="admin-badge">Ù…Ø³Ø¤ÙˆÙ„</span>' : '<span class="employee-badge">Ù…ÙˆØ¸Ù</span>');

    appContent.innerHTML = `
        <div class="page-header">
            <h1><i class="fas fa-user-cog"></i> Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ</h1>
        </div>

        <!-- NEW: Profile Header Section for display -->
        <div class="profile-settings-header">
            <div class="profile-avatar-edit large-avatar">
                <img src="${currentUserProfile.avatar_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(currentUserProfile.full_name || currentUserProfile.email)}&background=8A2BE2&color=fff&size=128`}" alt="Avatar" id="avatar-preview">
                <input type="file" id="avatar-upload" accept="image/*" style="display: none;">
            </div>
            <div class="profile-header-info">
                <h2 class="profile-name-display">${currentUserProfile.full_name || 'Ù…Ø³ØªØ®Ø¯Ù…'} ${roleBadge}</h2>
                <p class="profile-email-display">${currentUserProfile.email || ''}</p>
            </div>
        </div>

        <div class="form-container" style="max-width: 800px;">
            <form id="profile-settings-form">
                ${currentUserProfile.role === 'admin' || currentUserProfile.role === 'super_admin' ? `
                    <h3 class="details-section-title">Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©</h3>
                    <div class="details-grid" style="grid-template-columns: 1fr; gap: 20px;"><div class="form-group"><label for="profile-full-name">Ø§Ù„Ø§Ø³Ù… Ø§Ù„ÙƒØ§Ù…Ù„</label><input type="text" id="profile-full-name" class="profile-name-input" value="${currentUserProfile.full_name || ''}" required></div></div>
                ` : ''}
                
                <h3 class="details-section-title">ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±</h3>
                <div class="details-grid" style="grid-template-columns: 1fr; gap: 20px;">
                    <div class="form-group">
                        <label for="profile-current-password">ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø­Ø§Ù„ÙŠØ©</label>
                        <div class="password-input-wrapper">
                            <input type="password" id="profile-current-password" placeholder="Ù…ØªØ§Ø­ Ù„Ù„Ø³ÙˆØ¨Ø± Ø£Ø¯Ù…Ù† ÙÙ‚Ø·" ${currentUserProfile.role === 'super_admin' ? '' : 'disabled'}>
                            <button type="button" class="password-toggle-btn" title="Ø¥Ø¸Ù‡Ø§Ø±/Ø¥Ø®ÙØ§Ø¡ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±"><i class="fas fa-eye"></i></button>
                            <div id="current-password-validation-msg" class="validation-status-inline"></div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="profile-new-password">ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©</label>
                        <div class="password-input-wrapper">
                            <input type="password" id="profile-new-password" placeholder="${isSuperAdmin ? '' : 'Ù…ØªØ§Ø­ Ù„Ù„Ø³ÙˆØ¨Ø± Ø£Ø¯Ù…Ù† ÙÙ‚Ø·'}" ${isSuperAdmin ? '' : 'disabled'}>
                            <button type="button" class="password-toggle-btn" title="Ø¥Ø¸Ù‡Ø§Ø±/Ø¥Ø®ÙØ§Ø¡ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±"><i class="fas fa-eye"></i></button>
                        </div>
                        <div class="password-strength-meter"><div class="strength-bar"></div></div>
                        <div class="password-actions">
                            ${isSuperAdmin ? '<button type="button" id="generate-password-btn" class="btn-secondary btn-small">Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± Ù‚ÙˆÙŠØ©</button>' : ''}
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="profile-confirm-password">ØªØ£ÙƒÙŠØ¯ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©</label>
                        <div class="password-input-wrapper">
                            <input type="password" id="profile-confirm-password" ${isSuperAdmin ? '' : 'disabled'}>
                            <button type="button" class="password-toggle-btn" title="Ø¥Ø¸Ù‡Ø§Ø±/Ø¥Ø®ÙØ§Ø¡ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±"><i class="fas fa-eye"></i></button>
                            <div id="password-match-error" class="validation-error-inline" style="display: none;">ÙƒÙ„Ù…ØªØ§ Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚ØªÙŠÙ†.</div>
                        </div>
                    </div>
                    ${!isSuperAdmin ? '<div class="alert alert-warning">ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ù„Ø³ÙˆØ¨Ø± Ø£Ø¯Ù…Ù† ÙÙ‚Ø·.</div>' : ''}
                </div>

                ${isSuperAdmin || currentUserProfile.role === 'admin' ? `
                <div class="form-actions">
                    <button type="submit" id="save-profile-settings-btn" class="btn-primary">
                        <i class="fas fa-save"></i> Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
                    </button>
                </div>
                ` : ''}
            </form>
        </div>
    `;

    const form = document.getElementById('profile-settings-form');
    // Only query saveBtn if it exists
    const saveBtn = form.querySelector('#save-profile-settings-btn');
    const newPasswordInput = form.querySelector('#profile-new-password');
    const confirmPasswordInput = form.querySelector('#profile-confirm-password');
    const currentPasswordInput = form.querySelector('#profile-current-password');
    const validationMsgEl = form.querySelector('#current-password-validation-msg');

    // --- NEW: Real-time current password validation on blur (super_admin only) ---
    if (currentPasswordInput) {
        currentPasswordInput.addEventListener('blur', async () => {
            if (!isSuperAdmin) return;
            const password = currentPasswordInput.value;
    
            // Clear previous message if input is empty
            if (!password) {
                validationMsgEl.innerHTML = '';
                validationMsgEl.className = 'validation-status-inline';
                return;
            }

            // Show a loading indicator
            validationMsgEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span>Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚...</span>';
            validationMsgEl.className = 'validation-status-inline checking';

            try {
                const response = await authedFetch('/api/auth/verify-password', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password })
                });

                if (!response.ok) {
                    const result = await response.json().catch(() => ({}));
                    validationMsgEl.innerHTML = '<i class="fas fa-times-circle"></i> <span>' + (result.message || 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø­Ø§Ù„ÙŠØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©.') + '</span>';
                    validationMsgEl.className = 'validation-status-inline error';
                    return;
                }

                validationMsgEl.innerHTML = '<i class="fas fa-check-circle"></i> <span>ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØµØ­ÙŠØ­Ø©.</span>';
                validationMsgEl.className = 'validation-status-inline success';
            } catch (e) {
                validationMsgEl.innerHTML = '<i class="fas fa-exclamation-triangle"></i> <span>Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚.</span>';
                validationMsgEl.className = 'validation-status-inline error';
            }
        });
    }
 
    // --- Avatar Logic ---
    const avatarUploadInput = document.getElementById('avatar-upload');
    const avatarPreview = document.getElementById('avatar-preview');
    const avatarEditContainer = document.querySelector('.profile-settings-header .profile-avatar-edit');

    if (avatarEditContainer) {
        avatarEditContainer.addEventListener('click', () => {
            // Allow both admin and super_admin to change avatar
            if (currentUserProfile.role === 'admin' || currentUserProfile.role === 'super_admin') {
                avatarUploadInput.click();
            }
        });
    }
    if (avatarUploadInput) {
        avatarUploadInput.addEventListener('change', () => {
            const file = avatarUploadInput.files[0];
            if (file) avatarPreview.src = URL.createObjectURL(file);
        });
    }

    // --- Password Toggles & Strength Meter ---
    form.querySelectorAll('.password-toggle-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const input = btn.closest('.password-input-wrapper').querySelector('input');
            const isPassword = input.type === 'password';
            input.type = isPassword ? 'text' : 'password';
            btn.querySelector('i').className = `fas ${isPassword ? 'fa-eye-slash' : 'fa-eye'}`;
        });
    });
    const strengthBar = form.querySelector('.strength-bar');
    newPasswordInput.addEventListener('input', () => {
        const password = newPasswordInput.value;
        let strength = 0;
        if (password.length >= 8) strength++;
        if (password.match(/[a-z]/) && password.match(/[A-Z]/)) strength++;
        if (password.match(/\d/)) strength++;
        if (password.match(/[^a-zA-Z\d]/)) strength++;
        strengthBar.className = 'strength-bar';
        if (strength > 0) strengthBar.classList.add(`strength-${strength}`);
    });

    // --- Generate Password Button ---
    const generatePasswordBtn = form.querySelector('#generate-password-btn');
    if (generatePasswordBtn) {
        generatePasswordBtn.addEventListener('click', () => {
            const lower = 'abcdefghijklmnopqrstuvwxyz';
            const upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const numbers = '0123456789';
            const symbols = '!@#$%^&*()_+-=[]{}|;:,.<>?';
            const all = lower + upper + numbers + symbols;
            let newPassword = '';
            newPassword += lower.charAt(Math.floor(Math.random() * lower.length));
            newPassword += upper.charAt(Math.floor(Math.random() * upper.length));
            newPassword += numbers.charAt(Math.floor(Math.random() * numbers.length));
            newPassword += symbols.charAt(Math.floor(Math.random() * symbols.length));
            for (let i = newPassword.length; i < 14; i++) {
                newPassword += all.charAt(Math.floor(Math.random() * all.length));
            }
            newPassword = newPassword.split('').sort(() => 0.5 - Math.random()).join('');
            newPasswordInput.value = newPassword;
            confirmPasswordInput.value = newPassword;
            newPasswordInput.dispatchEvent(new Event('input')); // Trigger strength check
            navigator.clipboard.writeText(newPassword).then(() => {
                showToast('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ÙˆÙ†Ø³Ø® ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± Ù‚ÙˆÙŠØ©.', 'success');
            });
        });
    }

    // --- Real-time password match validation ---
    const passwordMatchError = form.querySelector('#password-match-error');
    const validatePasswordMatch = () => {
        if (newPasswordInput.value && confirmPasswordInput.value && newPasswordInput.value !== confirmPasswordInput.value) {
            passwordMatchError.style.display = 'block';
            if (saveBtn) saveBtn.disabled = true;
        } else {
            passwordMatchError.style.display = 'none';
            if (saveBtn) saveBtn.disabled = false;
        }
    };
    newPasswordInput.addEventListener('input', validatePasswordMatch);
    confirmPasswordInput.addEventListener('input', validatePasswordMatch);

    // --- Disable form elements for non-admins ---
    if (currentUserProfile.role !== 'admin' && currentUserProfile.role !== 'super_admin') {
        const fullNameInput = form.querySelector('#profile-full-name');
        if (fullNameInput) fullNameInput.disabled = true;
        avatarEditContainer.style.cursor = 'not-allowed';
        avatarEditContainer.title = 'Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ ØªØºÙŠÙŠØ± Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø´Ø®ØµÙŠØ©.';
    }

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        if (!saveBtn) return; // Should not happen if button is hidden, but defensive

        // --- Submission Logic ---
        saveBtn.disabled = true;
        saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...';

        const fullNameInput = document.getElementById('profile-full-name');
        const fullName = fullNameInput ? fullNameInput.value : currentUserProfile.full_name;
        const newPassword = newPasswordInput.value; // FIX: Define newPassword variable
        const confirmPassword = document.getElementById('profile-confirm-password').value;
        const currentPassword = document.getElementById('profile-current-password').value;

        try {
            // --- Password Validation (super_admin only) ---
            if (newPassword || confirmPassword || currentPassword) {
                if (currentUserProfile.role !== 'super_admin') {
                    throw new Error('ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ù„Ø³ÙˆØ¨Ø± Ø£Ø¯Ù…Ù† ÙÙ‚Ø·.');
                }
                if (newPassword && !currentPassword) {
                    throw new Error('ÙŠØ¬Ø¨ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„ØªØºÙŠÙŠØ±Ù‡Ø§.');
                }
                if (newPassword !== confirmPassword) {
                    throw new Error('ÙƒÙ„Ù…ØªØ§ Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯ØªØ§Ù† ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚ØªÙŠÙ†.');
                }
            }

            // 1. Handle avatar upload if a new file is selected
            const avatarFile = document.getElementById('avatar-upload').files[0];
            let newAvatarUrl = currentUserProfile.avatar_url;

            if (avatarFile) {
                const formData = new FormData();
                formData.append('avatar', avatarFile);

                const uploadResp = await authedFetch(`/api/users/${currentUserProfile._id}/avatar`, {
                    method: 'POST',
                    body: formData
                });
                if (!uploadResp.ok) {
                    const result = await uploadResp.json().catch(() => ({}));
                    throw new Error(result.message || 'ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.');
                }

                const uploadResult = await uploadResp.json();
                newAvatarUrl = uploadResult.avatar_url || newAvatarUrl;
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© ÙÙˆØ±Ø§Ù‹
                if (newAvatarUrl && avatarPreview) {
                    avatarPreview.src = newAvatarUrl;
                }
            }

            // 2. Update public profile table (users)
            const profileUpdateData = { avatar_url: newAvatarUrl };
            if ((currentUserProfile.role === 'admin' || currentUserProfile.role === 'super_admin') && fullNameInput) {
                profileUpdateData.full_name = fullName;
            }

            // TODO: Implement backend endpoint for updating user profile
            const response = await authedFetch(`/api/users/${currentUserProfile._id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(profileUpdateData)
            });
            if (!response.ok) {
                const result = await response.json();
                throw new Error(result.message || 'ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ.');
            }


            // 3. If a new password is provided, verify old and update in auth (super_admin only)
            if (newPassword && currentPassword && currentUserProfile.role === 'super_admin') {
                const resp = await authedFetch('/api/auth/change-password', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ currentPassword, newPassword })
                });

                if (!resp.ok) {
                    const result = await resp.json().catch(() => ({}));
                    throw new Error(result.message || 'ÙØ´Ù„ ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±.');
                }
            }

            // 4. Refresh local user profile data to reflect changes
            await fetchUserProfile();

            showToast('ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ Ø¨Ù†Ø¬Ø§Ø­.', 'success');

            // NEW: If password was changed, clear fields and hide the section
            if (newPassword) {
                currentPasswordInput.value = '';
                newPasswordInput.value = '';
                confirmPasswordInput.value = '';
                validationMsgEl.innerHTML = '';
                validationMsgEl.className = 'validation-status-inline';
                form.querySelector('#password-match-error').style.display = 'none';
                form.querySelector('.strength-bar').className = 'strength-bar';
            }
        } catch (error) {
            console.error('Error updating profile:', error);
            showToast(`ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ: ${error.message}`, 'error');
        } finally {
            saveBtn.disabled = false;
            saveBtn.innerHTML = '<i class="fas fa-save"></i> Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª';
        }
    });
}
// ============================================
// Purge All Users (Super Admin Only)
// ============================================
async function handlePurgeAllUsers() {
    const modal = document.createElement('div');
    modal.id = 'purge-all-users-modal';
    modal.className = 'purge-modal';
    modal.innerHTML = `
        <div class="modal-overlay"></div>
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-exclamation-triangle"></i> ?????: ??? ???? ????????</h3>
            </div>
            <div class="modal-body">
                <p style="color: var(--error-color); font-weight: bold; font-size: 1.1em;"> ????? ???? ???????!</p>
                <p>??? ??? ??? ??? <strong>???? ?????? ??????????</strong> ?? ??????.</p>
                <p style="margin-top: 15px;"><strong>??????:</strong> ????? ?????? (Super Admin) ????? ??? ??? ????.</p>
                <p style="color: var(--error-color); font-weight: bold; margin-top: 15px;"> ??? ??????? ?? ???? ??????? ???!</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary cancel-purge-btn">
                    <i class="fas fa-times"></i> ?????
                </button>
                <button class="btn btn-danger confirm-purge-btn">
                    <i class="fas fa-trash-alt"></i> ???? ???? ???? ????????
                </button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    setTimeout(() => modal.classList.add('show'), 10);
    const cancelBtn = modal.querySelector('.cancel-purge-btn');
    const overlay = modal.querySelector('.modal-overlay');
    const closeModal = () => { modal.classList.remove('show'); setTimeout(() => modal.remove(), 300); };
    cancelBtn.addEventListener('click', closeModal);
    overlay.addEventListener('click', closeModal);
    const confirmBtn = modal.querySelector('.confirm-purge-btn');
    confirmBtn.addEventListener('click', async () => {
        confirmBtn.disabled = true;
        confirmBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ???? ?????...';
        try {
            const response = await fetch('/api/users/purge-all', {
                method: 'DELETE',
                headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}`, 'Content-Type': 'application/json' }
            });
            const data = await response.json();
            if (response.ok) {
                showToast(data.message || '?? ??? ???? ???????? ?????', 'success');
                closeModal();
                setTimeout(() => renderUsersPage(), 1500);
            } else {
                showToast(data.message || '??? ??? ????????', 'error');
                confirmBtn.disabled = false;
                confirmBtn.innerHTML = '<i class="fas fa-trash-alt"></i> ???? ???? ???? ????????';
            }
        } catch (error) {
            console.error('Error purging users:', error);
            showToast('??? ??? ????? ??? ????????', 'error');
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = '<i class="fas fa-trash-alt"></i> ???? ???? ???? ????????';
        }
    });
}


// == tasks.js ==
ï»¿// Refactored Tasks Page: Decoupled from Calendar, reliant solely on taskStore.
(function() {
    // --- Constants and Configuration ---
    const CLASSIFICATIONS = ['R', 'A', 'B', 'C'];
    const OPEN_GROUPS_KEY = 'openTaskGroups';

    // --- UI Rendering Functions ---

    function getTaskCardHtml(agent, task) {
        const avatarHtml = agent.avatar_url
            ? `<img src="${agent.avatar_url}" alt="Avatar" class="task-agent-avatar" loading="lazy">`
            : `<div class="task-agent-avatar-placeholder"><i class="fas fa-user"></i></div>`;

        const isAudited = task.audited;
        const isCompetitionSent = task.competition_sent;
        const isComplete = isAudited; // Main completion logic

        const depositBonusText = (agent.remaining_deposit_bonus > 0 && agent.deposit_bonus_percentage > 0)
            ? `${agent.remaining_deposit_bonus} ${agent.remaining_deposit_bonus === 1 ? 'Ù…Ø±Ø©' : 'Ù…Ø±Ø§Øª'} Ø¨Ù†Ø³Ø¨Ø© ${agent.deposit_bonus_percentage}%`
            : 'Ù„Ø§ ÙŠÙˆØ¬Ø¯';

        return `
        <div class="task-card ${isComplete ? 'complete' : ''}" data-agent-id="${agent._id}" data-name="${agent.name.toLowerCase()}" data-original-name="${agent.name}" data-agentid-str="${agent.agent_id}">
            <div class="task-card-header" style="cursor: pointer;">
                <div class="task-card-main">
                    ${avatarHtml}
                    <div class="task-agent-info">
                        <h3 class="${isComplete ? 'has-checkmark' : ''}">${agent.name}<i class="fas fa-check-circle task-complete-icon" title="Ø§Ù„Ù…Ù‡Ù…Ø© Ù…ÙƒØªÙ…Ù„Ø©"></i></h3>
                        <p class="task-agent-id" title="Ù†Ø³Ø® Ø§Ù„Ø±Ù‚Ù…">${agent.agent_id}</p>
                    </div>
                </div>
                <span class="classification-badge classification-${agent.classification.toLowerCase()}">${agent.classification}</span>
            </div>
            <div class="task-card-body">
                <div class="task-stat">
                    <label>Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„ØªØ¯Ø§ÙˆÙ„ÙŠ:</label>
                    <span>${Math.max(0, agent.remaining_balance || 0)}</span>
                </div>
                <div class="task-stat">
                    <label>Ø¨ÙˆÙ†Øµ Ø§Ù„Ø¥ÙŠØ¯Ø§Ø¹:</label>
                    <span>${depositBonusText}</span>
                </div>
            </div>
            <div class="task-card-actions">
                <div class="action-item ${isAudited ? 'done' : ''}">
                    <label>Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚</label>
                    <label class="custom-checkbox toggle-switch">
                        <input type="checkbox" class="audit-check" data-agent-id="${agent._id}" ${isAudited ? 'checked' : ''}>
                        <span class="slider round"></span>
                    </label>
                </div>
                <div class="action-item ${isAudited && isCompetitionSent ? 'done' : ''}">
                    <label>Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</label>
                    <label class="custom-checkbox toggle-switch">
                        <input type="checkbox" class="competition-check" data-agent-id="${agent._id}" ${isCompetitionSent ? 'checked' : ''} ${!isAudited ? 'disabled' : ''}>
                        <span class="slider round"></span>
                    </label>
                </div>
            </div>
        </div>`;
    }

    function getTaskGroupHtml(classification, agents, tasksMap, openGroups, highlightedAgentId) {
        if (agents.length === 0) return '';

        const completedCount = agents.filter(agent => (tasksMap[agent._id] || {}).audited).length;
        const allComplete = completedCount === agents.length;
        const containsHighlight = highlightedAgentId && agents.some(agent => agent._id == highlightedAgentId);
        const isOpen = openGroups.includes(classification) || containsHighlight;

        const agentCardsHtml = agents.map(agent => getTaskCardHtml(agent, tasksMap[agent._id] || {})).join('');

        return `
        <details class="task-group ${allComplete ? 'all-complete' : ''}" data-classification="${classification}" ${isOpen ? 'open' : ''}>
            <summary class="task-group-header">
                <div class="task-group-title">
                    <h2>${classification}</h2>
                    <span class="task-group-progress">${completedCount} / ${agents.length}</span>
                </div>
                <div class="task-group-bulk-actions">
                    <label class="custom-checkbox small"><input type="checkbox" class="bulk-audit-check" data-classification="${classification}">
                        <span class="checkmark"></span> ØªØ¯Ù‚ÙŠÙ‚ Ø§Ù„ÙƒÙ„
                    </label>
                    <label class="custom-checkbox small"><input type="checkbox" class="bulk-competition-check" data-classification="${classification}">
                        <span class="checkmark"></span> Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„ÙƒÙ„
                    </label>
                </div>
                <div class="task-group-indicators">
                    <i class="fas fa-check-circle group-completion-indicator" title="Ø§ÙƒØªÙ…Ù„Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù‡Ø§Ù… ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø³Ù…"></i>
                    <i class="fas fa-chevron-down"></i>
                </div>
            </summary>
            <div class="task-group-content">${agentCardsHtml}</div>
        </details>`;
    }

    function getPageLayoutHtml() {
        return `
        <div class="page-header column-header">
            <div class="header-top-row">
                <h1>Ù…Ù‡Ù…Ø§Øª Ø§Ù„ÙŠÙˆÙ…</h1>
                <div class="header-actions-group">
                    <button id="mark-all-audited-btn" class="btn-primary">
                        <i class="fas fa-check-double"></i> ØªÙ…ÙŠÙŠØ² Ø§Ù„ÙƒÙ„ ÙƒÙ€ "ØªÙ… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚"
                    </button>
                </div>
            </div>
            <div class="agent-filters">
                <div class="filter-search-container">
                    <input type="search" id="task-search-input" placeholder="Ø¨Ø­Ø« Ø¨Ø§Ù„Ø§Ø³Ù… Ø£Ùˆ Ø§Ù„Ø±Ù‚Ù…..." autocomplete="off">
                    <i class="fas fa-search"></i>
                    <i class="fas fa-times-circle search-clear-btn" id="task-search-clear"></i>
                </div>
            </div>
        </div>
        <div id="tasks-content-wrapper"></div>`;
    }

    function getOverviewHtml(agents, tasksMap) {
        const total = agents.length;
        const completed = agents.filter(agent => (tasksMap[agent._id] || {}).audited).length;
        const progress = total > 0 ? (completed / total) * 100 : 0;

        return `
        <div class="tasks-overview" id="tasks-overview">
            <div class="progress-donut-chart" style="--p:${progress};--b:10px;--c:var(--primary-color);">
                <span>${Math.round(progress)}%</span>
            </div>
            <div class="overview-stats">
                <div class="overview-stat-item" data-stat="total">
                    <h3>${total}</h3>
                    <p><i class="fas fa-tasks"></i> Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ù…Ù‡Ø§Ù… Ø§Ù„ÙŠÙˆÙ…</p>
                </div>
                <div class="overview-stat-item" data-stat="completed">
                    <h3>${completed}</h3>
                    <p><i class="fas fa-check-double"></i> Ù…Ù‡Ø§Ù… Ù…ÙƒØªÙ…Ù„Ø©</p>
                </div>
                <div class="overview-stat-item" data-stat="pending">
                    <h3>${total - completed}</h3>
                    <p><i class="fas fa-hourglass-half"></i> Ù…Ù‡Ø§Ù… Ù…ØªØ¨Ù‚ÙŠØ©</p>
                </div>
            </div>
        </div>`;
    }


    // --- Main Page Class ---

    class TasksPage {
        constructor(container) {
            this.container = container;
            this.agents = [];
            this.tasksMap = {};
            this.dayIndex = new Date().getDay();
            this.searchDebounceTimer = null;

            // Bind methods
            this.boundHandleEvents = this.handleEvents.bind(this);
            this.boundUpdateUIFromStore = this.updateUIFromStore.bind(this);
        }

        async render() {
            this.container.innerHTML = getPageLayoutHtml();
            this.contentWrapper = this.container.querySelector('#tasks-content-wrapper');
            
            this.setupEventListeners();
            
            // Subscribe to store updates
            if (window.taskStore) {
                window.taskStore.subscribe(this.boundUpdateUIFromStore);
            }

            await this.fetchAndRenderTasks();
        }

        async fetchAndRenderTasks() {
            // Saturday (6) is a holiday
            if (this.dayIndex === 6) { 
                this.contentWrapper.innerHTML = '<div class="no-results-message"><i class="fas fa-coffee" style="font-size: 48px; margin-bottom: 15px; color: #64748b;"></i><br>ÙŠÙˆÙ… Ø§Ù„Ø³Ø¨Øª Ø¥Ø¬Ø§Ø²Ø© Ø±Ø³Ù…ÙŠØ©<br><span style="font-size: 0.9em; color: #94a3b8;">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù‡Ø§Ù… Ù…Ø¬Ø¯ÙˆÙ„Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„ÙŠÙˆÙ…</span></div>';
                return;
            }

            try {
                // Pass the local day index to the backend to ensure consistency
                const response = await authedFetch(`/api/tasks/today?day=${this.dayIndex}`);
                if (!response.ok) throw new Error('Failed to fetch tasks');
                
                const { agents, tasksMap } = await response.json();
                
                console.log('[TASKS PAGE DEBUG] Response from /api/tasks/today:');
                console.log('  - Agents count:', agents?.length || 0);
                console.log('  - Agents:', agents);
                console.log('  - Current day index:', this.dayIndex);
                
                this.agents = agents || [];
                this.tasksMap = tasksMap || {};

                this.renderAllContent();

            } catch (error) {
                console.error("Error fetching tasks:", error);
                this.contentWrapper.innerHTML = `<p class="error">Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù‡Ø§Ù….</p>`;
            }
        }

        renderAllContent() {
            if (this.agents.length === 0) {
                this.contentWrapper.innerHTML = '<p class="no-results-message">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù‡Ø§Ù… Ù…Ø¬Ø¯ÙˆÙ„Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„ÙŠÙˆÙ….</p>';
                return;
            }

            const groupedAgents = CLASSIFICATIONS.reduce((acc, c) => {
                acc[c] = this.agents.filter(a => a.classification === c);
                return acc;
            }, {});

            // Default: open all classifications unless user has saved state
            const openGroups = JSON.parse(localStorage.getItem(OPEN_GROUPS_KEY)) || CLASSIFICATIONS.slice();
            const highlightedAgentId = new URLSearchParams(window.location.hash.split('?')[1]).get('highlight');

            const overviewHtml = getOverviewHtml(this.agents, this.tasksMap);
            const groupsHtml = CLASSIFICATIONS.map(c => 
                getTaskGroupHtml(c, groupedAgents[c], this.tasksMap, openGroups, highlightedAgentId)
            ).join('');

            this.contentWrapper.innerHTML = `${overviewHtml}<div id="task-list-container">${groupsHtml}</div>`;
            
            this.highlightCard(highlightedAgentId);
        }

        highlightCard(agentId) {
            if (!agentId) return;
            const card = this.contentWrapper.querySelector(`.task-card[data-agent-id="${agentId}"]`);
            if (card) {
                card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                card.classList.add('highlighted');
            }
            // Clean the URL
            history.replaceState(null, '', '#tasks');
        }

        setupEventListeners() {
            this.container.addEventListener('click', this.boundHandleEvents);
            this.container.addEventListener('change', this.boundHandleEvents);
            
            const searchInput = this.container.querySelector('#task-search-input');
            searchInput.addEventListener('input', () => {
                clearTimeout(this.searchDebounceTimer);
                this.searchDebounceTimer = setTimeout(() => this.filterAgents(searchInput.value), 300);
            });
            
            this.container.querySelector('#task-search-clear').addEventListener('click', () => {
                searchInput.value = '';
                this.filterAgents('');
            });
        }

        async handleEvents(e) {
            const target = e.target;
            const agentCard = target.closest('.task-card');
            const agentId = agentCard?.dataset.agentId;

            // --- Change Events (Toggles) ---
            if (e.type === 'change') {
                const taskType = target.classList.contains('audit-check') ? 'audited' 
                               : target.classList.contains('competition-check') ? 'competition_sent' 
                               : null;
                if (agentId && taskType) {
                    // ========== DEBUG CONSOLE LOGS (TASKS PAGE) ==========
                    /* console.log('ğŸ”„ [TASKS] Toggle Changed!');
                    console.log('ğŸ“ Agent ID:', agentId);
                    console.log('ğŸ“… Day Index:', this.dayIndex);
                    console.log('ğŸ·ï¸ Task Type:', taskType);
                    console.log('âœ… New Status:', target.checked ? 'ON (checked)' : 'OFF (unchecked)');
                    console.log('ğŸ¯ Checkbox element:', target);
                    console.log('ğŸ” Checkbox classes:', target.className);
                    console.log('ğŸ“Š Checkbox checked property:', target.checked);
                    console.log('===================================================='); */
                    // =====================================================

                    agentCard.classList.add('is-loading');
                    agentCard.querySelectorAll('input').forEach(i => i.disabled = true);
                    try {
                        // console.log('ğŸ“¤ [TASKS] Sending update to server...');
                        await window.taskStore.updateTaskStatus(agentId, this.dayIndex, taskType, target.checked);
                        // console.log('âœ… [TASKS] Server update successful!');
                        this.updateSingleCard(agentId); // FIX: Targeted UI update
                        // console.log('ğŸ¨ [TASKS] UI updated successfully!');
                    } catch (error) {
                        console.error('âŒ [TASKS] Failed to update task', error);
                        console.error('Error details:', error);
                        showToast('ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù‡Ù…Ø©.', 'error');
                        target.checked = !target.checked; // Revert on error
                        console.log('âª [TASKS] Reverted checkbox to:', !target.checked);
                    } finally {
                        agentCard.classList.remove('is-loading');
                        // Re-enable controls, considering dependencies
                        const isAudited = agentCard.querySelector('.audit-check').checked;
                        agentCard.querySelector('.audit-check').disabled = false;
                        const compCheck = agentCard.querySelector('.competition-check');
                        if(compCheck) compCheck.disabled = !isAudited;
                    }
                    return;
                }

                const bulkTaskType = target.classList.contains('bulk-audit-check') ? 'audited' 
                                   : target.classList.contains('bulk-competition-check') ? 'competition_sent' 
                                   : null;
                if (bulkTaskType) {
                    this.handleBulkUpdate(target.dataset.classification, bulkTaskType, target.checked);
                    return;
                }
            }

            // --- Click Events ---
            if (e.type === 'click') {
                if (target.closest('.task-card-header')) {
                    window.location.hash = `#profile/${agentId}`;
                    return;
                }
                if (target.id === 'mark-all-audited-btn') {
                    this.handleMarkAllAudited();
                    return;
                }
                if (target.closest('.task-group-header')) {
                    this.saveOpenGroupsState();
                    return;
                }
            }
        }

        handleBulkUpdate(classification, taskType, status) {
            showLoader();
            const agentsToUpdate = this.agents.filter(a => a.classification === classification);
            const promises = agentsToUpdate.map(agent => 
                window.taskStore.updateTaskStatus(agent._id, this.dayIndex, taskType, status)
            );

            Promise.all(promises)
                .then(() => {
                    showToast(`ØªÙ… ØªØ­Ø¯ÙŠØ« ${agentsToUpdate.length} ÙˆÙƒÙ„Ø§Ø¡ Ø¨Ù†Ø¬Ø§Ø­.`, 'success');
                    this.fetchAndRenderTasks(); // FIX: Refresh UI after bulk update
                })
                .catch(err => {
                    console.error('Bulk update failed:', err);
                    showToast('ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø¨Ø¹Ø¶ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡.', 'error');
                })
                .finally(hideLoader);
        }

        handleMarkAllAudited() {
            showConfirmationModal('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† ØªÙ…ÙŠÙŠØ² Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù‡Ø§Ù… ÙƒÙ€ "ØªÙ… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚"ØŸ', () => {
                showLoader();
                const promises = this.agents.map(agent => 
                    window.taskStore.updateTaskStatus(agent._id, this.dayIndex, 'audited', true)
                );

                Promise.all(promises)
                    .then(() => {
                        showToast('ØªÙ… ØªØ­Ø¯ÙŠØ« Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù‡Ø§Ù… Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                        this.fetchAndRenderTasks(); // FIX: Refresh UI after bulk update
                    })
                    .catch(err => {
                        console.error('Mark all audited failed:', err);
                        showToast('ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ù‡Ø§Ù….', 'error');
                    })
                    .finally(hideLoader);
            });
        }
        
        filterAgents(searchTerm) {
            const term = searchTerm.toLowerCase().trim();
            const taskListContainer = this.container.querySelector('#task-list-container');
            if (!taskListContainer) return;

            this.agents.forEach(agent => {
                const card = taskListContainer.querySelector(`.task-card[data-agent-id="${agent._id}"]`);
                if (!card) return;

                const isVisible = term === '' || 
                                  agent.name.toLowerCase().includes(term) || 
                                  agent.agent_id.includes(term);
                card.style.display = isVisible ? '' : 'none';
            });

            // Update group visibility and progress
            CLASSIFICATIONS.forEach(c => {
                const groupEl = taskListContainer.querySelector(`.task-group[data-classification="${c}"]`);
                if (!groupEl) return;

                const visibleCards = groupEl.querySelectorAll('.task-card[style=""]');
                groupEl.style.display = visibleCards.length > 0 ? '' : 'none';
            });
        }

        saveOpenGroupsState() {
            const openGroups = Array.from(this.container.querySelectorAll('.task-group[open]'))
                                    .map(el => el.dataset.classification);
            localStorage.setItem(OPEN_GROUPS_KEY, JSON.stringify(openGroups));
        }

        updateSingleCard(agentId) {
            this.tasksMap = window.taskStore.state.tasks || {}; // Refresh state
            const card = this.container.querySelector(`.task-card[data-agent-id="${agentId}"]`);
            if (!card) return;

            const task = (this.tasksMap[agentId] || {})[this.dayIndex] || {};
            const isAudited = task.audited;
            const isCompetitionSent = task.competition_sent;
            const isComplete = isAudited;

            card.classList.toggle('complete', isComplete);
            card.querySelector('.task-agent-info h3').classList.toggle('has-checkmark', isComplete);
            
            const auditCheck = card.querySelector('.audit-check');
            const competitionCheck = card.querySelector('.competition-check');
            if (auditCheck) auditCheck.checked = isAudited;
            if (competitionCheck) {
                competitionCheck.checked = isCompetitionSent;
                competitionCheck.disabled = !isAudited;
            }

            auditCheck?.closest('.action-item').classList.toggle('done', isAudited);
            competitionCheck?.closest('.action-item').classList.toggle('done', isAudited && isCompetitionSent);

            // Update group and overview stats since a card changed
            this.updateAllGroupProgress();
            this.updateOverview();
        }

        updateAllGroupProgress() {
            CLASSIFICATIONS.forEach(c => {
                const groupEl = this.container.querySelector(`.task-group[data-classification="${c}"]`);
                if (!groupEl) return;

                const groupAgents = this.agents.filter(a => a.classification === c);
                const completedCount = groupAgents.filter(a => (this.tasksMap[a._id] || {})[this.dayIndex]?.audited).length;
                
                groupEl.querySelector('.task-group-progress').textContent = `${completedCount} / ${groupAgents.length}`;
                groupEl.classList.toggle('all-complete', completedCount === groupAgents.length);
            });
        }

        updateOverview() {
            const overviewEl = this.container.querySelector('#tasks-overview');
            if (!overviewEl) return;

            const total = this.agents.length;
            const completed = this.agents.filter(a => (this.tasksMap[a._id] || {})[this.dayIndex]?.audited).length;
            const progress = total > 0 ? (completed / total) * 100 : 0;

            overviewEl.querySelector('.progress-donut-chart').style.setProperty('--p', progress);
            overviewEl.querySelector('.progress-donut-chart span').textContent = `${Math.round(progress)}%`;
            overviewEl.querySelector('[data-stat="total"] h3').textContent = total;
            overviewEl.querySelector('[data-stat="completed"] h3').textContent = completed;
            overviewEl.querySelector('[data-stat="pending"] h3').textContent = total - completed;
        }

        updateUIFromStore(newState) {
            console.log('[Tasks Page] Received store update:', newState);
            this.tasksMap = newState.tasks || {};
            
            // Efficiently update only visible cards
            this.agents.forEach(agent => {
                this.updateSingleCard(agent._id);
            });
        }

        destroy() {
            console.log('[Tasks Page] Destroying instance and cleaning up listeners.');
            this.container.removeEventListener('click', this.boundHandleEvents);
            this.container.removeEventListener('change', this.boundHandleEvents);
            clearTimeout(this.searchDebounceTimer);
            
            if (window.taskStore && this.boundUpdateUIFromStore) {
                window.taskStore.unsubscribe(this.boundUpdateUIFromStore);
            }
        }
    }

    window.TasksPage = TasksPage;
})();

// == addAgent.js ==
ï»¿const RANKS_DATA = {
    // Ø§Ù„Ø§Ø¹ØªÙŠØ§Ø¯ÙŠØ©
    'BEGINNING': { competition_bonus: 60, deposit_bonus_percentage: null, deposit_bonus_count: null },
    'GROWTH': { competition_bonus: 100, deposit_bonus_percentage: 40, deposit_bonus_count: 2 },
    'PRO': { competition_bonus: 150, deposit_bonus_percentage: 50, deposit_bonus_count: 3 },
    'ELITE': { competition_bonus: 200, deposit_bonus_percentage: 50, deposit_bonus_count: 4 },
    // Ø§Ù„Ø­ØµØ±ÙŠØ©
    'CENTER': { competition_bonus: 300, deposit_bonus_percentage: null, deposit_bonus_count: null },
    'BRONZE': { competition_bonus: 150, deposit_bonus_percentage: 40, deposit_bonus_count: 2 },
    'SILVER': { competition_bonus: 230, deposit_bonus_percentage: 40, deposit_bonus_count: 3 },
    'GOLD': { competition_bonus: 300, deposit_bonus_percentage: 50, deposit_bonus_count: 3 },
    'PLATINUM': { competition_bonus: 500, deposit_bonus_percentage: 60, deposit_bonus_count: 4 },
    'DIAMOND': { competition_bonus: 800, deposit_bonus_percentage: 75, deposit_bonus_count: 4 },
    'SAPPHIRE': { competition_bonus: 1100, deposit_bonus_percentage: 85, deposit_bonus_count: 4 },
    'EMERALD': { competition_bonus: 2000, deposit_bonus_percentage: 90, deposit_bonus_count: 4 },
    'KING': { competition_bonus: 2500, deposit_bonus_percentage: 95, deposit_bonus_count: 4 },
    'LEGEND': { competition_bonus: Infinity, deposit_bonus_percentage: 100, deposit_bonus_count: Infinity },
    'ÙˆÙƒÙŠÙ„ Ø­ØµØ±ÙŠ Ø¨Ø¯ÙˆÙ† Ù…Ø±ØªØ¨Ø©': { competition_bonus: 60, deposit_bonus_percentage: null, deposit_bonus_count: null },
};

function renderAddAgentForm() {
    const hash = window.location.hash;
    const urlParams = new URLSearchParams(hash.split('?')[1]);
    const returnPage = urlParams.get('returnTo') || 'manage-agents';

    const appContent = document.getElementById('app-content');
    appContent.innerHTML = `
        <div class="page-header"><h1><i class="fas fa-user-plus"></i> Ø¥Ø¶Ø§ÙØ© ÙˆÙƒÙŠÙ„ Ø¬Ø¯ÙŠØ¯</h1></div>
        <div class="form-container-v2">
            <form id="add-agent-form">
                <div class="form-section avatar-section">
                    <div class="profile-avatar-edit large-avatar">
                        <img src="https://ui-avatars.com/api/?name=?&background=8A2BE2&color=fff&size=128" alt="Avatar" id="avatar-preview">
                        <input type="file" id="avatar-upload" accept="image/*" style="display: none;">
                    </div>
                </div>

                <div class="form-section">
                    <h3 class="details-section-title"><i class="fas fa-id-card"></i> Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©</h3>
                    <div class="details-grid">
                        <div class="form-group"><label for="agent-name">Ø§Ø³Ù… Ø§Ù„ÙˆÙƒÙŠÙ„</label><input type="text" id="agent-name" required></div>
                        <div class="form-group">
                            <label for="agent-id">Ø±Ù‚Ù… Ø§Ù„ÙˆÙƒØ§Ù„Ø©</label><input type="text" id="agent-id" required>
                            <div id="agent-id-validation" class="validation-message"></div>
                        </div>
                    </div>
                </div>

                <div class="form-section">
                    <h3 class="details-section-title"><i class="fab fa-telegram-plane"></i> Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªÙ„Ø¬Ø±Ø§Ù…</h3>
                    <div class="details-grid">
                        <div class="form-group"><label for="telegram-channel-url">Ø±Ø§Ø¨Ø· Ù‚Ù†Ø§Ø© Ø§Ù„ØªÙ„Ø¬Ø±Ø§Ù…</label><input type="text" id="telegram-channel-url"></div>
                        <div class="form-group"><label for="telegram-group-url">Ø±Ø§Ø¨Ø· Ø¬Ø±ÙˆØ¨ Ø§Ù„ØªÙ„Ø¬Ø±Ø§Ù…</label><input type="text" id="telegram-group-url"></div>
                        <div class="form-group"><label for="telegram-chat-id">Ù…Ø¹Ø±Ù Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© (Chat ID)</label><input type="text" id="telegram-chat-id" placeholder="Ù…Ø«Ø§Ù„: -100123456789"></div>
                        <div class="form-group"><label for="telegram-group-name">Ø§Ø³Ù… Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„ØªÙ„Ø¬Ø±Ø§Ù…</label><input type="text" id="telegram-group-name"></div>
                    </div>
                </div>

                <div class="form-section">
                    <h3 class="details-section-title"><i class="fas fa-cogs"></i> Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…</h3>
                    <div class="details-grid">
                        <div class="form-group">
                            <label for="agent-classification">Ø§Ù„ØªØµÙ†ÙŠÙ</label>
                            <select id="agent-classification"><option value="R">R</option><option value="A">A</option><option value="B">B</option><option value="C">C</option></select>
                        </div>
                        <div class="form-group">
                            <label for="agent-rank">Ø§Ù„Ù…Ø±ØªØ¨Ø©</label>
                            <select id="agent-rank">
                                <optgroup label="â• Ù…Ø±Ø§ØªØ¨ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ø§Ø¹ØªÙŠØ§Ø¯ÙŠØ© â–">
                                    ${Object.keys(RANKS_DATA).filter(r => ['BEGINNING', 'GROWTH', 'PRO', 'ELITE'].includes(r)).map((rank, index) => `<option value="${rank}" ${index === 0 ? 'selected' : ''}>ğŸ”¸ ${rank}</option>`).join('')}
                                </optgroup>
                                <optgroup label="â• Ù…Ø±Ø§ØªØ¨ Ø§Ù„ÙˆÙƒØ§Ù„Ø© Ø§Ù„Ø­ØµØ±ÙŠØ© â–">
                                    <option value="ÙˆÙƒÙŠÙ„ Ø­ØµØ±ÙŠ Ø¨Ø¯ÙˆÙ† Ù…Ø±ØªØ¨Ø©">â­ ÙˆÙƒÙŠÙ„ Ø­ØµØ±ÙŠ Ø¨Ø¯ÙˆÙ† Ù…Ø±ØªØ¨Ø©</option>
                                    <option disabled>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</option>
                                    ${Object.keys(RANKS_DATA).filter(r => ['BRONZE', 'SILVER', 'GOLD', 'PLATINUM', 'DIAMOND', 'SAPPHIRE', 'EMERALD', 'KING', 'LEGEND'].includes(r)).map(rank => `<option value="${rank}">â­ ${rank}</option>`).join('')}
                                </optgroup>
                                <optgroup label="â• Ø§Ù„Ù…Ø±Ø§ÙƒØ² â–">
                                    <option value="CENTER">ğŸ¢ CENTER</option>
                                </optgroup>
                            </select>
                            <div id="rank-hint" class="form-hint">
                                <!-- Rank details will be shown here -->
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="agent-renewal-period">ÙØªØ±Ø© ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø±ØµÙŠØ¯</label>
                            <select id="agent-renewal-period">
                                <option value="none" selected>Ø¨Ø¯ÙˆÙ† ØªØ¬Ø¯ÙŠØ¯</option>
                                <option value="weekly">Ø£Ø³Ø¨ÙˆØ¹ÙŠ</option>
                                <option value="biweekly">ÙƒÙ„ Ø£Ø³Ø¨ÙˆØ¹ÙŠÙ†</option>
                                <option value="monthly">Ø´Ù‡Ø±ÙŠ</option>
                            </select>
                        </div>
                        <div class="form-group" id="competitions-per-week-group">
                            <label for="agent-competitions-per-week">Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª ÙƒÙ„ Ø£Ø³Ø¨ÙˆØ¹</label>
                            <select id="agent-competitions-per-week">
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group" style="margin-top: 20px;">
                        <label style="margin-bottom: 10px;">Ø£ÙŠØ§Ù… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚</label>
                        <div class="days-selector-v2">
                            ${['Ø§Ù„Ø£Ø­Ø¯', 'Ø§Ù„Ø§Ø«Ù†ÙŠÙ†', 'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡', 'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡', 'Ø§Ù„Ø®Ù…ÙŠØ³', 'Ø§Ù„Ø¬Ù…Ø¹Ø©'].map((day, index) => `
                                <div class="day-toggle-wrapper">
                                    <input type="checkbox" id="day-${index}" value="${index}" class="day-toggle-input">
                                    <label for="day-${index}" class="day-toggle-btn">${day}</label>
                                </div>`).join('')}
                        </div>
                    </div>
                </div>

                <div class="form-actions-v2">
                    <button type="submit" id="save-agent-btn" class="btn-primary">Ø­ÙØ¸ Ø§Ù„ÙˆÙƒÙŠÙ„</button>
                    <button type="button" id="cancel-add-agent" class="btn-secondary">Ø¥Ù„ØºØ§Ø¡</button>
                </div>
            </form>
        </div>
    `;

    // --- Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­: Ø±Ø¨Ø· Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠØ© Ø¨Ø§Ù„ØªØµÙ†ÙŠÙ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ---
    const classificationSelect = document.getElementById('agent-classification');
    const competitionsGroup = document.getElementById('competitions-per-week-group');
    const competitionsPerWeekSelect = document.getElementById('agent-competitions-per-week');

    const updateCompetitionsPerWeek = () => {
        const classification = classificationSelect.value;
        if (classification === 'R' || classification === 'A') {
            competitionsPerWeekSelect.value = '2';
        } else if (classification === 'B' || classification === 'C') {
            competitionsPerWeekSelect.value = '1';
        }
    };

    classificationSelect.addEventListener('change', updateCompetitionsPerWeek);
    // --- MODIFICATION: Call the function on page load to set the initial value and ensure visibility ---
    updateCompetitionsPerWeek();
    // Avatar preview logic
    const avatarUploadInput = document.getElementById('avatar-upload');
    const avatarPreview = document.getElementById('avatar-preview');
    const avatarContainer = avatarPreview.closest('.profile-avatar-edit');

    if (avatarContainer) {
        avatarContainer.addEventListener('click', () => avatarUploadInput.click());
    }

    avatarUploadInput.addEventListener('change', () => {
        const file = avatarUploadInput.files[0];
        if (file) {
            avatarPreview.src = URL.createObjectURL(file);
        }
    });

    // --- Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­ Ø£: Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ÙÙˆØ±ÙŠ Ù…Ù† Ø±Ù‚Ù… Ø§Ù„ÙˆÙƒØ§Ù„Ø© ---
    const agentIdInput = document.getElementById('agent-id');
    const agentIdValidation = document.getElementById('agent-id-validation');
    agentIdInput.addEventListener('blur', async () => {
        const agentId = agentIdInput.value.trim();
        if (!agentId) {
            agentIdValidation.innerHTML = '';
            agentIdInput.classList.remove('invalid');
            return;
        }
        agentIdValidation.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚...';
        // --- STEP 3: MIGRATION TO CUSTOM BACKEND ---
        const response = await authedFetch(`/api/agents/check-uniqueness?agent_id=${agentId}`);
        const { exists, error } = await response.json();

        if (error) {
            agentIdValidation.innerHTML = '<span class="error-text">Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚</span>';
        } else if (exists) {
            agentIdValidation.innerHTML = '<span class="error-text"><i class="fas fa-times-circle"></i> Ø±Ù‚Ù… Ø§Ù„ÙˆÙƒØ§Ù„Ø© Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„</span>';
            agentIdInput.classList.add('invalid');
        } else {
            agentIdValidation.innerHTML = '<span class="success-text"><i class="fas fa-check-circle"></i> Ø§Ù„Ø±Ù‚Ù… Ù…ØªØ§Ø­</span>';
            agentIdInput.classList.remove('invalid');
        }
    });

    // --- Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­ Ø¨: Ø¥Ø¸Ù‡Ø§Ø± ØªÙ„Ù…ÙŠØ­ Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø±ØªØ¨Ø© ---
    const rankSelect = document.getElementById('agent-rank');
    const rankHint = document.getElementById('rank-hint');
    const updateRankHint = () => {
        const rank = rankSelect.value;
        const rankData = RANKS_DATA[rank] || {};
        let hintText = '';
        if (rankData.competition_bonus) {
            const bonus = rankData.competition_bonus === Infinity ? 'ØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯' : `$${rankData.competition_bonus}`;
            hintText += `ğŸ’° Ø¨ÙˆÙ†Øµ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª: <strong>${bonus}</strong>`;
        }
        if (rankData.deposit_bonus_count) {
            const count = rankData.deposit_bonus_count === Infinity ? 'ØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯' : rankData.deposit_bonus_count;
            hintText += ` | ğŸ Ø¨ÙˆÙ†Øµ Ø§Ù„Ø¥ÙŠØ¯Ø§Ø¹: <strong>${count} Ù…Ø±Ø§Øª</strong> Ø¨Ù†Ø³Ø¨Ø© <strong>${rankData.deposit_bonus_percentage}%</strong>`;
        }
        if (hintText) {
            rankHint.innerHTML = hintText;
            rankHint.style.display = 'block';
        } else {
            rankHint.style.display = 'none';
        }
    };

    rankSelect.addEventListener('change', updateRankHint);
    updateRankHint(); // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø£ÙˆÙ„ÙŠ Ù„Ø¹Ø±Ø¶ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©

    document.getElementById('agent-name').addEventListener('input', (e) => {
        avatarPreview.src = `https://ui-avatars.com/api/?name=${encodeURIComponent(e.target.value) || '?'}&background=8A2BE2&color=fff&size=128`;
    });

    const cancelButton = document.getElementById('cancel-add-agent');
    cancelButton.addEventListener('click', () => {
        const nameInput = document.getElementById('agent-name');
        const idInput = document.getElementById('agent-id');

        if (nameInput.value.trim() !== '' || idInput.value.trim() !== '') {
            showConfirmationModal(
                'ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± Ù…Ø­ÙÙˆØ¸Ø©. Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© ÙˆØ¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¥Ø¶Ø§ÙØ©ØŸ',
                () => {
                    window.location.hash = `#${returnPage}`;
                }, {
                    title: 'ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¥Ù„ØºØ§Ø¡',
                    confirmText: 'Ù†Ø¹Ù…ØŒ Ø¥Ù„ØºØ§Ø¡',
                    confirmClass: 'btn-danger'
                });
        } else {
            window.location.hash = `#${returnPage}`;
        }
    });

    document.getElementById('add-agent-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        // The check is now implicit in the authedFetch call

        const rank = document.getElementById('agent-rank').value;
        const rankData = RANKS_DATA[rank] || {};

        // --- NEW: Calculate competition_duration based on competitions_per_week ---
        const competitionsPerWeek = parseInt(document.getElementById('agent-competitions-per-week').value, 10);
        let competitionDuration = '48h'; // Default

        if (competitionsPerWeek === 2) {
            competitionDuration = '24h';
        } else if (competitionsPerWeek === 3) {
            // As 16h is not a standard option, we can default to 24h or handle as needed.
            competitionDuration = '24h';
        }

        const selectedDays = Array.from(document.querySelectorAll('.days-selector-v2 input:checked')).map(input => parseInt(input.value, 10));

        const newAgentData = {
            name: document.getElementById('agent-name').value,
            agent_id: document.getElementById('agent-id').value,
            classification: document.getElementById('agent-classification').value,
            audit_days: selectedDays,
            rank: rank,
            telegram_channel_url: document.getElementById('telegram-channel-url').value || null,
            telegram_group_url: document.getElementById('telegram-group-url').value || null,
            telegram_chat_id: document.getElementById('telegram-chat-id').value || null,
            telegram_group_name: document.getElementById('telegram-group-name').value || null,
            competition_bonus: rankData.competition_bonus,
            deposit_bonus_percentage: rankData.deposit_bonus_percentage,
            deposit_bonus_count: rankData.deposit_bonus_count,
            remaining_balance: rankData.competition_bonus,
            remaining_deposit_bonus: rankData.deposit_bonus_count,
            renewal_period: document.getElementById('agent-renewal-period').value,
            competitions_per_week: competitionsPerWeek, // --- FIX: Ensure this is added to the payload ---
            competition_duration: competitionDuration, // --- NEW: Add calculated duration ---
            prize_per_winner: 30, // --- NEW: Default prize per winner to $30 ---
        };

        // --- Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­ Ø¯: ØªØ£ÙƒÙŠØ¯ Ù‚Ø¨Ù„ Ø§Ù„Ø­ÙØ¸ ---
        const summaryHtml = `
            <div class="confirmation-summary-grid">
                <div class="summary-item"><strong>Ø§Ù„Ø§Ø³Ù…:</strong> ${newAgentData.name}</div>
                <div class="summary-item"><strong>Ø±Ù‚Ù… Ø§Ù„ÙˆÙƒØ§Ù„Ø©:</strong> ${newAgentData.agent_id}</div>
                <div class="summary-item"><strong>Ø§Ù„Ù…Ø±ØªØ¨Ø©:</strong> ${newAgentData.rank}</div>
                <div class="summary-item"><strong>Ø§Ù„ØªØµÙ†ÙŠÙ:</strong> ${newAgentData.classification}</div>
                <hr>
                <div class="summary-item"><strong><i class="fas fa-cogs"></i> Ø¨ÙŠØ§Ù†Ø§Øª ØªÙ„Ù‚Ø§Ø¦ÙŠØ©:</strong></div>
                <div class="summary-item"><strong>Ø¨ÙˆÙ†Øµ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª:</strong> ${newAgentData.competition_bonus === Infinity ? 'ØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯' : `$${newAgentData.competition_bonus || 0}`}</div>
                <div class="summary-item"><strong>Ø¨ÙˆÙ†Øµ Ø§Ù„Ø¥ÙŠØ¯Ø§Ø¹:</strong> ${newAgentData.deposit_bonus_count === Infinity ? 'ØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯' : (newAgentData.deposit_bonus_count || 0)} Ù…Ø±Ø§Øª Ø¨Ù†Ø³Ø¨Ø© ${newAgentData.deposit_bonus_percentage || 0}%</div>
                <div class="summary-item"><strong>Ù…Ø¯Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©:</strong> ${newAgentData.competition_duration}</div>
                <div class="summary-item"><strong>Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø£Ø³Ø¨ÙˆØ¹ÙŠØ§Ù‹:</strong> ${newAgentData.competitions_per_week}</div>
             </div>
            <p>Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØµØ­ÙŠØ­Ø©ØŸ</p>
        `;

        showConfirmationModal(
            summaryHtml,
            async () => {
                await saveAgent(newAgentData);
            }, {
                title: 'Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„',
                confirmText: 'Ù†Ø¹Ù…ØŒ Ø­ÙØ¸',
                confirmClass: 'btn-primary'
            }
        );
    });
}

async function saveAgent(newAgentData) {
    const saveBtn = document.getElementById('save-agent-btn');
    saveBtn.disabled = true;
    saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...';

    // --- STEP 3: MIGRATION TO CUSTOM BACKEND ---
    try {
        const rank = newAgentData.rank;
        const rankData = RANKS_DATA[rank] || {};

        // Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø±ØµØ¯Ø© Ù„Ù„ØªØ£ÙƒÙŠØ¯
        newAgentData.competition_bonus = rankData.competition_bonus;
        newAgentData.deposit_bonus_percentage = rankData.deposit_bonus_percentage;
        newAgentData.deposit_bonus_count = rankData.deposit_bonus_count;
        newAgentData.remaining_balance = rankData.competition_bonus;
        newAgentData.remaining_deposit_bonus = rankData.deposit_bonus_count;
        // --- FIX: Preserve competitions_per_week and competition_duration from the form ---
        // The original newAgentData object already has these values. We just need to make sure they are not overwritten.
        // No explicit re-assignment is needed if we don't nullify them.
        
        // --- Ø¥ØµÙ„Ø§Ø­: Ù…Ù†Ø·Ù‚ Ø®Ø§Øµ Ù„Ù…Ø±ØªØ¨Ø© "ÙˆÙƒÙŠÙ„ Ø­ØµØ±ÙŠ Ø¨Ø¯ÙˆÙ† Ù…Ø±ØªØ¨Ø©" ---
        if (rank === 'ÙˆÙƒÙŠÙ„ Ø­ØµØ±ÙŠ Ø¨Ø¯ÙˆÙ† Ù…Ø±ØªØ¨Ø©') {
            newAgentData.competition_bonus = 60;
            newAgentData.remaining_balance = 60;
            newAgentData.deposit_bonus_percentage = null;
            newAgentData.deposit_bonus_count = null;
            newAgentData.remaining_deposit_bonus = null;
        }

        // Send data to our new backend API
        const response = await authedFetch('/api/agents', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(newAgentData)
        });

        const result = await response.json();

        if (!response.ok) {
            throw new Error(result.message || 'ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„ÙˆÙƒÙŠÙ„.');
        }

        const insertedAgent = result.data;

        // TODO: Re-implement avatar upload. This will require a separate endpoint on the backend
        // that handles file uploads (e.g., using multer) and saves them to a folder or a cloud service like S3.

        await logAgentActivity(currentUserProfile?._id, insertedAgent._id, 'AGENT_CREATED', `ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ÙˆÙƒÙŠÙ„ Ø¬Ø¯ÙŠØ¯: ${insertedAgent.name}.`);
        showToast('ØªÙ…Øª Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙˆÙƒÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­!', 'success');
        window.allAgentsData = []; // Ù…Ø³Ø­ Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª Ù„Ù„ÙˆÙƒÙ„Ø§Ø¡ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø¬Ù„Ø¨Ù‡Ø§ Ø¹Ù†Ø¯ Ø§Ù„Ø¹ÙˆØ¯Ø©
        // Use replace to avoid adding the 'add-agent' page to history
        const newUrl = window.location.pathname + window.location.search + `#profile/${insertedAgent._id}`; // Use _id from MongoDB
        window.location.replace(newUrl);

    } catch (error) {
        console.error('Error saving agent:', error);
        showToast(`ÙØ´Ù„ Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙˆÙƒÙŠÙ„: ${error.message}`, 'error');
        saveBtn.disabled = false;
        saveBtn.innerHTML = 'Ø­ÙØ¸ Ø§Ù„ÙˆÙƒÙŠÙ„';
    }
}

function renderBulkAddAgentsModal() {
    const modalContent = `
        <div class="form-layout" style="gap: 15px;">
            <div class="form-group">
                <label for="bulk-agents-data">
                    <i class="fas fa-paste"></i> Ø§Ù„ØµÙ‚ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ù‡Ù†Ø§
                </label>
                <p class="form-hint">
                    ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…ÙØµÙˆÙ„Ø© Ø¨Ù…Ø³Ø§ÙØ© Tab (ÙŠÙ…ÙƒÙ†Ùƒ Ù†Ø³Ø®Ù‡Ø§ Ù…Ù† Ø¬Ø¯ÙˆÙ„ Excel).<br>
                    Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù„Ù„Ø£Ø¹Ù…Ø¯Ø©: <strong>Ø§Ù„Ø§Ø³Ù…ØŒ Ø±Ù‚Ù… Ø§Ù„ÙˆÙƒØ§Ù„Ø©ØŒ Ø§Ù„ØªØµÙ†ÙŠÙØŒ Ø§Ù„Ù…Ø±ØªØ¨Ø©ØŒ ÙØªØ±Ø© Ø§Ù„ØªØ¬Ø¯ÙŠØ¯ØŒ Ø£ÙŠØ§Ù… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ØŒ Ø±Ø§Ø¨Ø· Ø§Ù„Ù‚Ù†Ø§Ø©ØŒ Ø±Ø§Ø¨Ø· Ø§Ù„Ø¬Ø±ÙˆØ¨ØŒ Ù…Ø¹Ø±Ù Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©ØŒ Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©ØŒ Ù…Ø¯Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© (24h Ø£Ùˆ 48h Ø£Ùˆ 5s Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±)</strong>
                </p>
                <textarea id="bulk-agents-data" rows="15" placeholder="Ù…Ø«Ø§Ù„:\nØ£Ø­Ù…Ø¯ Ø¹Ù„ÙŠ\t12345\tR\tGrowth\tweekly\t1,3,5\thttps://t.me/channel\thttps://t.me/group\t-100123\tGroup Name\t48h"></textarea>
            </div>
        </div>
    `;

    showConfirmationModal(
        modalContent,
        () => {
            const data = document.getElementById('bulk-agents-data').value;
            handleBulkAddAgents(data);
        },
        {
            title: 'Ø¥Ø¶Ø§ÙØ© ÙˆÙƒÙ„Ø§Ø¡ Ø¯ÙØ¹Ø© ÙˆØ§Ø­Ø¯Ø©',
            confirmText: 'Ø¨Ø¯Ø¡ Ø§Ù„Ø¥Ø¶Ø§ÙØ©',
            confirmClass: 'btn-primary',
            modalClass: 'modal-fullscreen'
        }
    );
}

async function handleBulkAddAgents(data) {
    const lines = data.trim().split('\n');
    if (lines.length === 0 || (lines.length === 1 && lines[0].trim() === '')) {
        showToast('Ù„Ù… ÙŠØªÙ… Ø¥Ø¯Ø®Ø§Ù„ Ø£ÙŠ Ø¨ÙŠØ§Ù†Ø§Øª.', 'info');
        return;
    }

    const allParsedAgents = [];
    const errors = [];
    const validRenewalPeriods = ['none', 'weekly', 'biweekly', 'monthly'];
    
    // --- NEW: Create a lowercase to correct-case map for ranks ---
    const rankMap = Object.keys(RANKS_DATA).reduce((map, rank) => {
        map[rank.toLowerCase()] = rank;
        return map;
    }, {});
    // --- NEW: Mappings for Arabic input ---
    const renewalPeriodMap = {
        'Ø§Ø³Ø¨ÙˆØ¹': 'weekly', 'Ø£Ø³Ø¨ÙˆØ¹ÙŠ': 'weekly',
        'Ø§Ø³Ø¨ÙˆØ¹ÙŠÙ†': 'biweekly', 'ÙƒÙ„ Ø£Ø³Ø¨ÙˆØ¹ÙŠÙ†': 'biweekly',
        'Ø´Ù‡Ø±': 'monthly', 'Ø´Ù‡Ø±ÙŠ': 'monthly',
        'Ø¨Ø¯ÙˆÙ†': 'none'
    };
    const auditDayMap = {
        'Ø§Ù„Ø§Ø­Ø¯': 0, 'Ø§Ù„Ø£Ø­Ø¯': 0,
        'Ø§Ù„Ø§Ø«Ù†ÙŠÙ†': 1, 'Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†': 1,
        'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡': 2,
        'Ø§Ù„Ø§Ø±Ø¨Ø¹Ø§Ø¡': 3, 'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡': 3,
        'Ø§Ù„Ø®Ù…ÙŠØ³': 4,
        'Ø§Ù„Ø¬Ù…Ø¹Ø©': 5,
    };

    lines.forEach((line, index) => {
        // --- NEW: Skip empty lines ---
        if (!line.trim()) {
            return;
        }

        // --- IMPROVEMENT: Trim trailing empty fields to prevent errors from extra columns in Excel ---
        let fields = line.split('\t').map(f => f.trim());
        while (fields.length > 0 && fields[fields.length - 1] === '') {
            fields.pop();
        }

        if (fields.length < 4) { // At least Name, ID, Classification, Rank are required
            errors.push(`Ø§Ù„Ø³Ø·Ø± ${index + 1}: Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ù‚ÙˆÙ„ ØºÙŠØ± ÙƒØ§ÙÙ.`);
            return;
        }

        const [
            name, agent_id, classification, rank, 
            renewal_period = 'none', 
            audit_days_str = '', 
            telegram_channel_url = '', 
            telegram_group_url = '', 
            telegram_chat_id = '', 
            telegram_group_name = '',
            competition_duration = null,
            competitions_per_week_str = ''] = fields; // --- NEW: Read competitions per week ---

        if (!name || !agent_id || !classification || !rank) { // --- IMPROVEMENT: More specific error message ---
            errors.push(`Ø§Ù„Ø³Ø·Ø± ${index + 1}: Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© (Ø§Ù„Ø§Ø³Ù…ØŒ Ø§Ù„Ø±Ù‚Ù…ØŒ Ø§Ù„ØªØµÙ†ÙŠÙØŒ Ø§Ù„Ù…Ø±ØªØ¨Ø©) Ù…Ø·Ù„ÙˆØ¨Ø©.`);
            return;
        }

        const correctRank = rankMap[rank.toLowerCase()];
        if (!correctRank) {
            errors.push(`Ø§Ù„Ø³Ø·Ø± ${index + 1}: Ø§Ù„Ù…Ø±ØªØ¨Ø© "${rank}" ØºÙŠØ± ØµØ§Ù„Ø­Ø©.`);
            return;
        }

        // --- NEW: Process renewal period with Arabic mapping ---
        const processedRenewalPeriod = renewalPeriodMap[renewal_period.toLowerCase()] || renewal_period.toLowerCase();
        if (!validRenewalPeriods.includes(processedRenewalPeriod)) {
            errors.push(`Ø§Ù„Ø³Ø·Ø± ${index + 1}: ÙØªØ±Ø© Ø§Ù„ØªØ¬Ø¯ÙŠØ¯ "${renewal_period}" ØºÙŠØ± ØµØ§Ù„Ø­Ø©.`);
            return;
        }

        // --- NEW: Process audit days with Arabic mapping ---
        const audit_days = audit_days_str
            .split(/[,/]/) // Split by comma or slash
            .map(dayName => auditDayMap[dayName.trim()])
            .filter(dayIndex => dayIndex !== undefined && dayIndex >= 0 && dayIndex <= 6);

        // --- MODIFIED: Validate and normalize competition_duration ---
        let processed_competition_duration = null;
        if (competition_duration) {
            // Normalize input: "24 h" -> "24h", "24" -> "24"
            const normalized = competition_duration.trim().replace(/\s/g, ''); 
            if (normalized === '5s') {
                processed_competition_duration = '5s';
            } else if (normalized.startsWith('24')) {
                processed_competition_duration = '24h';
            } else if (normalized.startsWith('48')) {
                processed_competition_duration = '48h'; // --- IMPROVEMENT: More specific error message ---
            } else {
                errors.push(`Ø§Ù„Ø³Ø·Ø± ${index + 1}: Ù…Ø¯Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© "${competition_duration}" ØºÙŠØ± ØµØ§Ù„Ø­Ø©. ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† '24h' Ø£Ùˆ '48h' Ø£Ùˆ '5s'.`);
                return;
            }
        }

        // --- NEW: Process competitions_per_week ---
        let competitions_per_week = parseInt(competitions_per_week_str, 10);
        if (isNaN(competitions_per_week)) {
            // If not provided or invalid, set it automatically based on classification
            if (classification.toUpperCase() === 'R' || classification.toUpperCase() === 'A') {
                competitions_per_week = 2;
            } else { // B or C
                competitions_per_week = 1;
            }
        }

        // --- NEW: Calculate competition_duration based on competitions_per_week ---
        let competition_duration_calculated = '48h'; // Default
        if (competitions_per_week === 2) {
            competition_duration_calculated = '24h';
        } else if (competitions_per_week === 3) {
            competition_duration_calculated = '24h'; // Fallback for 16h
        }
        // If a duration is explicitly provided in the sheet, it will override the calculated one.
        const final_competition_duration = processed_competition_duration || competition_duration_calculated;

        const rankData = RANKS_DATA[correctRank];
        const newAgent = {
            name,
            agent_id,
            classification: classification.toUpperCase(),
            rank: correctRank,
            renewal_period: processedRenewalPeriod,
            audit_days,
            telegram_channel_url: telegram_channel_url || null,
            telegram_group_url: telegram_group_url || null,
            telegram_chat_id: telegram_chat_id || null,
            telegram_group_name: telegram_group_name || null,
            competition_bonus: rankData.competition_bonus || 0,
            deposit_bonus_percentage: rankData.deposit_bonus_percentage || 0,
            deposit_bonus_count: rankData.deposit_bonus_count || 0,
            remaining_balance: rankData.competition_bonus || 0,
            remaining_deposit_bonus: rankData.deposit_bonus_count || 0,
            consumed_balance: 0,
            used_deposit_bonus: 0,
            status: 'Active',
            competition_duration: final_competition_duration, // --- MODIFIED: Use the final duration ---
            competitions_per_week, // --- NEW: Add the processed value ---
        };
        allParsedAgents.push(newAgent);
    });

    if (errors.length > 0) {
        showToast(`ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ${errors.length} Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. ÙŠØ±Ø¬Ù‰ ØªØµØ­ÙŠØ­Ù‡Ø§ ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.`, 'error'); // --- IMPROVEMENT: More specific error message ---
        // Optionally, show a modal with all errors
        return;
    }

    // --- NEW: Logic to separate agents for insertion and update ---
    const uniqueAgentsMap = new Map();
    for (const agent of allParsedAgents) {
        // Use agent_id as the unique key to de-duplicate the input list, ensuring the last entry wins.
        uniqueAgentsMap.set(agent.agent_id, agent);
    }
    const uniqueAgents = Array.from(uniqueAgentsMap.values());
    const ignoredForInputDuplication = allParsedAgents.length - uniqueAgents.length;

    if (uniqueAgents.length === 0) {
        showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª ØµØ§Ù„Ø­Ø© Ù„Ù„Ø¥Ø¶Ø§ÙØ© Ø£Ùˆ Ø§Ù„ØªØ­Ø¯ÙŠØ«.', 'info');
        return;
    }

    // --- MODIFIED: Process in chunks to avoid overly long URLs ---
    const CHUNK_SIZE = 100; // Process 100 agents at a time
    let allExistingAgents = [];
    let checkError = null;

    // --- NEW: Check for existing agents against the database ---
    for (let i = 0; i < uniqueAgents.length; i += CHUNK_SIZE) {
        const chunk = uniqueAgents.slice(i, i + CHUNK_SIZE);
        const agentIds = chunk.map(a => a.agent_id);
        const query = `agent_ids=${agentIds.join(',')}&select=_id,name,agent_id&limit=${CHUNK_SIZE}`;
        const response = await authedFetch(`/api/agents?${query}`);
        const result = await response.json();

        if (!response.ok) {
            checkError = new Error(result.message || 'ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ÙŠÙ†.');
            break; // Stop on the first error
        }
        if (result.data) {
            allExistingAgents.push(...result.data);
        }
    }

    if (checkError) {
        showToast(`Ø®Ø·Ø£: ${checkError.message}`, 'error');
        return;
    }
    
    const existingAgentsMap = new Map();
    allExistingAgents.forEach(agent => {
        // --- IMPROVEMENT: Map by both agent_id and name for more robust checking ---
        existingAgentsMap.set(agent.agent_id, agent);
        existingAgentsMap.set(agent.name, agent);
    });

    const agentsToInsert = [];
    const agentsToUpdate = [];

    uniqueAgents.forEach(agent => {
        const existing = existingAgentsMap.get(agent.agent_id) || existingAgentsMap.get(agent.name);
        if (existing) {
            // Agent exists, add to update list with its database _id
            agentsToUpdate.push({ ...agent, id: existing._id });
        } else {
            // Add to insert list
            agentsToInsert.push(agent);
        }
    });

    const totalOperations = agentsToInsert.length + agentsToUpdate.length;
    if (totalOperations === 0) {
        showToast(`ØªÙ… ØªØ¬Ø§Ù‡Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ (${allParsedAgents.length}) Ù„ÙˆØ¬ÙˆØ¯Ù‡Ù… Ù…Ø³Ø¨Ù‚Ø§Ù‹ Ø£Ùˆ Ø¨Ø³Ø¨Ø¨ ØªÙƒØ±Ø§Ø± ÙÙŠ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª.`, 'warning');
        return;
    }

    let successCount = 0;
    let errorCount = 0;
    let processedCount = 0;

    // --- IMPROVEMENT: More descriptive progress modal ---
    const modalContent = `
        <div class="update-progress-container">
            <i class="fas fa-users-cog update-icon"></i>
            <h3 id="bulk-send-status-text">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©...</h3>
            <div class="progress-bar-outer">
                <div id="bulk-send-progress-bar-inner" class="progress-bar-inner"></div>
            </div>
        </div>
    `;
    const progressModalOverlay = showProgressModal('Ø¥Ø¶Ø§ÙØ© ÙˆØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡', modalContent);

    const progressBar = document.getElementById('bulk-send-progress-bar-inner');
    const statusText = document.getElementById('bulk-send-status-text');

    // --- NEW: Process agents one by one to show real-time progress and reduce server load ---
    for (const agent of agentsToInsert) {
        processedCount++;
        statusText.innerHTML = `Ø¬Ø§Ø±ÙŠ Ø¥Ø¶Ø§ÙØ© ÙˆÙƒÙŠÙ„: ${agent.name} (${processedCount}/${totalOperations})`;
        try {
            const response = await authedFetch('/api/agents', { method: 'POST', body: JSON.stringify(agent) });
            const result = await response.json();
            if (!response.ok) throw new Error(result.message);
            successCount++;
        } catch (e) {
            errorCount++;
        }
        progressBar.style.width = `${(processedCount / totalOperations) * 100}%`;
        await new Promise(resolve => setTimeout(resolve, 500)); // --- NEW: Add 500ms delay ---
    }

    for (const agent of agentsToUpdate) {
        processedCount++;
        statusText.innerHTML = `Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ« ÙˆÙƒÙŠÙ„: ${agent.name} (${processedCount}/${totalOperations})`;
        try {
            // The agent object already contains the 'id' field needed for the URL
            const response = await authedFetch(`/api/agents/${agent.id}`, { method: 'PUT', body: JSON.stringify(agent) });
            const result = await response.json();
            if (!response.ok) throw new Error(result.message);
            successCount++;
        } catch (e) {
            errorCount++;
        }
        progressBar.style.width = `${(processedCount / totalOperations) * 100}%`;
        await new Promise(resolve => setTimeout(resolve, 500)); // --- NEW: Add 500ms delay ---
    }

    progressBar.style.backgroundColor = errorCount > 0 ? 'var(--warning-color)' : 'var(--success-color)';
    
    let finalMessage = `Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.<br>`;
    finalMessage += `<strong>${successCount}</strong> Ø¹Ù…Ù„ÙŠØ© Ù†Ø§Ø¬Ø­Ø© | <strong>${errorCount}</strong> ÙØ´Ù„`;
    const totalIgnored = ignoredForInputDuplication;
    if (totalIgnored > 0) finalMessage += ` | <strong>${totalIgnored}</strong> ØªÙ… ØªØ¬Ø§Ù‡Ù„Ù‡Ù… Ù„Ù„ØªÙƒØ±Ø§Ø±.`;

    statusText.innerHTML = finalMessage;
    document.querySelector('.modal-no-actions .update-icon').className = 'fas fa-check-circle update-icon';
    
    await logAgentActivity(null, 'BULK_AGENT_UPSERT', `Ø¥Ø¶Ø§ÙØ© Ø¬Ù…Ø§Ø¹ÙŠØ©: ${agentsToInsert.length} Ø¬Ø¯ÙŠØ¯, ${agentsToUpdate.length} ØªØ­Ø¯ÙŠØ«, ${totalIgnored} ØªØ¬Ø§Ù‡Ù„.`);
    showToast('Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠØ©.', 'success');

    // Refresh the agents list
    allAgentsData = []; // Clear cache
    await renderManageAgentsPage();

    // Auto-close progress modal
    setTimeout(() => {
        if (progressModalOverlay) {
            progressModalOverlay.remove();
        }
    }, 4000);
}


// == activityLog.js ==
ï»¿const LOGS_PER_PAGE = 25;
const LOG_ACTION_TYPES = {
    // Auth & Session
    'USER_LOGIN': 'ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„',
    'USER_LOGOUT': 'ØªØ³Ø¬ÙŠÙ„ Ø®Ø±ÙˆØ¬',
    'LOGIN': 'ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„',
    'LOGOUT': 'ØªØ³Ø¬ÙŠÙ„ Ø®Ø±ÙˆØ¬',
    
    // Agent Actions
    'AGENT_CREATED': 'Ø¥Ù†Ø´Ø§Ø¡ ÙˆÙƒÙŠÙ„',
    'AGENT_DELETED': 'Ø­Ø°Ù ÙˆÙƒÙŠÙ„',
    'AGENT_BULK_DELETE': 'Ø­Ø°Ù Ø¬Ù…Ø§Ø¹ÙŠ Ù„Ù„ÙˆÙƒÙ„Ø§Ø¡',
    'AGENT_EDIT': 'ØªØ¹Ø¯ÙŠÙ„ ÙˆÙƒÙŠÙ„',
    'POST_AGENTS': 'Ø¥Ù†Ø´Ø§Ø¡ ÙˆÙƒÙŠÙ„',
    'PUT_AGENTS': 'ØªØ­Ø¯ÙŠØ« ÙˆÙƒÙŠÙ„',
    'DELETE_AGENTS': 'Ø­Ø°Ù ÙˆÙƒÙŠÙ„',
    
    // Profile & Details
    'PROFILE_UPDATE': 'ØªØ­Ø¯ÙŠØ« Ù…Ù„Ù Ø´Ø®ØµÙŠ',
    'PROFILE_VIEW': 'Ø¹Ø±Ø¶ Ù…Ù„Ù Ø´Ø®ØµÙŠ',
    'DETAILS_UPDATE': 'ØªØ­Ø¯ÙŠØ« ØªÙØ§ØµÙŠÙ„',
    
    // Renewal
    'MANUAL_RENEWAL': 'ØªØ¬Ø¯ÙŠØ¯ Ø±ØµÙŠØ¯ ÙŠØ¯ÙˆÙŠ',
    'AUTO_RENEWAL': 'ØªØ¬Ø¯ÙŠØ¯ Ø±ØµÙŠØ¯ ØªÙ„Ù‚Ø§Ø¦ÙŠ',
    'AGENT_BULK_RENEW': 'ØªØ¬Ø¯ÙŠØ¯ Ø±ØµÙŠØ¯ Ø¬Ù…Ø§Ø¹ÙŠ',
    
    // Competitions
    'COMPETITION_CREATED': 'Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø©',
    'COMPETITION_UPDATE': 'ØªØ­Ø¯ÙŠØ« Ù…Ø³Ø§Ø¨Ù‚Ø©',
    'COMPETITION_DELETED': 'Ø­Ø°Ù Ù…Ø³Ø§Ø¨Ù‚Ø©',
    'COMPETITION_EXPIRED': 'Ø§Ù†ØªÙ‡Ø§Ø¡ ØµÙ„Ø§Ø­ÙŠØ© Ù…Ø³Ø§Ø¨Ù‚Ø©',
    'POST_COMPETITIONS': 'Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø©',
    'PUT_COMPETITIONS': 'ØªØ­Ø¯ÙŠØ« Ù…Ø³Ø§Ø¨Ù‚Ø©',
    'DELETE_COMPETITIONS': 'Ø­Ø°Ù Ù…Ø³Ø§Ø¨Ù‚Ø©',
    
    // Tasks
    'TASK_UPDATE': 'ØªØ­Ø¯ÙŠØ« Ù…Ù‡Ù…Ø©',
    'TASK_CREATED': 'Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‡Ù…Ø©',
    'TASK_DELETED': 'Ø­Ø°Ù Ù…Ù‡Ù…Ø©',
    'POST_TASKS': 'Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‡Ù…Ø©',
    'PUT_TASKS': 'ØªØ­Ø¯ÙŠØ« Ù…Ù‡Ù…Ø©',
    'DELETE_TASKS': 'Ø­Ø°Ù Ù…Ù‡Ù…Ø©',
    'TASK_COMPLETED': 'Ù…Ù‡Ù…Ø© Ù…ÙƒØªÙ…Ù„Ø©',
    'TASK_UNCOMPLETED': 'Ù…Ù‡Ù…Ø© ØºÙŠØ± Ù…ÙƒØªÙ…Ù„Ø©',
    
    // Users
    'USER_CREATED': 'Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªØ®Ø¯Ù…',
    'USER_UPDATED': 'ØªØ­Ø¯ÙŠØ« Ù…Ø³ØªØ®Ø¯Ù…',
    'USER_DELETED': 'Ø­Ø°Ù Ù…Ø³ØªØ®Ø¯Ù…',
    'USER_VIEW': 'Ø¹Ø±Ø¶ Ù…Ø³ØªØ®Ø¯Ù…',
    'GET_USERS': 'Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†',
    'POST_USERS': 'Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªØ®Ø¯Ù…',
    'PUT_USERS': 'ØªØ­Ø¯ÙŠØ« Ù…Ø³ØªØ®Ø¯Ù…',
    'DELETE_USERS': 'Ø­Ø°Ù Ù…Ø³ØªØ®Ø¯Ù…',
    
    // Calendar
    'GET_CALENDAR': 'Ø¹Ø±Ø¶ Ø§Ù„ØªÙ‚ÙˆÙŠÙ…',
    'GET_DATA': 'Ø¹Ø±Ø¶ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª',
    'POST_DATA': 'Ø¥Ø¶Ø§ÙØ© Ø¨ÙŠØ§Ù†Ø§Øª',
    'PUT_DATA': 'ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª',
    'DELETE_DATA': 'Ø­Ø°Ù Ø¨ÙŠØ§Ù†Ø§Øª',
    'VIEW_DATA': 'Ø¹Ø±Ø¶ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª',
    
    // Templates
    'GET_TEMPLATES': 'Ø¹Ø±Ø¶ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨',
    'POST_TEMPLATES': 'Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ù„Ø¨',
    'PUT_TEMPLATES': 'ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ù„Ø¨',
    'DELETE_TEMPLATES': 'Ø­Ø°Ù Ù‚Ø§Ù„Ø¨',
    'TEMPLATE_CREATED': 'Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ù„Ø¨',
    'TEMPLATE_UPDATED': 'ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ù„Ø¨',
    'TEMPLATE_DELETED': 'Ø­Ø°Ù Ù‚Ø§Ù„Ø¨',
    
    // Stats & Analytics
    'GET_STATS': 'Ø¹Ø±Ø¶ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª',
    'GET_ANALYTICS': 'Ø¹Ø±Ø¶ Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª',
    
    // System
    'SYSTEM_TASK': 'Ù…Ù‡Ù…Ø© Ù†Ø¸Ø§Ù…',
    'TELEGRAM_ERROR': 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙ„Ø¬Ø±Ø§Ù…',
};

// Map common API endpoints + methods to friendly Arabic labels
function mapEndpointToArabic(method, endpoint) {
    if (!method || !endpoint) return '';
    const clean = endpoint.split('?')[0].replace(/\/$/, '');
    const parts = clean.split('/').filter(Boolean); // ['api','users', ...]

    // direct special cases
    if (/\/api\/auth\/login$/i.test(clean)) return 'ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„';
    if (/\/api\/auth\/logout$/i.test(clean)) return 'ØªØ³Ø¬ÙŠÙ„ Ø®Ø±ÙˆØ¬';

    const joinLastTwo = parts.slice(-2).join('/');
    const last = parts.slice(-1)[0] || '';

    const resourceMap = {
        'agents': 'ÙˆÙƒÙŠÙ„', 'agent': 'ÙˆÙƒÙŠÙ„',
        'users': 'Ù…Ø³ØªØ®Ø¯Ù…', 'user': 'Ù…Ø³ØªØ®Ø¯Ù…',
        'competitions': 'Ù…Ø³Ø§Ø¨Ù‚Ø©', 'competition': 'Ù…Ø³Ø§Ø¨Ù‚Ø©',
        'templates': 'Ù‚Ø§Ù„Ø¨', 'template': 'Ù‚Ø§Ù„Ø¨',
        'tasks': 'Ù…Ù‡Ù…Ø©', 'task': 'Ù…Ù‡Ù…Ø©',
        'logs': 'Ø³Ø¬Ù„',
    };

    const pick = (key) => resourceMap[key] || null;

    let resWord = pick(joinLastTwo) || pick(last);

    // If resource not found, try some educated guesses
    if (!resWord && last) {
        // crude singularization for english plurals
        const singular = last.replace(/s$/i, '');
        resWord = pick(singular) || null;
    }

    if (resWord) {
        if (method === 'POST') return `Ø¥Ù†Ø´Ø§Ø¡ ${resWord}`;
        if (method === 'DELETE') return `Ø­Ø°Ù ${resWord}`;
        if (method === 'GET') return `Ø¬Ù„Ø¨ ${resWord}${['Ù…Ø³ØªØ®Ø¯Ù…','ÙˆÙƒÙŠÙ„'].includes(resWord) ? 'ÙŠÙ†' : 'Ø§Øª'}`;
        if (method === 'PUT' || method === 'PATCH') return `ØªØ­Ø¯ÙŠØ« ${resWord}`;
    }

    // Generic fallback by method
    if (method === 'GET') return 'Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª';
    if (method === 'POST') return 'Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª';
    if (method === 'DELETE') return 'Ø­Ø°Ù Ø¨ÙŠØ§Ù†Ø§Øª';
    if (method === 'PUT' || method === 'PATCH') return 'ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª';
    return '';
}

// Utility function for HTML escaping
const esc = (s) => String(s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

let activityLogViewMode = 'table'; // 'table' | 'cards' | 'timeline'
// Infinite scroll state (for cards & timeline)
let activityLogCurrentPage = 1;
let activityLogTotalPages = 1;
let activityLogAllLogs = [];
let activityLogObserver = null;
const activityLogDebouncers = {};

function debounceActivityLog(key, fn, delay = 400) {
    if (activityLogDebouncers[key]) clearTimeout(activityLogDebouncers[key]);
    activityLogDebouncers[key] = setTimeout(fn, delay);
}

function resetActivityLogState() {
    activityLogCurrentPage = 1;
    activityLogTotalPages = 1;
    activityLogAllLogs = [];
    if (activityLogObserver) {
        activityLogObserver.disconnect();
        activityLogObserver = null;
    }
}

async function renderActivityLogPage() {
    const appContent = document.getElementById('app-content');
    // Ensure user profile is loaded (fallback if navigation is early)
    if (!window.currentUserProfile) {
        try {
            const cached = localStorage.getItem('userProfile');
            if (cached) {
                window.currentUserProfile = JSON.parse(cached);
            } else {
                const resp = await authedFetch('/api/auth/me');
                if (resp.ok) {
                    window.currentUserProfile = await resp.json();
                    localStorage.setItem('userProfile', JSON.stringify(window.currentUserProfile));
                }
            }
        } catch (e) {
            console.warn('[ActivityLog] Failed to hydrate user profile early:', e.message);
        }
    }

    // --- Permission Check ---
    const currentRoleRaw = window.currentUserProfile?.role;
    console.debug('[ActivityLog] Detected current user role:', currentRoleRaw);
    // Support multiple casing / legacy variants just in case
    const normalizedRole = typeof currentRoleRaw === 'string' ? currentRoleRaw.trim().toLowerCase() : '';
    const isSuperAdmin = ['super_admin', 'superadmin', 'owner'].includes(normalizedRole);
    const isAdmin = isSuperAdmin || normalizedRole === 'admin';

    // --- MODIFICATION: Restrict access to Admins and Super Admins only ---
    if (!isAdmin) {
        appContent.innerHTML = `
            <div class="access-denied-container">
                <i class="fas fa-lock"></i>
                <h2>Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© ÙˆØµÙˆÙ„</h2>
                <p>Ø£Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø¯ÙŠØ±.</p>
            </div>`;
        return;
    }

    appContent.innerHTML = `
        <div class="page-header column-header">
            <div class="header-top-row">
                <h1><i class="fas fa-history"></i> Ø³Ø¬Ù„ Ù†Ø´Ø§Ø· Ø§Ù„Ù…ÙˆÙ‚Ø¹</h1>
                <div class="view-mode-switch">
                    <button id="view-table-btn" class="view-mode-btn active" data-mode="table" title="Ø¹Ø±Ø¶ Ø¬Ø¯ÙˆÙ„ÙŠ"><i class="fas fa-table"></i></button>
                </div>
            </div>
            <div class="filters-container">
                <div class="filter-group">
                    <label for="log-user-filter">ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…</label>
                    <select id="log-user-filter">
                        <option value="all">ÙƒÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†</option>
                        <!-- User options will be populated here -->
                    </select>
                </div>
                <div class="filter-group">
                    <label for="log-action-filter">ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡</label>
                    <select id="log-action-filter">
                        <option value="all">ÙƒÙ„ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</option>
                        ${Object.entries(LOG_ACTION_TYPES).map(([key, value]) => `<option value="${key}">${value}</option>`).join('')}
                    </select>
                </div>
                <div class="filter-group">
                    <label for="log-sort-select">ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨</label>
                    <select id="log-sort-select">
                        <option value="newest">Ø§Ù„Ø£Ø­Ø¯Ø« Ø£ÙˆÙ„Ø§Ù‹</option>
                        <option value="oldest">Ø§Ù„Ø£Ù‚Ø¯Ù… Ø£ÙˆÙ„Ø§Ù‹</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="log-date-from">Ù…Ù† ØªØ§Ø±ÙŠØ®</label>
                    <input type="date" id="log-date-from">
                </div>
                <div class="filter-group">
                    <label for="log-date-to">Ø¥Ù„Ù‰ ØªØ§Ø±ÙŠØ®</label>
                    <input type="date" id="log-date-to">
                </div>
                <div class="filter-group">
                    <label for="log-search-text">Ø¨Ø­Ø« Ù†ØµÙŠ</label>
                    <input type="search" id="log-search-text" placeholder="Ø§Ø¨Ø­Ø« ÙÙŠ Ø§Ù„ÙˆØµÙ...">
                </div>
                <div class="filter-actions">
                    <button id="apply-log-filters" class="btn-primary"><i class="fas fa-filter"></i> ØªØ·Ø¨ÙŠÙ‚</button>
                    <button id="reset-log-filters" class="btn-secondary"><i class="fas fa-undo"></i> Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†</button>
                    <button id="export-log-csv" class="btn-secondary"><i class="fas fa-file-csv"></i> ØªØµØ¯ÙŠØ± CSV</button>
                    <button id="bulk-delete-logs-btn" class="btn-danger" style="display:none;"><i class="fas fa-trash-alt"></i> Ø­Ø°Ù Ø§Ù„Ù…Ø­Ø¯Ø¯</button>
                    <label class="auto-refresh-label"><input type="checkbox" id="auto-refresh-logs"> ØªØ­Ø¯ÙŠØ« ØªÙ„Ù‚Ø§Ø¦ÙŠ</label>
                    ${isSuperAdmin ? '<button id="purge-all-logs-btn" class="btn-danger" style="margin-inline-start:8px;"><i class="fas fa-exclamation-triangle"></i> Ø­Ø°Ù ÙƒÙ„ Ø§Ù„Ø³Ø¬Ù„Ø§Øª</button>' : ''}
                </div>
            </div>
        </div>
        <div id="activity-log-container">
            <div class="loader-container"><div class="spinner"></div></div>
        </div>

        <!-- Purge Confirmation Modal -->
        <div id="purge-confirm-modal" class="modal" style="display:none;">
            <div class="modal-content" style="max-width:500px;">
                <div class="modal-header" style="background:#dc3545;color:white;">
                    <h2><i class="fas fa-exclamation-triangle"></i> ØªØ­Ø°ÙŠØ± Ø´Ø¯ÙŠØ¯</h2>
                    <button class="modal-close" id="purge-modal-close">&times;</button>
                </div>
                <div class="modal-body" style="padding:30px;text-align:center;">
                    <i class="fas fa-exclamation-circle" style="font-size:60px;color:#dc3545;margin-bottom:20px;"></i>
                    <h3 style="color:#dc3545;margin-bottom:15px;">Ø³ÙŠØªÙ… Ø­Ø°Ù ÙƒÙ„ Ø§Ù„Ø³Ø¬Ù„Ø§Øª Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹</h3>
                    <p style="font-size:16px;margin-bottom:20px;color:#666;">Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡. Ø³ÙŠØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ù†Ø´Ø§Ø· Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ Ø¯Ø§Ø¦Ù….</p>
                    <div style="background:#fff3cd;border:1px solid #ffc107;padding:15px;border-radius:8px;margin-bottom:20px;">
                        <p style="margin:0;font-weight:bold;color:#856404;">Ù„Ù„ØªØ£ÙƒÙŠØ¯ØŒ Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ø§Ù„ØªØ§Ù„ÙŠ:</p>
                        <p style="margin:10px 0;font-size:18px;color:#dc3545;font-weight:bold;">DELETE ALL</p>
                    </div>
                    <input type="text" id="purge-confirm-input" placeholder="Ø§ÙƒØªØ¨ DELETE ALL Ù‡Ù†Ø§" style="width:100%;padding:12px;font-size:16px;border:2px solid #ddd;border-radius:6px;text-align:center;margin-bottom:20px;">
                    <div style="display:flex;gap:10px;justify-content:center;">
                        <button id="purge-confirm-btn" class="btn-danger" style="padding:12px 30px;font-size:16px;">
                            <i class="fas fa-trash-alt"></i> ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
                        </button>
                        <button id="purge-cancel-btn" class="btn-secondary" style="padding:12px 30px;font-size:16px;">
                            <i class="fas fa-times"></i> Ø¥Ù„ØºØ§Ø¡
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    // View mode listeners
    appContent.querySelectorAll('.view-mode-btn').forEach(btn => {
        btn.addEventListener('click', e => {
            const mode = e.currentTarget.dataset.mode;
            if (mode && ['table','cards','timeline'].includes(mode)) {
                activityLogViewMode = mode;
                resetActivityLogState();
                appContent.querySelectorAll('.view-mode-btn').forEach(b=>b.classList.remove('active'));
                e.currentTarget.classList.add('active');
                fetchAndDisplayLogs(1);
            }
        });
    });
    document.getElementById('apply-log-filters').addEventListener('click', () => { resetActivityLogState(); fetchAndDisplayLogs(1); });
    document.getElementById('reset-log-filters').addEventListener('click', () => {
        ['log-user-filter', 'log-action-filter', 'log-sort-select'].forEach(id => document.getElementById(id).selectedIndex = 0);
        resetActivityLogState();
        const searchInput = document.getElementById('log-search-text'); if (searchInput) searchInput.value = '';
        fetchAndDisplayLogs(1);
    });
    // Bulk delete listener
    document.getElementById('bulk-delete-logs-btn').addEventListener('click', async () => {
        const selected = Array.from(document.querySelectorAll('.log-select-checkbox:checked')).map(cb => cb.dataset.logId).filter(Boolean);
        if (selected.length === 0) return;
        if (!confirm(`Ù‡Ù„ ØªØ±ÙŠØ¯ Ø­Ø°Ù ${selected.length} Ø³Ø¬Ù„/Ø³Ø¬Ù„Ø§ØªØŸ Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡.`)) return;
        try {
            const resp = await authedFetch('/api/logs', {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ids: selected })
            });
            if (!resp.ok) throw new Error('ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ø³Ø¬Ù„Ø§Øª');
            const result = await resp.json();
            showToast(`${result.deletedCount || selected.length} Ø³Ø¬Ù„/Ø³Ø¬Ù„Ø§Øª Ø­Ø°ÙØª Ø¨Ù†Ø¬Ø§Ø­.`, 'success');
            fetchAndDisplayLogs(1);
        } catch (err) {
            console.error('Bulk delete error', err);
            showToast('ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ø³Ø¬Ù„Ø§Øª.', 'error');
        }
    });

    // Purge ALL logs (Super Admin only)
    const purgeBtn = document.getElementById('purge-all-logs-btn');
    if (purgeBtn) {
        purgeBtn.addEventListener('click', () => {
            // Show custom modal instead of browser confirm
            const modal = document.getElementById('purge-confirm-modal');
            const input = document.getElementById('purge-confirm-input');
            if (modal) {
                modal.style.display = 'flex';
                if (input) {
                    input.value = '';
                    setTimeout(() => input.focus(), 100);
                }
            }
        });
    }

    // Purge modal handlers
    const purgeModal = document.getElementById('purge-confirm-modal');
    const purgeConfirmBtn = document.getElementById('purge-confirm-btn');
    const purgeCancelBtn = document.getElementById('purge-cancel-btn');
    const purgeModalClose = document.getElementById('purge-modal-close');
    const purgeInput = document.getElementById('purge-confirm-input');

    const closePurgeModal = () => {
        if (purgeModal) purgeModal.style.display = 'none';
        if (purgeInput) purgeInput.value = '';
    };

    if (purgeCancelBtn) purgeCancelBtn.addEventListener('click', closePurgeModal);
    if (purgeModalClose) purgeModalClose.addEventListener('click', closePurgeModal);
    if (purgeModal) {
        purgeModal.addEventListener('click', (e) => {
            if (e.target === purgeModal) closePurgeModal();
        });
    }

    if (purgeConfirmBtn) {
        purgeConfirmBtn.addEventListener('click', async () => {
            const phrase = purgeInput?.value?.trim();
            if (phrase !== 'DELETE ALL') {
                showToast('ÙŠØ¬Ø¨ ÙƒØªØ§Ø¨Ø© "DELETE ALL" Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ Ù„Ù„ØªØ£ÙƒÙŠØ¯', 'error');
                if (purgeInput) purgeInput.focus();
                return;
            }
            closePurgeModal();
            try {
                const resp = await authedFetch('/api/logs/purge', { method: 'DELETE' });
                if (!resp.ok) throw new Error('ÙØ´Ù„ Ø§Ù„Ø­Ø°Ù Ø§Ù„ÙƒØ§Ù…Ù„.');
                const result = await resp.json();
                showToast(`ØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø³Ø¬Ù„Ø§Øª (${result.deletedCount || 0}).`, 'success');
                resetActivityLogState();
                fetchAndDisplayLogs(1);
            } catch (e) {
                console.error('[PurgeLogs] error', e);
                showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø°Ù Ø§Ù„ÙƒØ§Ù…Ù„.', 'error');
            }
        });
    }
    // Debounced search
    const searchInput = document.getElementById('log-search-text');
    if (searchInput) {
        searchInput.addEventListener('input', () => {
            debounceActivityLog('search', () => { resetActivityLogState(); fetchAndDisplayLogs(1); }, 450);
        });
    }

    await fetchAndDisplayLogs(1);

    // Fallback: If user just became super admin after initial render or role loaded late, ensure button exists
    if (isSuperAdmin && !document.getElementById('purge-all-logs-btn')) {
        const actionsBar = document.querySelector('.filters-container .filter-actions');
        if (actionsBar) {
            const btn = document.createElement('button');
            btn.id = 'purge-all-logs-btn';
            btn.className = 'btn-danger';
            btn.style.marginInlineStart = '8px';
            btn.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Ø­Ø°Ù ÙƒÙ„ Ø§Ù„Ø³Ø¬Ù„Ø§Øª';
            actionsBar.appendChild(btn);
            console.debug('[ActivityLog] Purge button injected via fallback logic');
            // Attach listener immediately
            btn.addEventListener('click', () => {
                const modal = document.getElementById('purge-confirm-modal');
                const input = document.getElementById('purge-confirm-input');
                if (modal) {
                    modal.style.display = 'flex';
                    if (input) {
                        input.value = '';
                        setTimeout(() => input.focus(), 100);
                    }
                }
            });
        }
    }

    // Modal close listeners
    const modal = document.getElementById('activity-log-modal');
    const modalClose = document.getElementById('modal-close');
    if (modal && modalClose) {
        modalClose.addEventListener('click', () => modal.classList.remove('show'));
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('show');
        });
    }
}

async function fetchAndDisplayLogs(page) {
    const container = document.getElementById('activity-log-container');
    if (!container) return;
    const isAppend = (activityLogViewMode !== 'table' && page > 1);
    if (!isAppend) {
        container.innerHTML = '<div class="loader-container"><div class="spinner"></div></div>';
    }

    const sortValue = document.getElementById('log-sort-select')?.value || 'newest'; // This element is duplicated, but we handle it.
    const userFilter = document.getElementById('log-user-filter')?.value || 'all';
    const actionFilter = document.getElementById('log-action-filter')?.value || 'all';

    try {
        const dateFrom = document.getElementById('log-date-from')?.value;
        const dateTo = document.getElementById('log-date-to')?.value;
        const searchQ = document.getElementById('log-search-text')?.value || '';

        // Build query params safely: only include keys with defined values
        const params = new URLSearchParams();
        params.set('page', page);
        params.set('limit', LOGS_PER_PAGE);
        params.set('sort', sortValue);
        // only send filters when the user actually selected a value other than 'all'
        if (userFilter && userFilter !== 'all') params.set('user_id', userFilter);
        if (actionFilter && actionFilter !== 'all') params.set('action_type', actionFilter);
        params.set('populate', 'user'); // Request user data to be populated
        if (dateFrom) params.set('date_from', dateFrom);
        if (dateTo) params.set('date_to', dateTo);
        if (searchQ) params.set('q', searchQ);

        const response = await authedFetch(`/api/logs?${params.toString()}`);
        if (!response.ok) {
            throw new Error('ÙØ´Ù„ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ø¬Ù„.');
        }
        const { data: logs, count } = await response.json();

        activityLogTotalPages = Math.ceil((count || 0) / LOGS_PER_PAGE);
        activityLogCurrentPage = page;
        if (isAppend) {
            activityLogAllLogs = activityLogAllLogs.concat(logs || []);
        } else {
            activityLogAllLogs = logs || [];
        }

        displayLogsPage(activityLogAllLogs, activityLogCurrentPage, count || 0, isAppend);

        // --- NEW: Populate user filter if not already populated ---
        const userFilterSelect = document.getElementById('log-user-filter');
        if (userFilterSelect && userFilterSelect.options.length <= 1) {
            const usersResponse = await authedFetch('/api/users?limit=1000&select=full_name,_id');
            if (usersResponse.ok) {
                const { users } = await usersResponse.json(); // The endpoint returns { users: [...] }
                // Add a "System" option
                userFilterSelect.innerHTML += `<option value="system">Ø§Ù„Ù†Ø¸Ø§Ù… (ØªÙ„Ù‚Ø§Ø¦ÙŠ)</option>`;
                // --- FIX: Ensure 'users' is an array before iterating ---
                if (Array.isArray(users)) {
                    users.forEach(user => {
                        const option = new Option(user.full_name, user._id);
                        userFilterSelect.add(option);
                    });
                }
            }
        }
    } catch (error) {
        console.error("Error fetching logs:", error);
        container.innerHTML = `<p class="error">${error.message}</p>`;
    }
}

// Export visible logs (fetch a large set) as CSV
document.addEventListener('click', async (e) => {
    if (e.target && e.target.id === 'export-log-csv') {
        try {
            const params = new URLSearchParams({ limit: 10000, sort: 'newest', populate: 'user' });
            const dateFrom = document.getElementById('log-date-from')?.value;
            const dateTo = document.getElementById('log-date-to')?.value;
            const searchQ = document.getElementById('log-search-text')?.value || '';
            const userFilter = document.getElementById('log-user-filter')?.value || 'all';
            const actionFilter = document.getElementById('log-action-filter')?.value || 'all';
            if (dateFrom) params.set('date_from', dateFrom);
            if (dateTo) params.set('date_to', dateTo);
            if (searchQ) params.set('q', searchQ);
            if (userFilter) params.set('user_id', userFilter);
            if (actionFilter) params.set('action_type', actionFilter);

            const resp = await authedFetch(`/api/logs?${params.toString()}`);
            if (!resp.ok) throw new Error('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø³Ø¬Ù„Ø§Øª Ù„ØªØµØ¯ÙŠØ±Ù‡Ø§');
            const { data: logs } = await resp.json();
            const rows = logs.map(l => ({
                createdAt: new Date(l.createdAt).toLocaleString('ar-EG'),
                user: l.user_name || 'Ø§Ù„Ù†Ø¸Ø§Ù…',
                action_type: l.action_type,
                description: l.description,
                metadata: JSON.stringify(l.metadata || {})
            }));
            const header = Object.keys(rows[0] || {}).join(',') + '\n';
            const csv = header + rows.map(r => Object.values(r).map(v => '"' + String(v).replace(/"/g, '""') + '"').join(',')).join('\n');
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `activity_logs_${new Date().toISOString().slice(0,10)}.csv`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        } catch (err) {
            console.error('Export failed', err);
            showToast('ÙØ´Ù„ ØªØµØ¯ÙŠØ± Ø§Ù„Ø³Ø¬Ù„Ø§Øª.', 'error');
        }
    }
});

// Auto-refresh handling
let activityLogAutoRefreshInterval = null;
document.addEventListener('change', (e) => {
    if (e.target && e.target.id === 'auto-refresh-logs') {
        const checked = e.target.checked;
        if (checked) {
            activityLogAutoRefreshInterval = setInterval(() => fetchAndDisplayLogs(1), 15000); // refresh every 15s
        } else {
            if (activityLogAutoRefreshInterval) clearInterval(activityLogAutoRefreshInterval);
        }
    }
});

function setupInfiniteScroll() {
    const sentinel = document.getElementById('log-scroll-sentinel');
    if (!sentinel) return;
    if (activityLogObserver) activityLogObserver.disconnect();
    activityLogObserver = new IntersectionObserver(entries => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                if (activityLogCurrentPage < activityLogTotalPages) {
                    activityLogObserver.disconnect();
                    fetchAndDisplayLogs(activityLogCurrentPage + 1);
                }
            }
        });
    }, { rootMargin: '200px' });
    activityLogObserver.observe(sentinel);
}

function displayLogsPage(logs, page, totalCount, isAppend = false) {
    const container = document.getElementById('activity-log-container');
    if (!container) return;

    page = parseInt(page);
    const totalPages = Math.ceil(totalCount / LOGS_PER_PAGE);

    let logHtml = logs.length > 0 ? generateActivityLogHTML(logs, activityLogViewMode) : '<p class="no-results-message">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø³Ø¬Ù„Ø§Øª Ù„Ø¹Ø±Ø¶Ù‡Ø§.</p>';

    let paginationHtml = '';
    if (totalPages > 1) {
        paginationHtml = '<div class="pagination-container">';
        const maxVisiblePages = 5; // Max number of page links to show
        let startPage, endPage;

        if (totalPages <= maxVisiblePages) {
            startPage = 1;
            endPage = totalPages;
        } else {
            const maxPagesBeforeCurrent = Math.floor(maxVisiblePages / 2);
            const maxPagesAfterCurrent = Math.ceil(maxVisiblePages / 2) - 1;
            if (page <= maxPagesBeforeCurrent) {
                startPage = 1;
                endPage = maxVisiblePages;
            } else if (page + maxPagesAfterCurrent >= totalPages) {
                startPage = totalPages - maxVisiblePages + 1;
                endPage = totalPages;
            } else {
                startPage = page - maxPagesBeforeCurrent;
                endPage = page + maxPagesAfterCurrent;
            }
        }

        paginationHtml += `<button class="page-btn" data-page="${page - 1}" ${page === 1 ? 'disabled' : ''}><i class="fas fa-chevron-right"></i> Ø§Ù„Ø³Ø§Ø¨Ù‚</button>`;

        if (startPage > 1) {
            paginationHtml += `<button class="page-btn" data-page="1">1</button>`;
            if (startPage > 2) {
                paginationHtml += `<span class="page-ellipsis">...</span>`;
            }
        }

        for (let i = startPage; i <= endPage; i++) {
            paginationHtml += `<button class="page-btn ${i === page ? 'active' : ''}" data-page="${i}">${i}</button>`;
        }

        paginationHtml += `<button class="page-btn" data-page="${page + 1}" ${page >= totalPages ? 'disabled' : ''}>Ø§Ù„ØªØ§Ù„ÙŠ <i class="fas fa-chevron-left"></i></button>`;
        paginationHtml += '</div>';
    }

    // For infinite modes remove pagination & add sentinel
    if (activityLogViewMode !== 'table') {
        paginationHtml = '';
        // Provide summary stats
        const summary = (() => {
            if (!Array.isArray(logs) || !logs.length) return '';
            const counts = logs.reduce((acc,l)=>{ acc[l.action_type] = (acc[l.action_type]||0)+1; return acc; },{});
            const top = Object.entries(counts).sort((a,b)=>b[1]-a[1]).slice(0,6).map(([k,v])=>`<span class="log-stat-chip">${esc(LOG_ACTION_TYPES[k]||k)}: ${v}</span>`).join('');
            return `<div class="log-stats-bar">${top}</div>`;
        })();
        container.innerHTML = summary + logHtml + `<div id="log-scroll-sentinel" class="scroll-sentinel">${page < activityLogTotalPages ? '<div class="loader-inline"><div class="spinner"></div> ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø²ÙŠØ¯ ...</div>' : '<div class="end-of-results">Ø§Ù†ØªÙ‡Øª Ø§Ù„Ø³Ø¬Ù„Ø§Øª</div>'}</div>`;
        if (page < activityLogTotalPages) setupInfiniteScroll();
    } else {
        container.innerHTML = `${logHtml}${paginationHtml}`;
    }

    // Setup selection behavior: select-all and per-row checkboxes
    const selectAll = container.querySelector('#select-all-logs');
    const bulkBtn = document.getElementById('bulk-delete-logs-btn');

    const updateBulkVisibility = () => {
        const any = container.querySelectorAll('.log-select-checkbox:checked').length > 0;
        if (bulkBtn) bulkBtn.style.display = any ? 'inline-flex' : 'none';
        if (selectAll) selectAll.checked = container.querySelectorAll('.log-select-checkbox').length > 0 && any && (container.querySelectorAll('.log-select-checkbox:checked').length === container.querySelectorAll('.log-select-checkbox').length);
    };

    container.querySelectorAll('.log-select-checkbox').forEach(cb => {
        cb.addEventListener('change', () => updateBulkVisibility());
    });

    if (selectAll) {
        selectAll.addEventListener('change', (e) => {
            const checked = e.target.checked;
            container.querySelectorAll('.log-select-checkbox').forEach(cb => { cb.checked = checked; });
            updateBulkVisibility();
        });
    }

    if (activityLogViewMode === 'table') {
        container.querySelectorAll('.page-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const newPage = e.currentTarget.dataset.page;
                if (newPage) {
                    fetchAndDisplayLogs(parseInt(newPage));
                }
            });
        });
    }

    // Attach meta toggle listeners
    container.querySelectorAll('.log-meta-toggle').forEach(btn => {
        btn.addEventListener('click', (e) => {
            toggleMeta(e.currentTarget);
        });
    });

    // Attach copy endpoint listeners
    container.querySelectorAll('.api-copy-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            copyEndpoint(e.currentTarget);
        });
    });

    // Attach copy meta listeners
    container.querySelectorAll('.log-meta-copy').forEach(btn => {
        btn.addEventListener('click', (e) => {
            copyMeta(e.currentTarget);
        });
    });
}

/**
 * Generates the HTML for a list of activity logs using a card-based design.
 * @param {Array} logs - The array of log objects.
 * @returns {string} The generated HTML string.
 */
function generateActivityLogHTML(logs, mode='table') {
    const getActionDetails = (actionType) => {
        if (!actionType) return { group: 'unknown', icon: 'fa-question-circle', color: '#6c757d' };
        const upper = actionType.toUpperCase();
        if (upper.includes('CREATE') || upper.startsWith('POST ')) return { group: 'create', icon: 'fa-plus', color: '#28a745' };
        if (upper.includes('DELETE') || upper.startsWith('DELETE ')) return { group: 'delete', icon: 'fa-trash', color: '#dc3545' };
        if (upper.includes('UPDATE') || upper.startsWith('PUT ') || upper.startsWith('PATCH ')) return { group: 'update', icon: 'fa-edit', color: '#007bff' };
        if (upper.includes('RENEW')) return { group: 'renew', icon: 'fa-redo', color: '#ffc107' };
        if (upper.includes('EXPIRE')) return { group: 'expire', icon: 'fa-clock', color: '#6c757d' };
        if (upper.startsWith('GET ')) return { group: 'read', icon: 'fa-eye', color: '#17a2b8' };
        return { group: 'other', icon: 'fa-info', color: '#17a2b8' };
    };

    // Helper function for HTML escaping (moved to top)

    // Group by date for timeline/cards
    const byDate = {};
    logs.forEach(l => {
        const d = l.createdAt ? new Date(l.createdAt) : null;
        const key = d ? d.toISOString().slice(0,10) : 'unknown';
        if (!byDate[key]) byDate[key] = [];
        byDate[key].push(l);
    });

    if (mode === 'cards') {
        return `<div class="activity-log-cards">${logs.map(log => {
            const { group, icon, color } = getActionDetails(log.action_type);
            const time = log.createdAt ? new Date(log.createdAt).toLocaleTimeString('ar-EG',{hour:'2-digit',minute:'2-digit'}) : '-';
            const date = log.createdAt ? new Date(log.createdAt).toLocaleDateString('ar-EG',{year:'numeric',month:'short',day:'numeric'}) : '-';
            const userName = log.user?.full_name || log.user_name || 'Ø§Ù„Ù†Ø¸Ø§Ù…';
            let description = log.description || '';
            let actionText = LOG_ACTION_TYPES[log.action_type] || mapEndpointToArabic('', log.action_type) || log.action_type;
            if (!description.trim()) description = actionText;
            let metaObj = null; try { metaObj = log.metadata && Object.keys(log.metadata).length ? log.metadata : null; } catch(e){ metaObj=null; }
            const encodedMeta = metaObj ? encodeURIComponent(JSON.stringify(metaObj)) : '';
            return `<div class="activity-log-card" data-action-group="${group}">
                <div class="log-card-header">
                    <span class="log-badge badge-${group}"><i class="fas ${icon}"></i></span>
                    <div class="log-card-time">
                        <span class="log-time-hm">${esc(time)}</span>
                        <span class="log-time-date">${esc(date)}</span>
                    </div>
                    <div class="log-card-user"><i class="fas fa-user"></i> ${esc(userName)}</div>
                </div>
                <div class="log-card-body">
                    <p class="log-card-desc">${esc(description)}</p>
                    <div class="log-card-meta-actions">
                        ${metaObj ? `<button class="log-meta-toggle small" data-toggle="meta" data-meta="${encodedMeta}"><i class="fas fa-info-circle"></i> ØªÙØ§ØµÙŠÙ„</button>` : ''}
                    </div>
                </div>
                <div class="log-card-footer">${esc(actionText)}</div>
                <div class="log-card-select"><input type="checkbox" class="log-select-checkbox" data-log-id="${esc(log._id || '')}" aria-label="Ø§Ø®ØªØ± Ø§Ù„Ø³Ø¬Ù„"></div>
            </div>`;
        }).join('')}</div>`;
    }

    if (mode === 'timeline') {
        return `<div class="activity-log-timeline">${Object.entries(byDate).sort((a,b)=> a[0]<b[0]?1:-1).map(([day, items])=>{
            return `<div class="timeline-day"><div class="timeline-day-header"><i class="fas fa-calendar-day"></i> ${day}</div>
            <div class="timeline-items">${items.sort((a,b)=> new Date(b.createdAt)-new Date(a.createdAt)).map(log=>{
                const { group, icon } = getActionDetails(log.action_type);
                const time = log.createdAt ? new Date(log.createdAt).toLocaleTimeString('ar-EG',{hour:'2-digit',minute:'2-digit'}) : '-';
                const userName = log.user?.full_name || log.user_name || 'Ø§Ù„Ù†Ø¸Ø§Ù…';
                let description = log.description || '';
                let actionText = LOG_ACTION_TYPES[log.action_type] || log.action_type;
                if (!description.trim()) description = actionText;
                let metaObj = null; try { metaObj = log.metadata && Object.keys(log.metadata).length ? log.metadata : null; } catch(e){ metaObj=null; }
                const encodedMeta = metaObj ? encodeURIComponent(JSON.stringify(metaObj)) : '';
                return `<div class="timeline-item" data-action-group="${group}">
                    <div class="timeline-marker"><i class="fas ${icon}"></i></div>
                    <div class="timeline-content">
                        <div class="timeline-meta"><span class="timeline-time">${esc(time)}</span><span class="timeline-user"><i class="fas fa-user"></i> ${esc(userName)}</span></div>
                        <div class="timeline-desc">${esc(description)}</div>
                        <div class="timeline-actions">${metaObj ? `<button class="log-meta-toggle tiny" data-toggle="meta" data-meta="${encodedMeta}"><i class="fas fa-info-circle"></i></button>` : ''}
                        <input type="checkbox" class="log-select-checkbox" data-log-id="${esc(log._id || '')}" aria-label="Ø§Ø®ØªØ± Ø§Ù„Ø³Ø¬Ù„"></div>
                    </div>
                </div>`;
            }).join('')}</div></div>`;
        }).join('')}</div>`;
    }

    // Default (table) legacy path
    const logRows = logs.map(log => {
        const { group, icon } = getActionDetails(log.action_type);
        const time = log.createdAt ? new Date(log.createdAt).toLocaleString('ar-EG', { day: 'numeric', month: 'long', year: 'numeric', hour: 'numeric', minute: '2-digit' }) : '-';
        const userName = log.user?.full_name || log.user_name || 'Ø§Ù„Ù†Ø¸Ø§Ù…';
        
        // Use description from backend (already in Arabic) as primary display text
        let description = log.description || '';
        
        // Fallback: translate action_type to Arabic if description is missing
        let actionText = '';
        if (LOG_ACTION_TYPES[log.action_type]) {
            actionText = LOG_ACTION_TYPES[log.action_type];
        } else {
            // Comprehensive translation of English action types to Arabic
            actionText = log.action_type
                // HTTP Methods
                .replace(/^GET[_\s]+/i, 'Ø¹Ø±Ø¶ ')
                .replace(/^POST[_\s]+/i, 'Ø¥Ù†Ø´Ø§Ø¡ ')
                .replace(/^PUT[_\s]+/i, 'ØªØ­Ø¯ÙŠØ« ')
                .replace(/^PATCH[_\s]+/i, 'ØªØ¹Ø¯ÙŠÙ„ ')
                .replace(/^DELETE[_\s]+/i, 'Ø­Ø°Ù ')
                // Common Resources
                .replace(/\bDATA\b/gi, 'Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª')
                .replace(/\bCALENDAR\b/gi, 'Ø§Ù„ØªÙ‚ÙˆÙŠÙ…')
                .replace(/\bAGENTS?\b/gi, 'Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡')
                .replace(/\bUSERS?\b/gi, 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†')
                .replace(/\bCOMPETITIONS?\b/gi, 'Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª')
                .replace(/\bTASKS?\b/gi, 'Ø§Ù„Ù…Ù‡Ø§Ù…')
                .replace(/\bTEMPLATES?\b/gi, 'Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨')
                .replace(/\bLOGS?\b/gi, 'Ø§Ù„Ø³Ø¬Ù„Ø§Øª')
                .replace(/\bSTATS?\b/gi, 'Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª')
                .replace(/\bANALYTICS?\b/gi, 'Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª')
                // Actions
                .replace(/\bVIEW\b/gi, 'Ø¹Ø±Ø¶')
                .replace(/\bCREATED?\b/gi, 'Ø¥Ù†Ø´Ø§Ø¡')
                .replace(/\bUPDATED?\b/gi, 'ØªØ­Ø¯ÙŠØ«')
                .replace(/\bDELETED?\b/gi, 'Ø­Ø°Ù')
                .replace(/\bARCHIVED?\b/gi, 'Ø£Ø±Ø´ÙØ©')
                .replace(/\bRESTORED?\b/gi, 'Ø§Ø³ØªØ¹Ø§Ø¯Ø©')
                // Clean up
                .replace(/_/g, ' ')
                .trim();
        }
        
        let metaObj = null;
        try { metaObj = log.metadata && Object.keys(log.metadata).length ? log.metadata : null; } catch (e) { metaObj = null; }

        // Encode metadata for modal
        const encodedMeta = metaObj ? encodeURIComponent(JSON.stringify(metaObj)) : '';

        // Build description HTML - prioritize backend description (already Arabic)
        let descriptionHtml = '';
        
        // If description exists and is already in Arabic (from backend), use it directly
        if (description && description.trim()) {
            descriptionHtml = esc(description);
        } else {
            // Fallback to translated action text
            descriptionHtml = esc(actionText);
        }

        // Render metadata as key/value list when available
        let metaHtml = '';
        if (metaObj) {
            const entries = Object.entries(metaObj).map(([k, v]) => {
                const val = (typeof v === 'object') ? JSON.stringify(v) : String(v);
                return `<div class="log-meta-item"><div class="meta-key">${esc(k)}</div><div class="meta-val">${esc(val)}</div></div>`;
            }).join('');
            // include encoded full JSON for easy copying
            metaHtml = `<div class="log-meta-copy-wrap"><button class="log-meta-copy" data-copy="meta" data-meta="${encodedMeta}"><i class="fas fa-copy"></i> Ù†Ø³Ø® Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</button></div><div class="log-meta-list">${entries}</div>`;
        }

        return `
            <tr class="log-row" data-action-group="${group}" data-log-id="${esc(log._id || '')}">
                <td><input type="checkbox" class="log-select-checkbox" data-log-id="${esc(log._id || '')}" aria-label="Ø§Ø®ØªØ± Ø§Ù„Ø³Ø¬Ù„"></td>
                <td class="log-icon-cell"><i class="fas ${icon}" data-action-group="${group}"></i></td>
                <td class="log-description-cell">${descriptionHtml}</td>
                <td class="log-action-cell">${esc(actionText)}</td>
                <td class="log-user-cell">${esc(userName)}</td>
                <td class="log-time-cell">${esc(time)}</td>
                <td class="log-details-cell">
                    ${metaObj ? `<button class="log-meta-toggle" data-toggle="meta" data-meta="${encodedMeta}">Ø¹Ø±Ø¶ Ø§Ù„ØªÙØ§ØµÙŠÙ„</button>` : ''}
                </td>
            </tr>
        `;
    }).join('');

    // Add a header for the select-all checkbox
    const tableHeader = `
        <thead>
            <tr>
                <th><input type="checkbox" id="select-all-logs" aria-label="Ø§Ø®ØªØ± ÙƒÙ„ Ø§Ù„Ø³Ø¬Ù„Ø§Øª">
                    <label for="select-all-logs">Ø§Ø®ØªØ± Ø§Ù„ÙƒÙ„</label></th>
                <th>Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø©</th>
                <th>Ø§Ù„ÙˆØµÙ</th>
                <th>Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡</th>
                <th>Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…</th>
                <th>Ø§Ù„ØªØ§Ø±ÙŠØ® ÙˆØ§Ù„ÙˆÙ‚Øª</th>
                <th>Ø§Ù„ØªÙØ§ØµÙŠÙ„</th>
            </tr>
        </thead>
    `;

    return `<div class="activity-log-table-container">
        <table class="activity-log-table">
            ${tableHeader}
            <tbody>${logRows}</tbody>
        </table>
    </div>`;
}

function toggleMeta(button) {
    const enc = button.dataset.meta || '';
    if (!enc) return;
    const meta = decodeURIComponent(enc);
    const modal = document.getElementById('activity-log-modal');
    const modalBody = document.getElementById('modal-body');
    if (modal && modalBody) {
        // Parse and display metadata
        try {
            const metaObj = JSON.parse(meta);
            const entries = Object.entries(metaObj).map(([k, v]) => {
                const val = (typeof v === 'object') ? JSON.stringify(v) : String(v);
                return `<div class="log-meta-item"><div class="meta-key">${esc(k)}</div><div class="meta-val">${esc(val)}</div></div>`;
            }).join('');
            modalBody.innerHTML = `<div class="log-meta-list">${entries}</div>`;
        } catch (e) {
            modalBody.innerHTML = `<pre>${esc(meta)}</pre>`;
        }
        modal.classList.add('show');
    }
}

// Copy endpoint (from API-like descriptions)
function copyEndpoint(button) {
    const endpoint = button.dataset.endpoint || '';
    if (!endpoint) return;
    navigator.clipboard.writeText(endpoint).then(() => {
        if (typeof showToast === 'function') showToast('ØªÙ… Ù†Ø³Ø® Ø§Ù„Ù…Ø³Ø§Ø± Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ¸Ø©', 'info');
        else alert('ØªÙ… Ù†Ø³Ø® Ø§Ù„Ù…Ø³Ø§Ø±');
    }).catch(() => {
        if (typeof showToast === 'function') showToast('ÙØ´Ù„ Ù†Ø³Ø® Ø§Ù„Ù…Ø³Ø§Ø±', 'error');
        else alert('ÙØ´Ù„ Ù†Ø³Ø® Ø§Ù„Ù…Ø³Ø§Ø±');
    });
}

// Copy full metadata JSON
function copyMeta(button) {
    const enc = button.dataset.meta || '';
    if (!enc) return;
    const meta = decodeURIComponent(enc);
    navigator.clipboard.writeText(meta).then(() => {
        if (typeof showToast === 'function') showToast('ØªÙ… Ù†Ø³Ø® Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­', 'info');
        else alert('ØªÙ… Ù†Ø³Ø® Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
    }).catch(() => {
        if (typeof showToast === 'function') showToast('ÙØ´Ù„ Ù†Ø³Ø® Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 'error');
        else alert('ÙØ´Ù„ Ù†Ø³Ø® Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
    });
}

// == analytics.js ==
ï»¿// --- Ø£ÙƒØ«Ø± Ù…Ø³Ø§Ø¨Ù‚Ø§Øª ØªÙØ§Ø¹Ù„Ø§Ù‹ ---
// --- Ø¯Ø§Ù„Ø© Ø¹Ø±Ø¶ modal Ù„Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„ÙƒØ§Ù…Ù„ ---
function showQuestionModal(questionText) {
    let modal = document.getElementById('questionModal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'questionModal';
        modal.className = 'question-modal';
        modal.innerHTML = `
            <div class="modal-overlay"></div>
            <div class="modal-content">
                <div class="modal-header">
                    <h3><i class="fas fa-question-circle"></i> Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„ÙƒØ§Ù…Ù„</h3>
                    <button class="modal-close-btn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <p id="modalQuestionText"></p>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-primary modal-ok-btn">
                        <i class="fas fa-check"></i> Ø­Ø³Ù†Ø§Ù‹
                    </button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        const overlay = modal.querySelector('.modal-overlay');
        const closeBtn = modal.querySelector('.modal-close-btn');
        const okBtn = modal.querySelector('.modal-ok-btn');
        overlay.addEventListener('click', window.closeQuestionModal);
        if (closeBtn) closeBtn.addEventListener('click', window.closeQuestionModal);
        if (okBtn) okBtn.addEventListener('click', window.closeQuestionModal);
        document.addEventListener('keydown', (ev) => {
            if (ev.key === 'Escape') window.closeQuestionModal();
        }, { once: true });
    }
    
    const modalQuestionText = document.getElementById('modalQuestionText');
    if (modalQuestionText) {
        modalQuestionText.textContent = questionText;
    }
    
    modal.style.display = 'flex';
    setTimeout(() => {
        modal.classList.add('show');
    }, 10);
}

window.closeQuestionModal = function() {
    const modal = document.getElementById('questionModal');
    if (modal) {
        modal.classList.remove('show');
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    }
};

// Ø¯Ø§Ù„Ø© ØªÙ…Ø±ÙŠØ± Ø§Ø­ØªØ±Ø§ÙÙŠØ© Ù„Ø£ÙŠ Ù‚Ø³Ù… Ù…Ø¹ ØªØ¹ÙˆÙŠØ¶ Ø§Ù„Ù‡ÙŠØ¯Ø± Ø§Ù„Ø«Ø§Ø¨Øª
function scrollToSection(sectionId, headerOffset = 60) {
    const section = document.getElementById(sectionId);
    if (!section) return;
    // Scroll smoothly to the section top
    section.scrollIntoView({ behavior: 'smooth', block: 'start' });

    // Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù„ÙˆÙŠ (header) Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§
    const header = document.querySelector('header, .main-header, #mainHeader');
    if (header) {
        header.style.transition = 'top 0.4s, opacity 0.4s';
        header.style.top = `-${header.offsetHeight}px`;
        header.style.opacity = '0';
    }

    // ØªØ¹ÙˆÙŠØ¶ Ø§Ù„Ù‡ÙŠØ¯Ø± Ø§Ù„Ø«Ø§Ø¨Øª Ø¨Ø¹Ø¯ Ø§Ù„ØªÙ…Ø±ÙŠØ±
    setTimeout(() => {
        const sectionTop = section.getBoundingClientRect().top + window.pageYOffset;
        let scrollTarget = sectionTop - headerOffset;

        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø¬Ø¯ÙˆÙ„ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù‚Ø³Ù…ØŒ ØªØ£ÙƒØ¯ Ø£Ù† Ø±Ø£Ø³ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø¸Ø§Ù‡Ø± Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
        const table = section.querySelector('table');
        if (table) {
            const tableRect = table.getBoundingClientRect();
            const tableHead = table.querySelector('thead');
            if (tableHead) {
                // Ø§Ø­Ø³Ø¨ Ù…ÙˆØ¶Ø¹ Ø±Ø£Ø³ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ù„ØµÙØ­Ø©
                const theadRect = tableHead.getBoundingClientRect();
                const theadTop = theadRect.top + window.pageYOffset;
                // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ø±Ø£Ø³ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø¸Ø§Ù‡Ø±Ù‹Ø§ Ø¨Ø¹Ø¯ Ø§Ù„ØªÙ…Ø±ÙŠØ±ØŒ Ø¹Ø¯Ù„ Ø§Ù„Ù‡Ø¯Ù
                if (theadTop < window.pageYOffset + headerOffset || theadTop > window.pageYOffset + window.innerHeight) {
                    scrollTarget = theadTop - headerOffset;
                }
            }
        }

        window.scrollTo({
            top: scrollTarget,
            behavior: 'smooth'
        });

        // Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù„ÙˆÙŠ Ø¨Ø¹Ø¯ ÙØªØ±Ø© Ù‚ØµÙŠØ±Ø© Ø£Ùˆ Ø¹Ù†Ø¯ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø£Ø¹Ù„Ù‰
        if (header) {
            setTimeout(() => {
                header.style.top = '';
                header.style.opacity = '';
            }, 1200);

            // Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø´Ø±ÙŠØ· Ø¹Ù†Ø¯ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø£Ø¹Ù„Ù‰
            const onScroll = () => {
                if (window.scrollY < 50) {
                    header.style.top = '';
                    header.style.opacity = '';
                    window.removeEventListener('scroll', onScroll);
                }
            };
            window.addEventListener('scroll', onScroll);
        }
    }, 400);
}

// ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªÙ…Ø±ÙŠØ± Ù„Ø¬Ù…ÙŠØ¹ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø§Ø®ØªØµØ§Ø±Ø§Øª Ø§Ù„ØªÙŠ ØªØ­Ù…Ù„ data-section
document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('[data-section]').forEach(btn => {
        btn.addEventListener('click', function(e) {
            const targetId = btn.getAttribute('data-section');
            if (targetId) {
                e.preventDefault();
                scrollToSection(targetId);
            }
        });
    });
});

// ============================================
// Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ÙÙ„Ø§ØªØ± Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ø®Ø§ØµØ© Ø¨ÙƒÙ„ Ù‚Ø³Ù…
// ============================================

/**
 * Ø¥Ø¹Ø¯Ø§Ø¯ ÙÙ„ØªØ± Ø§Ù„ØªØ§Ø±ÙŠØ® Ù„Ù‚Ø³Ù… Ù…Ø¹ÙŠÙ†
 * @param {string} sectionName - Ø§Ø³Ù… Ø§Ù„Ù‚Ø³Ù… (Ù…Ø«Ù„: completedCompetitions, agentGrowth, Ø¥Ù„Ø®)
 * @param {Function} updateCallback - Ø¯Ø§Ù„Ø© ÙŠØªÙ… Ø§Ø³ØªØ¯Ø¹Ø§Ø¤Ù‡Ø§ Ø¹Ù†Ø¯ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„ØªØ±
 */
function setupSectionDateFilter(sectionName, updateCallback) {
    const fromDateInput = document.getElementById(`${sectionName}FromDate`);
    const toDateInput = document.getElementById(`${sectionName}ToDate`);
    const applyBtn = document.getElementById(`apply${capitalizeFirst(sectionName)}Filter`);
    const clearBtn = document.getElementById(`clear${capitalizeFirst(sectionName)}Filter`);

    if (!fromDateInput || !toDateInput || !applyBtn || !clearBtn) {
        console.warn(`[setupSectionDateFilter] Ø¹Ù†Ø§ØµØ± ÙÙ„ØªØ± ${sectionName} ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©`);
        return;
    }

    // Ø²Ø± ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„ØªØ±
    applyBtn.addEventListener('click', () => {
        const from = fromDateInput.value;
        const to = toDateInput.value;

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        if (!from && !to) {
            showToast('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± ØªØ§Ø±ÙŠØ® ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„', 'warning');
            return;
        }

        if (from && to && new Date(from) > new Date(to)) {
            showToast('ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‚Ø¨Ù„ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù†Ù‡Ø§ÙŠØ©', 'error');
            return;
        }

        // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„ØªØ±
        if (updateCallback) {
            updateCallback();
            showToast('ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„ØªØ± Ø¨Ù†Ø¬Ø§Ø­', 'success');
        }
    });

    // Ø²Ø± Ù…Ø³Ø­ Ø§Ù„ÙÙ„ØªØ±
    clearBtn.addEventListener('click', () => {
        fromDateInput.value = '';
        toDateInput.value = '';
        
        if (updateCallback) {
            updateCallback();
            showToast('ØªÙ… Ù…Ø³Ø­ Ø§Ù„ÙÙ„ØªØ±', 'info');
        }
    });
}

/**
 * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ÙÙ„ØªØ± Ø§Ù„ØªØ§Ø±ÙŠØ® Ù„Ù‚Ø³Ù… Ù…Ø¹ÙŠÙ†
 * @param {string} sectionName - Ø§Ø³Ù… Ø§Ù„Ù‚Ø³Ù…
 * @returns {Object|string} ÙƒØ§Ø¦Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ from Ùˆ toØŒ Ø£Ùˆ '30' ÙƒØ§ÙØªØ±Ø§Ø¶ÙŠ
 */
function getSectionDateFilter(sectionName) {
    const fromDateInput = document.getElementById(`${sectionName}FromDate`);
    const toDateInput = document.getElementById(`${sectionName}ToDate`);

    if (!fromDateInput || !toDateInput) {
        return '30'; // Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ
    }

    const from = fromDateInput.value;
    const to = toDateInput.value;

    if (from && to) {
        return { from, to };
    } else if (from || to) {
        return { from: from || undefined, to: to || undefined };
    }

    return '30'; // Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ
}

/**
 * ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø­Ø±Ù Ø§Ù„Ø£ÙˆÙ„ Ø¥Ù„Ù‰ Ø­Ø±Ù ÙƒØ¨ÙŠØ±
 * @param {string} str - Ø§Ù„Ù†Øµ
 * @returns {string} Ø§Ù„Ù†Øµ Ù…Ø¹ Ø­Ø±Ù ÙƒØ¨ÙŠØ± ÙÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
 */
function capitalizeFirst(str) {
    if (!str) return '';
    return str.charAt(0).toUpperCase() + str.slice(1);
}

// --- Ø£ÙƒØ«Ø± Ù…Ø³Ø§Ø¨Ù‚Ø§Øª ØªÙØ§Ø¹Ù„Ø§Ù‹ ---
async function fetchAndRenderMostInteractiveCompetitions() {
    const listEl = document.getElementById('mostInteractiveCompetitionsList');
    const errorEl = document.getElementById('mostInteractiveCompetitionsError');
    if (!listEl) return;
    listEl.innerHTML = '<div class="loading-spinner active"></div><p style="margin:8px 0 0; color:var(--text-secondary-color)">Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ø£ÙƒØ«Ø± ØªÙØ§Ø¹Ù„Ø§Ù‹...</p>';
    if (errorEl) errorEl.textContent = '';

    try {
        const sortSelect = document.getElementById('mostInteractiveSortBy');
        const limitSelect = document.getElementById('mostInteractiveLimit');
        const sortBy = sortSelect ? sortSelect.value : 'views';
        const limit = limitSelect ? parseInt(limitSelect.value, 10) : 50;

        // Build date params - Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙ„ØªØ± Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø®Ø§Øµ
        let query = '';
        const fromDateInput = document.getElementById('mostInteractiveFromDate');
        const toDateInput = document.getElementById('mostInteractiveToDate');
        const fromVal = fromDateInput?.value;
        const toVal = toDateInput?.value;
        if (fromVal && toVal) { query += `from=${fromVal}&to=${toVal}`; }
        else { query += 'range=30'; }
        query += `&limit=${limit}&sort=${sortBy}`;

        const res = await fetchWithAuth(`/api/stats/interactive-competitions?${query}`);
        if (!res.ok) {
            await res.text().catch(()=> '');
            throw new Error('ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
        }
        const data = await res.json();
        let competitions = Array.isArray(data?.data) ? data.data : [];

        competitions = competitions.map(c => ({
            views_count: c.views_count ?? 0,
            reactions_count: c.reactions_count ?? 0,
            participants_count: c.participants_count ?? 0,
            send_count: c.send_count ?? c.competitions_count ?? 0,
            type: (c.template_type ?? c.type) ?? 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯',
            correct_answer: c.correct_answer ?? 'ØºÙŠØ± Ù…ØªÙˆÙØ±',
            question: c.question || c.template_name || 'ØºÙŠØ± Ù…ØªÙˆÙØ±'
        }));

        const comparators = {
            views: (a,b) => b.views_count - a.views_count,
            reactions: (a,b) => b.reactions_count - a.reactions_count,
            participants: (a,b) => b.participants_count - a.participants_count,
            sends: (a,b) => b.send_count - a.send_count
        };
        competitions.sort(comparators[sortBy] || comparators.views);
        competitions = competitions.slice(0, limit);

        if (!competitions.length) {
            listEl.innerHTML = '<div class="empty-state"><i class="fas fa-inbox"></i><p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ§Ø­Ø© Ø¶Ù…Ù† Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©.</p></div>';
            return;
        }

        const typeLegacyMap = { general: 'Ù…Ù…ÙŠØ²Ø§Øª', trading: 'ØªÙØ§Ø¹Ù„ÙŠØ©', deposit: 'Ø¥ÙŠØ¯Ø§Ø¹' };
        const itemsHtml = competitions.map((comp, idx) => {
            const raw = (comp.type || '').toString().trim();
            const isArabic = raw === 'Ù…Ù…ÙŠØ²Ø§Øª' || raw === 'ØªÙØ§Ø¹Ù„ÙŠØ©' || raw === 'Ø¥ÙŠØ¯Ø§Ø¹';
            const displayType = isArabic ? raw : (typeLegacyMap[raw.toLowerCase()] || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯');
            let badgeKey = 'unknown';
            if (displayType === 'Ù…Ù…ÙŠØ²Ø§Øª') badgeKey = 'features';
            else if (displayType === 'ØªÙØ§Ø¹Ù„ÙŠØ©') badgeKey = 'interactive';
            else if (displayType === 'Ø¥ÙŠØ¯Ø§Ø¹') badgeKey = 'deposit';
            const engagement = (comp.views_count > 0) ? Math.min(100, Math.round((comp.participants_count / comp.views_count) * 100)) : 0;
            const qFull = (comp.question || 'ØºÙŠØ± Ù…ØªÙˆÙØ±').toString();
            const aFull = (comp.correct_answer || 'ØºÙŠØ± Ù…ØªÙˆÙØ±').toString();
            const escapedQ = qFull.replace(/\"/g,'&quot;');
            return `
              <div class="interactive-item" data-index="${idx+1}">
                <div class="item-rank"><span class="index-badge">${idx+1}</span></div>
                <div class="item-main">
                  <div class="item-question question-cell" title="${escapedQ}" data-fulltext="${escapedQ}">
                    <i class="fas fa-question-circle"></i>
                    <span class="question-text">${qFull}</span>
                    <span class="answer-badge">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©: ${aFull}</span>
                  </div>
                  <div class="item-meta">
                    <span class="type-badge ${badgeKey}">${displayType}</span>
                    <span class="metric-chip"><i class="fas fa-paper-plane"></i> ${ (comp.send_count ?? 0).toLocaleString('ar-EG') }</span>
                    <span class="metric-chip"><i class="fas fa-eye"></i> ${ (comp.views_count ?? 0).toLocaleString('ar-EG') }</span>
                    <span class="metric-chip"><i class="fas fa-bolt"></i> ${ (comp.reactions_count ?? 0).toLocaleString('ar-EG') }</span>
                    <span class="metric-chip"><i class="fas fa-users"></i> ${ (comp.participants_count ?? 0).toLocaleString('ar-EG') }</span>
                  </div>
                  <div class="engagement-bar" title="Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªÙØ§Ø¹Ù„">
                    <div class="fill" style="width:${engagement}%"></div>
                    <span class="pct">${engagement}%</span>
                  </div>
                </div>
              </div>
            `;
        }).join('');
        listEl.innerHTML = itemsHtml;

        // Modal for question full text
        try {
            const container = document.getElementById('mostInteractiveCompetitionsList');
            if (container && !container._questionClickBound) {
                container.addEventListener('click', (ev) => {
                    const cell = ev.target.closest('.question-cell');
                    if (!cell) return;
                    const full = cell.getAttribute('data-fulltext') || cell.textContent || '';
                    const content = `
                        <div class="dark-expand-modal-wrapper">
                            <div class="dark-expand-modal">
                                <div class="dark-expand-modal-header">
                                    <i class="fas fa-question-circle" style="color:#4fa3ff"></i> Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„ÙƒØ§Ù…Ù„
                                </div>
                                <div class="dark-expand-modal-body"><pre>${full}</pre></div>
                            </div>
                        </div>`;
                    if (typeof showConfirmationModal === 'function') {
                        showConfirmationModal(content, async () => true, { title: '', confirmText: '<i class="fas fa-times"></i> Ø¥ØºÙ„Ø§Ù‚', showCancel: false });
                    } else { alert(full); }
                });
                container._questionClickBound = true;
            }
        } catch (_) { /* ignore */ }
    } catch (err) {
        listEl.innerHTML = '<div class="empty-state error"><i class="fas fa-exclamation-triangle"></i><p>ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.</p></div>';
        if (errorEl) {
            errorEl.textContent = 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø£ÙƒØ«Ø± Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª ØªÙØ§Ø¹Ù„Ø§Ù‹';
            errorEl.classList.add('active');
        }
    }
}
// Use the globally available utilities
const { authedFetch: fetchWithAuth, showToast } = window.utils;

// DEBUG gate: disable verbose logs in production to keep UI smooth
const DEBUG = false;
const dlog = DEBUG ? (..._args) => {} : null;

// Helper: truncate long text safely
function truncateText(str, max) {
    if (!str) return '';
    const s = String(str);
    return s.length > max ? s.slice(0, max - 1) + 'â€¦' : s;
}

// Ensure Chart.js is loaded
if (typeof Chart === 'undefined') {
    try { showToast && showToast('Chart.js ØºÙŠØ± Ù…Ø­Ù…Ù„. ÙŠØ±Ø¬Ù‰ ØªØ¶Ù…ÙŠÙ†Ù‡ Ù‚Ø¨Ù„ analytics.js', 'error'); } catch (_) {}
    throw new Error('Chart.js dependency missing');
}

// Register the ChartDataLabels plugin
if (typeof ChartDataLabels !== 'undefined') {
    Chart.register(ChartDataLabels);
}

// Function to safely configure Chart.js
function configureChartDefaults() {
    if (!window.Chart) {
        return false;
    }

    try {
        // Configure basic defaults
        Chart.defaults.font.family = 'Arial, sans-serif';
        Chart.defaults.color = '#fff';

        // Configure RTL settings safely
        if (Chart.defaults.plugins) {
            if (Chart.defaults.plugins.tooltip) {
                Chart.defaults.plugins.tooltip.rtl = true;
            }
            if (Chart.defaults.plugins.legend) {
                Chart.defaults.plugins.legend.rtl = true;
            }
            if (Chart.defaults.plugins.datalabels) {
                Chart.defaults.plugins.datalabels.rtl = true;
            }
        }
        return true;
    } catch (error) {
        return false;
    }
}

// Chart instances
let mostFrequentCompetitionsChart;
let agentGrowthChart;
let agentClassificationChart;
let competitionPerformanceChart;

// Declare canvas and error elements globally for access in rendering functions
let agentGrowthCanvas, agentClassificationCanvas, competitionPerformanceCanvas;
let agentGrowthError, agentClassificationError, competitionPerformanceError;

// Comparison mode state
let isComparisonMode = false;
let comparisonData = {
    period1: null,
    period2: null
};

// Configure Chart.js when the script loads
configureChartDefaults();

// Arabic Labels
const ARABIC_LABELS = {
    mostFrequentCompetitions: 'Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ø£ÙƒØ«Ø± ØªÙƒØ±Ø§Ø±Ù‹Ø§',
    competitionName: 'Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©',
    count: 'Ø§Ù„Ø¹Ø¯Ø¯',
    agentGrowth: 'Ù†Ù…Ùˆ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ (Ø¢Ø®Ø± 6 Ø£Ø´Ù‡Ø±)',
    newAgents: 'ÙˆÙƒÙ„Ø§Ø¡ Ø¬Ø¯Ø¯',
    agentClassification: 'ØªÙˆØ²ÙŠØ¹ ØªØµÙ†ÙŠÙØ§Øª Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡',
    competitionPerformance: 'Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª (Ø­Ø³Ø¨ Ø§Ù„ØªÙØ§Ø¹Ù„)',
    views: 'Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª',
    // activityDistribution: 'ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø£Ù†Ø´Ø·Ø© ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…',
    action: 'Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡',
    noData: 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ø¹Ø±Ø¶Ù‡Ø§.',
    errorFetchingData: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.',
    copySuccess: 'ØªÙ… Ù†Ø³Ø® Ø¹Ù†ÙˆØ§Ù† IP Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ¸Ø©!',
    copyFail: 'ÙØ´Ù„ Ù†Ø³Ø® Ø¹Ù†ÙˆØ§Ù† IP.',
};

// Chart.js configuration is handled at script initialization

// Function to show/hide loading spinner
function showLoading(element, show) {
    if (element) {
        element.classList.toggle('active', show);
    }
}

// Function to show/hide error message
function showError(element, message, show) {
    if (element) {
        element.textContent = message;
        element.classList.toggle('active', show);
    }
}

// Function to get user role
function getUserRole() {
    try {
        const user = JSON.parse(localStorage.getItem('user'));
        return user?.role;
    } catch (e) {
        return null;
    }
}

// Helper function to format date to YYYY-MM-DD
function formatDate(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// Function to calculate comparison periods
function calculateComparisonPeriods(type) {
    const today = new Date();
    let period1Start, period1End, period2Start, period2End;

    switch (type) {
        case 'week':
            // Current week (Sunday to Saturday)
            const currentDayOfWeek = today.getDay();
            period1End = new Date(today);
            period1Start = new Date(today);
            period1Start.setDate(today.getDate() - currentDayOfWeek);
            
            // Previous week
            period2End = new Date(period1Start);
            period2End.setDate(period2End.getDate() - 1);
            period2Start = new Date(period2End);
            period2Start.setDate(period2End.getDate() - 6);
            break;

        case 'month':
            // Current month
            period1Start = new Date(today.getFullYear(), today.getMonth(), 1);
            period1End = new Date(today);
            
            // Previous month
            period2Start = new Date(today.getFullYear(), today.getMonth() - 1, 1);
            period2End = new Date(today.getFullYear(), today.getMonth(), 0);
            break;

        case 'quarter':
            // Current quarter
            const currentQuarter = Math.floor(today.getMonth() / 3);
            period1Start = new Date(today.getFullYear(), currentQuarter * 3, 1);
            period1End = new Date(today);
            
            // Previous quarter
            const prevQuarter = currentQuarter - 1;
            const prevQuarterYear = prevQuarter < 0 ? today.getFullYear() - 1 : today.getFullYear();
            const prevQuarterMonth = prevQuarter < 0 ? 9 : prevQuarter * 3;
            period2Start = new Date(prevQuarterYear, prevQuarterMonth, 1);
            period2End = new Date(prevQuarterYear, prevQuarterMonth + 3, 0);
            break;

        default:
            return null;
    }

    return {
        period1: {
            from: formatDate(period1Start),
            to: formatDate(period1End)
        },
        period2: {
            from: formatDate(period2Start),
            to: formatDate(period2End)
        }
    };
}

// Function to calculate percentage change
function calculatePercentageChange(current, previous) {
    if (previous === 0) {
        return current > 0 ? 100 : 0;
    }
    return ((current - previous) / previous * 100).toFixed(1);
}

// Main data fetching function
async function fetchAnalyticsData(filter) {
    // Show loaders for all cards
    document.querySelectorAll('.loading-spinner').forEach(spinner => showLoading(spinner, true));
    document.querySelectorAll('.error-message').forEach(err => showError(err, '', false));

    // Show skeleton loaders for KPIs - optimized
    const kpiContainer = document.getElementById('analytics-kpi-cards');
    if (kpiContainer) {
        // Use document fragment for better performance
        const fragment = document.createDocumentFragment();
        const skeletonHTML = '<div class="stat-card-v2 loading"><div class="skeleton-line" style="width: 40%;"></div><div class="skeleton-line" style="width: 80%;"></div></div>';
        const temp = document.createElement('div');
        temp.innerHTML = skeletonHTML.repeat(6);
        while (temp.firstChild) {
            fragment.appendChild(temp.firstChild);
        }
        kpiContainer.innerHTML = '';
        kpiContainer.appendChild(fragment);
    }


    try {
        // Assuming fetchWithAuth is available globally or imported
        // build query params from provided filter object
        let url = '/api/analytics';
    dlog && dlog('DEBUG: fetchAnalyticsData - initial filter:', filter);
        const qp = new URLSearchParams();
        qp.append('_t', Date.now()); // Cache busting

        if (filter) {
            if (typeof filter === 'object') {
                const from = filter.from;
                const to = filter.to;
                const rangeValue = filter.range; // Renamed to avoid potential conflict, though unlikely

                if (from) qp.set('from', from);
                if (to) qp.set('to', to);
                if (rangeValue) qp.set('range', rangeValue);
            } else { // filter is a string (e.g., '7')
                qp.set('range', filter);
            }
        }

        const queryString = qp.toString();
        if (queryString) {
            url += `?${queryString}`;
        }

    dlog && dlog('DEBUG: fetchAnalyticsData - constructed URL:', url);
        const response = await fetchWithAuth(url);
        if (!response.ok) {
            throw new Error(ARABIC_LABELS.errorFetchingData);
        }
        const result = await response.json();
        return result; // backend returns object with analytics fields
    } catch (error) {
        try { showToast && showToast(ARABIC_LABELS.errorFetchingData, 'error'); } catch (_) {}
        document.querySelectorAll('.chart-card').forEach(card => {
            const errorEl = card.querySelector('.error-message');
            if (errorEl) showError(errorEl, ARABIC_LABELS.errorFetchingData, true);
        });
        return null;
    } finally {
        // Hide all loaders
        document.querySelectorAll('.loading-spinner').forEach(spinner => showLoading(spinner, false));
    }
}

// Fetch data for comparison mode
async function fetchComparisonData(period1, period2) {
    try {
        showToast('Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©...', 'info');
        
        // Fetch both periods in parallel
        const [data1, data2] = await Promise.all([
            fetchAnalyticsData(period1),
            fetchAnalyticsData(period2)
        ]);

        if (!data1 || !data2) {
            throw new Error('ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©');
        }

        comparisonData = {
            period1: data1,
            period2: data2,
            periodInfo: { period1, period2 }
        };

        renderComparisonView();
        showToast('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø© Ø¨Ù†Ø¬Ø§Ø­', 'success');
        
    } catch (error) {
        showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©', 'error');
    }
}

function renderKpiCards(data) {
    const container = document.getElementById('analytics-kpi-cards');
    if (!container || !data) {
        return;
    }

    // Log bonus deposit status
    dlog && dlog('[ANALYTICS-KPI] ğŸ¯ === ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ===');
    dlog && dlog('[ANALYTICS-KPI] ğŸ“Š Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªÙ„Ù…Ø©:', JSON.stringify(data, null, 2));
    dlog && dlog('[ANALYTICS-KPI] ğŸ’° Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø§Ù„Ù…Ù…Ù†ÙˆØ­Ø©:', data.granted_balances);
    dlog && dlog('[ANALYTICS-KPI] ğŸ“ˆ total_competitions_sent:', data.total_competitions_sent);
    dlog && dlog('[ANALYTICS-KPI] ğŸ‘¥ new_agents_in_period:', data.new_agents_in_period);
    dlog && dlog('[ANALYTICS-KPI] ğŸ“ total_activities:', data.total_activities);
    dlog && dlog('[ANALYTICS-KPI] ==================');

    // Extract granted balances data
    const grantedBalances = data.granted_balances || {};
    const tradingBonus = grantedBalances.trading_bonus || { total_amount: 0, winners_count: 0 };
    const depositBonus = grantedBalances.deposit_bonus || [];
    const depositWinners = depositBonus.reduce((sum, b) => sum + (b.winners_count || 0), 0);
    const tradingWinners = tradingBonus.winners_count || 0;
    const totalWinners = depositWinners + tradingWinners;
    const depositRatio = totalWinners > 0 ? ((depositWinners / totalWinners) * 100).toFixed(1) : '0.0';
    
    dlog && dlog('[ANALYTICS-KPI] ğŸ’µ Trading Bonus:', tradingBonus);
    dlog && dlog('[ANALYTICS-KPI] ğŸ Deposit Bonus:', depositBonus);

    container.innerHTML = `
        <div class="stat-card-v2">
            <p class="stat-card-v2-value">${data.total_competitions_sent ?? '0'}</p>
            <h3 class="stat-card-v2-title">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª (Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©)</h3>
        </div>
        <div class="stat-card-v2">
            <p class="stat-card-v2-value">${data.new_agents_in_period ?? '0'}</p>
            <h3 class="stat-card-v2-title">ÙˆÙƒÙ„Ø§Ø¡ Ø¬Ø¯Ø¯ (Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©)</h3>
        </div>
        <div class="stat-card-v2">
            <p class="stat-card-v2-value">${depositRatio}%</p>
            <h3 class="stat-card-v2-title">Ù†Ø³Ø¨Ø© Ø£Ø±ØµØ¯Ø© Ù…Ù…Ù†ÙˆØ­Ø© (Ù†Ø³Ø¨Ø© Ø¥ÙŠØ¯Ø§Ø¹)</h3>
        </div>
        <div class="stat-card-v2">
            <p class="stat-card-v2-value" style="color: var(--accent-color)">$${tradingBonus.total_amount?.toLocaleString() ?? '0'}</p>
            <h3 class="stat-card-v2-title">Ø£Ø±ØµØ¯Ø© Ù…Ù…Ù†ÙˆØ­Ø© (Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ)</h3>
        </div>
        <div class="stat-card-v2">
            <p class="stat-card-v2-value">${tradingBonus.winners_count ?? '0'}</p>
            <h3 class="stat-card-v2-title">Ø¹Ø¯Ø¯ ÙØ§Ø¦Ø²ÙŠÙ† (Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ)</h3>
        </div>
        <div class="stat-card-v2">
            <p class="stat-card-v2-value">${depositBonus.reduce((sum, b) => sum + (b.winners_count || 0), 0)}</p>
            <h3 class="stat-card-v2-title">Ø¥Ø¬Ù…Ø§Ù„ÙŠ ÙØ§Ø¦Ø²ÙŠÙ† (Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹)</h3>
        </div>
    `;
    
    dlog && dlog('[ANALYTICS-KPI] âœ… KPI cards rendered successfully');
}

// --- NEW: Fetch top agent per classification and render table ---
async function fetchTopAgentsPerClassification() {
    const bodyEl = document.getElementById('topAgentsByClassBody');
    const errorEl = document.getElementById('topAgentsByClassError');
    if (!bodyEl) return;
    bodyEl.innerHTML = '<tr class="loading-row"><td colspan="7"><div class="loading-spinner active"></div><p>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø£Ø¨Ø±Ø² Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡...</p></td></tr>';
    errorEl && (errorEl.textContent = '');

    const classifications = ['R','A','B','C'];
    try {
        // Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙ„ØªØ± Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ø®Ø§Øµ Ø¨Ø§Ù„Ù‚Ø³Ù…
        const fromDateInput = document.getElementById('topAgentsFromDate');
        const toDateInput = document.getElementById('topAgentsToDate');
        const fromVal = fromDateInput?.value;
        const toVal = toDateInput?.value;
        let dateQuery = '';
        if (fromVal && toVal) {
            dateQuery = `&from=${fromVal}&to=${toVal}`;
        }

        // Ø§Ø¬Ù„Ø¨ Ø­ØªÙ‰ 5 ÙˆÙƒÙ„Ø§Ø¡ Ù„ÙƒÙ„ ØªØµÙ†ÙŠÙ Ù„Ø­Ø³Ø§Ø¨ Ø£ÙØ¶Ù„Ù‡Ù… Ø¨Ù†Ø¸Ø§Ù… Ù†Ù‚Ø§Ø· Ù…Ø±ÙƒØ¨
        const results = await Promise.all(classifications.map(c => fetchWithAuth(`/api/stats/top-agents?classification=${c}&limit=5${dateQuery}`)));
        // Permission check: if any returns 403 show message
        if (results.every(r => r.status === 403)) {
            bodyEl.innerHTML = '<tr><td colspan="7" style="text-align:center; color:var(--error-color)"><i class="fas fa-lock"></i> Ù„Ø§ ØªÙ…ØªÙ„Ùƒ ØµÙ„Ø§Ø­ÙŠØ© Ø¹Ø±Ø¶ Ø£Ø¨Ø±Ø² Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡.</td></tr>';
            return;
        }
        const jsonData = await Promise.all(results.map(async r => {
            if (!r.ok) {
                await r.text();
                return { data: [] }; // graceful fallback per classification
            }
            return r.json();
        }));
        // cache
        topAgentsLastJson = jsonData;

        // ensure metric controls exist (insert once)
        const card = document.getElementById('topAgentsByClassCard');
        if (card && document.getElementById('topAgentsMetricControls')) {
            document.getElementById('topAgentsMetricControls').remove();
        }
        
        const rowsHtml = classifications.map((c, idx) => {
            const dataArr = jsonData[idx]?.data || [];
            if (!Array.isArray(dataArr) || dataArr.length === 0) {
                return `<tr><td colspan="7" style="text-align:center; color:var(--text-secondary-color)">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ§Ø­Ø© Ù„Ù„ØªØµÙ†ÙŠÙ ${c}</td></tr>`;
            }
            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø±ÙƒØ¨Ø©: Ù…Ø²ÙŠØ¬ Ù…ÙˆØ²ÙˆÙ† Ù…Ù† Ø§Ù„Ù…Ù‚Ø§ÙŠÙŠØ³
            // Ø£ÙˆØ²Ø§Ù† Ø§ÙØªØ±Ø§Ø¶ÙŠØ©: Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª 0.25ØŒ Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª 0.30ØŒ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª 0.30ØŒ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª 0.15
            // ØªØ·Ø¨ÙŠØ¹ Ù†Ø³Ø¨ÙŠ Ø¯Ø§Ø®Ù„ Ù†ÙØ³ Ø§Ù„ØªØµÙ†ÙŠÙ Ù„ØªØ¬Ù†Ø¨ Ù‡ÙŠÙ…Ù†Ø© Ø±Ù‚Ù… ÙˆØ§Ø­Ø¯ ÙƒØ¨ÙŠØ±.
            const maxViews = Math.max(...dataArr.map(a => a.total_views || 0), 1);
            const maxReactions = Math.max(...dataArr.map(a => a.total_reactions || 0), 1);
            const maxParticipants = Math.max(...dataArr.map(a => a.total_participants || 0), 1);
            const maxCompetitions = Math.max(...dataArr.map(a => a.competition_count || 0), 1);

            const scored = dataArr.map(a => {
                const v = (a.total_views || 0) / maxViews;
                const r = (a.total_reactions || 0) / maxReactions;
                const p = (a.total_participants || 0) / maxParticipants;
                const comp = (a.competition_count || 0) / maxCompetitions;
                const score = (v * 0.25) + (r * 0.30) + (p * 0.30) + (comp * 0.15);
                return { ...a, _score: score };
            });

            // ØªØ±ØªÙŠØ¨ ØªÙ†Ø§Ø²Ù„ÙŠ Ø­Ø³Ø¨ Ø§Ù„Ù†Ù‚Ø§Ø· Ø«Ù… ØªÙØ§Ø¹Ù„Ø§Øª Ø«Ù… Ù…Ø´Ø§Ø±ÙƒØ§Øª Ø«Ù… Ù…Ø´Ø§Ù‡Ø¯Ø§Øª ÙƒÙ…Ø¹Ø§ÙŠÙŠØ± ÙƒØ³Ø± Ø§Ù„ØªØ¹Ø§Ø¯Ù„
            scored.sort((a,b) => {
                if (b._score !== a._score) return b._score - a._score;
                if ((b.total_reactions||0) !== (a.total_reactions||0)) return (b.total_reactions||0) - (a.total_reactions||0);
                if ((b.total_participants||0) !== (a.total_participants||0)) return (b.total_participants||0) - (a.total_participants||0);
                return (b.total_views||0) - (a.total_views||0);
            });

            const top = scored[0];
            const scoreDisplay = (top._score * 100).toFixed(1); // ØªØ­ÙˆÙŠÙ„Ù‡ Ù„Ù†Ø³Ø¨Ø© Ù…Ø¦ÙˆÙŠØ© Ù„Ø³Ù‡ÙˆÙ„Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©

            return `<tr>
                <td>
                    <a href="#profile/${top._id}" class="agent-link">${top.name || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}</a>
                </td>
                <td><span class="classification-badge classification-${c.toLowerCase()}">${c}</span></td>
                <td>${top.total_views ?? 0}</td>
                <td>${top.total_reactions ?? 0}</td>
                <td>${top.total_participants ?? 0}</td>
                <td>${top.competition_count ?? 0}</td>
                <td><span class="agent-score" title="Ù…Ø²ÙŠØ¬ Ù…ÙˆØ²ÙˆÙ† Ù…Ù† Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª ÙˆØ§Ù„ØªÙØ§Ø¹Ù„Ø§Øª ÙˆØ§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª ÙˆØ¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª">${scoreDisplay}</span></td>
            </tr>`;
        }).join('');
        bodyEl.innerHTML = rowsHtml;
        // set table class to control column visibility
        try {
            const table = document.getElementById('topAgentsByClassTable');
            if (table) {
                table.classList.remove('metric-views','metric-reactions','metric-participants');
                table.classList.add('metric-'+topAgentsMetric);
            }
        } catch(_){}
    } catch (err) {
        bodyEl.innerHTML = '<tr><td colspan="7">ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.</td></tr>';
        if (errorEl) {
            errorEl.textContent = 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø£Ø¨Ø±Ø² Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ù„ÙƒÙ„ ØªØµÙ†ÙŠÙ';
            errorEl.classList.add('active');
        }
    }
}

// Render KPI cards with comparison
function renderKpiCardsComparison(data1, data2) {
    const container = document.getElementById('analytics-kpi-cards');
    if (!container || !data1 || !data2) return;

    const kpis = [
        {
            title: 'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª',
            icon: 'fa-paper-plane',
            color: 'color-1',
            value1: data1.total_competitions_sent ?? 0,
            value2: data2.total_competitions_sent ?? 0
        },
        {
            title: 'ÙˆÙƒÙ„Ø§Ø¡ Ø¬Ø¯Ø¯',
            icon: 'fa-user-plus',
            color: 'color-2',
            value1: data1.new_agents_in_period ?? 0,
            value2: data2.new_agents_in_period ?? 0
        },
        {
            title: 'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø£Ù†Ø´Ø·Ø©',
            icon: 'fa-history',
            color: 'color-3',
            value1: data1.total_activities ?? 0,
            value2: data2.total_activities ?? 0
        }
    ];

    container.innerHTML = kpis.map(kpi => {
        const percentageChange = calculatePercentageChange(kpi.value1, kpi.value2);
        const isPositive = percentageChange > 0;
        const isNegative = percentageChange < 0;
        const changeClass = isPositive ? 'positive' : isNegative ? 'negative' : 'neutral';
        const arrow = isPositive ? 'â†‘' : isNegative ? 'â†“' : 'â†’';

        return `
            <div class="stat-card-v2 comparison-mode">
                <p class="stat-card-v2-value">${kpi.value1}</p>
                <h3 class="stat-card-v2-title">${kpi.title}</h3>
                <div class="stat-comparison-indicator">
                    <div class="comparison-badge ${changeClass}">
                        <span class="comparison-arrow">${arrow}</span>
                        <span class="comparison-percentage">${Math.abs(percentageChange)}%</span>
                    </div>
                    <span style="color: var(--text-secondary-color); font-size: 0.85em;">
                        Ù…Ù‚Ø§Ø±Ù†Ø© Ø¨Ù€ ${kpi.value2}
                    </span>
                </div>
            </div>
        `;
    }).join('');
}

// --- Hook into existing analytics render flow: after main analytics data fetched ---
// We locate a suitable point: after KPI cards or at end of initial render function.
// If a global init exists we patch its call site. For simplicity we'll invoke from window load hash route via a small timeout.
window.addEventListener('load', () => {
    // Always fetch on page load to support standalone analytics.html
    setTimeout(() => {
        try { fetchTopAgentsPerClassification && fetchTopAgentsPerClassification(); } catch (_) {}
        fetchAndRenderMostInteractiveCompetitions();
    }, 300);
});

// Also re-fetch when hash changes to analytics
window.addEventListener('hashchange', () => {
    if (location.hash === '#analytics') {
        try { fetchTopAgentsPerClassification && fetchTopAgentsPerClassification(); } catch (_) {}
        fetchAndRenderMostInteractiveCompetitions();
    }
});

// Ø£Ø­Ø¯Ø§Ø« ØªÙØ§Ø¹Ù„ Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù‚Ø³Ù…
window.addEventListener('change', (e) => {
    if (e.target && (e.target.id === 'mostInteractiveSortBy' || e.target.id === 'mostInteractiveLimit')) {
        fetchAndRenderMostInteractiveCompetitions();
    }
});
window.addEventListener('click', (e) => {
    if (e.target && (e.target.id === 'mostInteractiveRefresh' || e.target.closest('#mostInteractiveRefresh'))) {
        fetchAndRenderMostInteractiveCompetitions();
    }
});

// Global variables for competitions table
let currentCompetitionsPage = 1;
let competitionsPerPage = 10;
let allCompetitionsData = [];
let filteredCompetitionsData = [];
let currentFilter = 'all';
// Top agents metric selection (views|reactions|participants)
let topAgentsMetric = 'views';
let topAgentsLastJson = null; // cache last fetched per-class data

// Helper function to translate base competition type (legacy)
function translateCompetitionType(type) {
    const translations = {
        'trading': 'Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ',
        'deposit': 'Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹',
        'general': 'Ø¹Ø§Ù…Ø©',
        'Ù…Ù…ÙŠØ²Ø§Øª': 'Ù…Ù…ÙŠØ²Ø§Øª',
        'ØªÙØ§Ø¹Ù„ÙŠØ©': 'ØªÙØ§Ø¹Ù„ÙŠØ©'
    };
    return translations[type] || type || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
}

// Helper function to translate template competition_type to Arabic (preferred)
function translateTemplateCompetitionType(comp) {
    const t = comp?.competition_type;
    if (t === 'standard') return 'Ù…Ù…ÙŠØ²Ø§Øª';
    if (t === 'special') return 'ØªÙØ§Ø¹Ù„ÙŠØ©';
    return null;
}

// Render Completed Competitions Table with performance optimization
function renderCompletedCompetitionsTable(competitions) {
    const tbody = document.getElementById('completedCompetitionsTableBody');
    const errorEl = document.getElementById('completedCompetitionsError');
    
    if (!tbody) return;
    
    if (!competitions || competitions.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="9" style="text-align: center; padding: 40px; color: var(--text-secondary-color);">
                    <i class="fas fa-inbox" style="font-size: 3em; margin-bottom: 15px; display: block;"></i>
                    Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ù…ÙƒØªÙ…Ù„Ø© ÙÙŠ Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©
                </td>
            </tr>
        `;
        return;
    }
    
    // Calculate pagination
    const totalPages = Math.ceil(competitions.length / competitionsPerPage);
    const startIndex = (currentCompetitionsPage - 1) * competitionsPerPage;
    const endIndex = startIndex + competitionsPerPage;
    const paginatedData = competitions.slice(startIndex, endIndex);
    
    // Update summary statistics
    updateCompetitionsSummary(competitions);
    
    // Use document fragment for better performance
    const fragment = document.createDocumentFragment();
    const temp = document.createElement('tbody');
    
    // Render table rows with optimized string building
    temp.innerHTML = paginatedData.map((comp, index) => {
        const globalIndex = startIndex + index + 1;
        const engagementRate = comp.views > 0 ? ((comp.participations / comp.views) * 100).toFixed(1) : 0;
        const engagementClass = engagementRate >= 70 ? 'high' : engagementRate >= 40 ? 'medium' : 'low';
        const classificationClass = comp.classification ? comp.classification.toLowerCase() : '';
        const completedDate = comp.completed_at ? new Date(comp.completed_at).toLocaleDateString('ar-EG') : 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
        const displayType = translateTemplateCompetitionType(comp) || translateCompetitionType(comp.type);
        
        return `
            <tr>
                <td data-label="#">${globalIndex}</td>
                <td data-label="Ø³Ø¤Ø§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©">
                    <span class="competition-question" title="${comp.question || 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}" data-full-question="${(comp.question || 'ØºÙŠØ± Ù…ØªÙˆÙØ±').replace(/"/g,'&quot;')}">
                        ${comp.question || 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}
                    </span>
                </td>
                <td data-label="Ø§Ù„Ù†ÙˆØ¹">
                    <span class="competition-type-badge">${displayType}</span>
                </td>
                <td data-label="Ø§Ù„ØªØµÙ†ÙŠÙ">
                    <span class="competition-classification-badge ${classificationClass}">${comp.classification || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}</span>
                </td>
                <td data-label="Ù…Ø±Ø§Øª Ø§Ù„Ø¥Ø±Ø³Ø§Ù„">
                    <span class="stat-number send-count" data-question="${(comp.question || 'ØºÙŠØ± Ù…ØªÙˆÙØ±').replace(/"/g,'&quot;')}"><i class="fas fa-paper-plane"></i> ${comp.send_count || 0}</span>
                </td>
                <td data-label="Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª">
                    <span class="stat-number"><i class="fas fa-eye"></i> ${comp.views || 0}</span>
                </td>
                <td data-label="Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª">
                    <span class="stat-number"><i class="fas fa-users"></i> ${comp.participations || 0}</span>
                </td>
                <td data-label="Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªÙØ§Ø¹Ù„">
                    <span class="engagement-rate ${engagementClass}">
                        <i class="fas fa-chart-line"></i> ${engagementRate}%
                    </span>
                </td>
                <td data-label="ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡">
                    <span class="competition-date">${completedDate}</span>
                </td>
            </tr>
        `;
    }).join('');
    
    // Clear and append efficiently
    tbody.innerHTML = '';
    tbody.appendChild(temp.firstChild ? temp : document.createTextNode(''));
    while (temp.firstChild) {
        tbody.appendChild(temp.firstChild);
    }
    
    // Update pagination
    requestAnimationFrame(() => updatePagination(totalPages));
}

// Enhance question click to show full text in a modal to avoid layout overflow while keeping accessibility
if (!window.__analyticsQuestionModalHooked) {
    window.__analyticsQuestionModalHooked = true;
    document.addEventListener('click', (e) => {
        const target = e.target.closest('.competition-question');
        if (target && target.dataset.fullQuestion) {
            const existing = document.querySelector('.modal-overlay[data-modal="question-full-text"]');
            if (existing) existing.remove();

            const fullText = target.dataset.fullQuestion;
            // Create lightweight modal
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.setAttribute('data-modal', 'question-full-text');
            const modal = document.createElement('div');
            modal.className = 'form-modal-content';
            modal.style.maxWidth = '700px';
            modal.innerHTML = `
                <div class="form-modal-header">
                    <h3 style="margin:0; font-size:1.1em;"><i class="fas fa-question-circle"></i> Ù†Øµ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„ÙƒØ§Ù…Ù„</h3>
                    <button class="btn-icon-action" id="close-question-modal" title="Ø¥ØºÙ„Ø§Ù‚">&times;</button>
                </div>
                <div class="form-modal-body" style="max-height:60vh; overflow-y:auto;">
                    <p style="line-height:1.6; white-space:pre-line;">${fullText}</p>
                </div>
                <div class="form-actions" style="text-align:left; padding:10px 20px 20px;">
                    <button class="btn-secondary" id="close-question-modal-btn">Ø¥ØºÙ„Ø§Ù‚</button>
                </div>
            `;
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            const close = () => overlay.remove();
            modal.querySelector('#close-question-modal').addEventListener('click', close);
            modal.querySelector('#close-question-modal-btn').addEventListener('click', close);
        }
    });
}

// Click handler: show recipients for a completed competition when clicking send count
if (!window.__analyticsRecipientsHooked) {
    window.__analyticsRecipientsHooked = true;
    document.addEventListener('click', async (e) => {
        const el = e.target.closest('.send-count');
        if (!el) return;

        const question = el.getAttribute('data-question') || '';
        if (!question) return;

        // Build date filter from the current analytics filter controls
        let query = `question=${encodeURIComponent(question)}`;
        const fromInput = document.getElementById('fromDate');
        const toInput = document.getElementById('toDate');
        const activeRangeBtn = document.querySelector('.filter-btn.active[data-range]');
        if (fromInput && toInput && fromInput.value && toInput.value) {
            query += `&from=${encodeURIComponent(fromInput.value)}&to=${encodeURIComponent(toInput.value)}`;
        } else if (activeRangeBtn) {
            const range = activeRangeBtn.getAttribute('data-range');
            if (range) query += `&range=${encodeURIComponent(range)}`;
        } else {
            query += `&range=30`;
        }

        try {
            showToast && showToast('Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡...', 'info');
            const res = await fetchWithAuth(`/api/stats/completed-competition-recipients?${query}`);
            if (!res.ok) {
                const msg = await res.text().catch(()=> '');
                throw new Error(msg || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡');
            }
            const data = await res.json();
            let agents = Array.isArray(data.agents) ? data.agents : [];

            // Sort agents: count desc then name asc for readability
            agents = agents
                .map(a => ({ name: a.name || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ', count: Number(a.count) || 0 }))
                .sort((a, b) => {
                    if (b.count !== a.count) return b.count - a.count;
                    return a.name.localeCompare(b.name, 'ar');
                });

            // Build modal content
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.setAttribute('data-modal', 'competition-recipients');
            // Ø§Ø¬Ø¹Ù„ Ø®Ù„ÙÙŠØ© Ø§Ù„Ø´Ø§Ø´Ø© ØºÙŠØ± Ø´ÙØ§ÙØ© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
            overlay.style.background = 'rgba(0, 0, 0, 0.95)';
            overlay.style.backdropFilter = 'blur(4px)';
            const modal = document.createElement('div');
            modal.className = 'form-modal-content';
            modal.style.maxWidth = '700px';

            const formatAgentsCount = (n) => {
                if (n === 1) return '1 ÙˆÙƒÙŠÙ„';
                if (n === 2) return '2 ÙˆÙƒÙŠÙ„Ø§Ù†';
                return `${n} ÙˆÙƒÙ„Ø§Ø¡`;
            };

            const tableRows = agents.length
                ? agents.map((a, idx) => `
                        <tr>
                            <td style="text-align:center; color:var(--text-secondary-color)">${idx+1}</td>
                            <td>${a.name}</td>
                            <td style="text-align:center; white-space:nowrap;">x${a.count}</td>
                        </tr>`).join('')
                : `<tr><td colspan="3" style="text-align:center; color:var(--text-secondary-color)">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø³Ù…Ø§Ø¡ Ø¶Ù…Ù† Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©</td></tr>`;

            modal.innerHTML = `
                <div class="form-modal-header">
                    <h3 style="margin:0; font-size:1.05em;"><i class="fas fa-paper-plane"></i> Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ø°ÙŠÙ† Ø§Ø³ØªÙ„Ù…ÙˆØ§ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</h3>
                    <button class="btn-icon-action" id="close-recipients-modal" title="Ø¥ØºÙ„Ø§Ù‚">&times;</button>
                </div>
                <div class="form-modal-body" style="max-height:60vh; overflow-y:auto;">
                    <div style="margin-bottom:10px; color:var(--text-secondary-color);">
                        <div><strong>Ø§Ù„Ø³Ø¤Ø§Ù„:</strong> <span style="white-space:pre-wrap;">${question}</span></div>
                        <div><strong>Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ:</strong> ${formatAgentsCount(agents.length)}</div>
                    </div>
                    <div class="table-responsive" style="margin-top:8px;">
                        <table style="width:100%; border-collapse:collapse;">
                            <thead>
                                <tr>
                                    <th style="width:56px; text-align:center; border-bottom:1px solid rgba(255,255,255,0.1);">#</th>
                                    <th style="text-align:right; border-bottom:1px solid rgba(255,255,255,0.1);">Ø§Ù„Ø§Ø³Ù…</th>
                                    <th style="width:120px; text-align:center; border-bottom:1px solid rgba(255,255,255,0.1);">Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù…</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${tableRows}
                            </tbody>
                        </table>
                    </div>
                </div>
                <div class="form-actions" style="text-align:left; padding:10px 20px 20px;">
                    <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-start;">
                        <button class="btn-secondary" id="copy-recipients-btn"><i class="fas fa-copy"></i> Ù†Ø³Ø® Ø§Ù„Ø£Ø³Ù…Ø§Ø¡</button>
                        <button class="btn-secondary" id="close-recipients-modal-btn">Ø¥ØºÙ„Ø§Ù‚</button>
                    </div>
                </div>
            `;

            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            const close = () => overlay.remove();
            modal.querySelector('#close-recipients-modal').addEventListener('click', close);
            modal.querySelector('#close-recipients-modal-btn').addEventListener('click', close);

            // Copy recipients to clipboard: one per line, include count if > 1
            const copyBtn = modal.querySelector('#copy-recipients-btn');
            if (copyBtn) {
                copyBtn.addEventListener('click', async () => {
                    try {
                        const text = agents.length ? agents.map(a => a.count > 1 ? `${a.name} x${a.count}` : a.name).join('\n') : '';
                        if (!text) {
                            showToast && showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù†Ø³Ø®Ù‡Ø§', 'info');
                            return;
                        }
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            await navigator.clipboard.writeText(text);
                        } else {
                            const ta = document.createElement('textarea');
                            ta.value = text;
                            document.body.appendChild(ta);
                            ta.select();
                            document.execCommand('copy');
                            ta.remove();
                        }
                        showToast && showToast('ØªÙ… Ù†Ø³Ø® Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ¸Ø©', 'success');
                    } catch (_) {
                        showToast && showToast('ØªØ¹Ø°Ø± Ù†Ø³Ø® Ø§Ù„Ø£Ø³Ù…Ø§Ø¡', 'error');
                    }
                });
            }

            // ØªÙ…Øª Ø¥Ø²Ø§Ù„Ø© Ø²Ø± ÙˆØªÙ†Ø²ÙŠÙ„ CSV Ø­Ø³Ø¨ Ø§Ù„Ø·Ù„Ø¨
        } catch (err) {
            try { showToast && showToast('ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡', 'error'); } catch(_) {}
        }
    });
}

// Update competitions summary statistics
function updateCompetitionsSummary(competitions) {
    const totalCompetitions = competitions.length;
    const totalViews = competitions.reduce((sum, comp) => sum + (comp.views || 0), 0);
    const totalParticipations = competitions.reduce((sum, comp) => sum + (comp.participations || 0), 0);
    
    document.getElementById('totalCompetitions').textContent = totalCompetitions;
    document.getElementById('totalViews').textContent = totalViews.toLocaleString('ar-EG');
    document.getElementById('totalParticipations').textContent = totalParticipations.toLocaleString('ar-EG');
}

// Update pagination controls
function updatePagination(totalPages) {
    document.getElementById('currentPage').textContent = currentCompetitionsPage;
    document.getElementById('totalPages').textContent = totalPages;
    
    const prevBtn = document.getElementById('prevPage');
    const nextBtn = document.getElementById('nextPage');
    
    if (prevBtn) {
        prevBtn.disabled = currentCompetitionsPage === 1;
    }
    
    if (nextBtn) {
        nextBtn.disabled = currentCompetitionsPage >= totalPages;
    }
}

// Filter competitions by classification
function filterCompetitions(filterType) {
    currentFilter = filterType;
    currentCompetitionsPage = 1; // Reset to first page
    
    if (filterType === 'all') {
        filteredCompetitionsData = [...allCompetitionsData];
    } else {
        // Normalize classification values to ensure case-insensitive matching and trim spaces.
        const wanted = filterType.toUpperCase();
        filteredCompetitionsData = allCompetitionsData.filter(comp => {
            const cls = (comp.classification || '').toString().trim().toUpperCase();
            return cls === wanted;
        });
    }
    
    renderCompletedCompetitionsTable(filteredCompetitionsData);
}


function renderMostFrequentCompetitionsChart(data) {
    const mostFrequentCompetitionsCanvas = document.getElementById('mostFrequentCompetitionsChart');
    const mostFrequentCompetitionsError = document.getElementById('mostFrequentCompetitionsError');
    if (!mostFrequentCompetitionsCanvas) return;
    if (mostFrequentCompetitionsChart) mostFrequentCompetitionsChart.destroy();

    if (!data || data.length === 0) {
        showError(mostFrequentCompetitionsError, ARABIC_LABELS.noData, true);
        return;
    }

    // support template_name (new aggregation) or competition_name (legacy)
    const labels = data.map(item => item.template_name || item.competition_name || item.template_id || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ');
    const counts = data.map(item => item.count);

    mostFrequentCompetitionsChart = new Chart(mostFrequentCompetitionsCanvas, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: ARABIC_LABELS.count,
                data: counts,
                backgroundColor: 'rgba(0, 123, 255, 0.6)', // Vibrant blue
                borderColor: 'rgba(0, 123, 255, 1)', // Vibrant blue
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false,
                },
                title: {
                    display: true,
                    text: ARABIC_LABELS.mostFrequentCompetitions,
                    font: { size: 16 }
                },
                datalabels: {
                    anchor: 'end',
                    align: 'top',
                    formatter: (value) => value,
                    color: '#fff',
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: ARABIC_LABELS.count
                    }
                },
                x: {
                    title: {
                        display: true,
                        text: ARABIC_LABELS.competitionName
                    }
                }
            }
        },
        plugins: [ChartDataLabels]
    });
}

function renderCompetitionsByDayChart(data) {
    if (!agentGrowthCanvas) return;
    if (agentGrowthChart) agentGrowthChart.destroy();

    if (!data || data.length === 0) {
        showError(agentGrowthError, ARABIC_LABELS.noData, true);
        return;
    }

    const labels = data.map(item => item.day);
    const counts = data.map(item => item.count);

    agentGrowthChart = new Chart(agentGrowthCanvas, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª',
                data: counts,
                backgroundColor: 'rgba(33, 150, 243, 0.6)',
                borderColor: 'rgba(33, 150, 243, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false,
                },
                title: {
                    display: true,
                    text: 'Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø­Ø³Ø¨ Ø§Ù„ÙŠÙˆÙ…',
                    font: { size: 16 },
                },
                datalabels: {
                    anchor: 'end',
                    align: 'top',
                    formatter: (value) => value,
                    color: '#fff',
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª'
                    },
                    ticks: { precision: 0 }
                },
                x: {
                    title: {
                        display: true,
                        text: 'Ø§Ù„ÙŠÙˆÙ…'
                    }
                }
            },
            onClick: (event, activeElements) => {
                if (activeElements.length > 0) {
                    const index = activeElements[0].index;
                    const dayName = labels[index];
                    // Build URL with current filter parameters
                    // Determine a safe base path whether we're on pages/analytics.html or index.html#analytics
                    let basePath;
                    const path = window.location.pathname || '';
                    if (path.includes('/pages/')) {
                        basePath = path.replace(/[^\/]*$/, ''); // keep trailing slash
                        basePath += 'day-competitions.html';
                    } else {
                        // When running inside the SPA (index.html), navigate to the standalone page under /pages
                        basePath = '/pages/day-competitions.html';
                    }
                    let url = `${basePath}?day=${encodeURIComponent(dayName)}`;
                    
                    // Get current filter parameters
                    const fromInput = document.getElementById('fromDate');
                    const toInput = document.getElementById('toDate');
                    const activeRangeBtn = document.querySelector('.filter-button.active[data-range]');
                    
                    if (fromInput && toInput && fromInput.value && toInput.value) {
                        url += `&from=${fromInput.value}&to=${toInput.value}`;
                    } else if (activeRangeBtn) {
                        const range = activeRangeBtn.dataset.range;
                        url += `&range=${range}`;
                    }
                    
                    window.location.href = url;
                }
            }
        },
        plugins: [ChartDataLabels]
    });
}

// Render granted balances section
function renderGrantedBalances(data) {
    const tradingBonusAmount = document.getElementById('tradingBonusAmount');
    const tradingBonusWinners = document.getElementById('tradingBonusWinners');
    const depositBonusTableBody = document.getElementById('depositBonusTableBody');
    const grantedBalancesError = document.getElementById('grantedBalancesError');

    if (!data) {
        if (grantedBalancesError) {
            showError(grantedBalancesError, ARABIC_LABELS.noData, true);
        }
        return;
    }

    // Clear previous error
    if (grantedBalancesError) {
        showError(grantedBalancesError, '', false);
    }

    // Debug Log for Granted Balances
    console.log('%c[Analytics] Granted Balances Update:', 'color: #00ff00; font-weight: bold; font-size: 12px;');
    console.log('Trading Bonus Data:', data.trading_bonus);
    console.log('Total Amount:', data.trading_bonus?.total_amount);
    console.log('Winners Count:', data.trading_bonus?.winners_count);
    console.log('Breakdown:', data.trading_bonus?.breakdown);
    console.log('[Deposit Bonus] Raw details from DB:', data.deposit_bonus_details);
    console.log('[Deposit Bonus] Totals by band:', (data.deposit_bonus || []).map(b => ({ value: b.bonus_value ?? b.percentage, winners: b.winners_count })));

    // Update trading bonus
    if (tradingBonusAmount) {
        tradingBonusAmount.textContent = `$${data.trading_bonus?.total_amount?.toLocaleString() || 0}`;
    }
    if (tradingBonusWinners) {
        tradingBonusWinners.textContent = data.trading_bonus?.winners_count || 0;
    }

    // Remove trading bonus breakdown controls per latest requirement
    document.getElementById('toggleTradingBreakdown')?.remove();
    document.getElementById('tradingBonusBreakdownContainer')?.remove();

    // Update deposit bonus table - show aggregated list
    if (depositBonusTableBody) {
        const details = Array.isArray(data.deposit_bonus_details) ? data.deposit_bonus_details : [];
        const REQUIRED_PERCENTAGES = [40, 50, 60, 75, 85, 90, 95, 100];
        const percentTotals = details.reduce((acc, item) => {
            const rawValue = typeof item.bonus_value === 'string' ? parseFloat(item.bonus_value) : item.bonus_value;
            if (!Number.isFinite(rawValue)) {
                return acc;
            }
            const winners = Number(item.total_winners) || 0;
            acc[rawValue] = (acc[rawValue] || 0) + winners;
            return acc;
        }, {});

        const normalizedRows = [];
        REQUIRED_PERCENTAGES.forEach((pct) => {
            normalizedRows.push({ bonus_value: pct, total_winners: percentTotals[pct] || 0, required: true });
            delete percentTotals[pct];
        });

        Object.keys(percentTotals)
            .map((key) => Number(key))
            .filter((pct) => Number.isFinite(pct))
            .sort((a, b) => a - b)
            .forEach((pct) => {
                normalizedRows.push({ bonus_value: pct, total_winners: percentTotals[pct] || 0, required: false });
            });

        const rowsHtml = normalizedRows.map((item) => `
            <tr>
                <td style="font-weight:bold; color:#10b981;">
                    ${item.bonus_value}%${item.required ? '' : ' *'}
                </td>
                <td>${item.total_winners}</td>
            </tr>
        `).join('');

        const tableWrapper = depositBonusTableBody.closest('.deposit-bonus-table');
        if (tableWrapper) tableWrapper.style.display = 'block';
        depositBonusTableBody.innerHTML = rowsHtml;
    }
}

// Render weekly excellence section
function renderWeeklyExcellence(data) {
    const weeklyExcellenceTableBody = document.getElementById('weeklyExcellenceTableBody');
    const weeklyExcellenceError = document.getElementById('weeklyExcellenceError');

    if (!data) {
        if (weeklyExcellenceError) {
            showError(weeklyExcellenceError, ARABIC_LABELS.noData, true);
        }
        return;
    }

    // Clear previous error
    if (weeklyExcellenceError) {
        showError(weeklyExcellenceError, '', false);
    }

    if (weeklyExcellenceTableBody) {
        const currentWeek = data.current_week || {};
        const previousWeek = data.previous_week || {};
        const change = data.change || {};

        // Helper function to format change percentage with color
        const formatChange = (changeValue) => {
            const value = parseFloat(changeValue) || 0;
            const sign = value >= 0 ? '+' : '';
            const colorClass = value >= 0 ? 'positive-change' : 'negative-change';
            return `<span class="${colorClass}">${sign}${value}%</span>`;
        };

        const rowsHtml = `
            <tr>
                <td><strong>Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª</strong></td>
                <td>${currentWeek.competitions_count || 0}</td>
                <td>${previousWeek.competitions_count || 0}</td>
                <td>${formatChange(change.competitions_change)}</td>
            </tr>
            <tr>
                <td><strong>Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª</strong></td>
                <td>${currentWeek.total_participations || 0}</td>
                <td>${previousWeek.total_participations || 0}</td>
                <td>${formatChange(change.participations_change)}</td>
            </tr>
        `;

        weeklyExcellenceTableBody.innerHTML = rowsHtml;
    }
}

function renderAgentClassificationChart(data) {
    if (!agentClassificationCanvas) return;
    if (agentClassificationChart) agentClassificationChart.destroy();

    if (!data || Object.keys(data).length === 0) {
        showError(agentClassificationError, ARABIC_LABELS.noData, true);
        return;
    }

    const labels = Object.keys(data);
    const counts = Object.values(data);

    agentClassificationChart = new Chart(agentClassificationCanvas, {
        type: 'doughnut',
        data: {
            labels: labels,
            datasets: [{
                label: ARABIC_LABELS.count,
                data: counts,
                backgroundColor: ['#4CAF50', '#F4A261', '#2196F3', '#9C27B0', '#795548'],
                borderColor: 'var(--card-bg-color)',
                borderWidth: 2
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: ARABIC_LABELS.agentClassification,
                    font: { size: 16 }
                },
                legend: {
                    position: 'bottom',
                },
                datalabels: {
                    color: '#fff',
                    formatter: (value, context) => {
                        const sum = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                        const percentage = (value / sum * 100).toFixed(0) + '%';
                        return percentage;
                    },
                }
            }
        },
        plugins: [ChartDataLabels]
    });
}

function renderCompetitionPerformanceChart(data) {
    if (!competitionPerformanceCanvas) return;
    if (competitionPerformanceChart) competitionPerformanceChart.destroy();

    if (!data || data.length === 0) {
        showError(competitionPerformanceError, ARABIC_LABELS.noData, true);
        return;
    }

    const labels = data.map(item => item.template_name || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ');
    const counts = data.map(item => item.total_views);

    competitionPerformanceChart = new Chart(competitionPerformanceCanvas, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: ARABIC_LABELS.views,
                data: counts,
                backgroundColor: 'rgba(244, 162, 97, 0.6)',
                borderColor: 'rgba(244, 162, 97, 1)',
                borderWidth: 1
            }]
        },
        options: {
            indexAxis: 'y', // Horizontal bar chart
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: ARABIC_LABELS.competitionPerformance,
                    font: { size: 16 }
                },
                datalabels: {
                    anchor: 'end',
                    align: 'end',
                    color: '#fff'
                }
            },
            scales: {
                x: {
                    beginAtZero: true,
                    title: { display: true, text: ARABIC_LABELS.views }
                }
            }
        },
        plugins: [ChartDataLabels]
    });
}


// Global variables for Rank Changes Pagination
let allRankChangesData = [];
let currentRankChangesPage = 1;
const RANK_CHANGES_PER_PAGE = 7;

// Function to fetch and render agent rank changes
async function fetchAndRenderRankChanges(filter) {
    const rankChangesTableBody = document.getElementById('rankChangesTableBody');
    const rankChangesError = document.getElementById('rankChangesError');
    
    if (!rankChangesTableBody) return;
    
    // Initialize purge button after elements are loaded
    initRankChangesPurgeButton();
    
    try {
        // Build query params
        let url = '/api/stats/rank-changes?limit=100'; // Increased limit to fetch more for client-side pagination
        
        if (filter) {
            if (typeof filter === 'object') {
                if (filter.from) url += `&from=${filter.from}`;
                if (filter.to) url += `&to=${filter.to}`;
            } else if (filter !== 'all') {
                // For range filters, calculate dates
                const endDate = new Date();
                const startDate = new Date();
                
                if (filter === 'year') {
                    startDate.setMonth(0, 1);
                } else {
                    const days = parseInt(filter) || 30;
                    startDate.setDate(startDate.getDate() - days);
                }
                
                url += `&from=${startDate.toISOString().split('T')[0]}&to=${endDate.toISOString().split('T')[0]}`;
            }
        }
        
        const response = await fetchWithAuth(url);
        if (!response.ok) {
            throw new Error('ÙØ´Ù„ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø©');
        }
        
        const result = await response.json();
        allRankChangesData = result.rankChanges || [];
        currentRankChangesPage = 1; // Reset to first page
        
        renderRankChangesPage(currentRankChangesPage);

    } catch (error) {
        console.error('Error fetching rank changes:', error);
        if (rankChangesError) {
            showError(rankChangesError, 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', true);
        }
        if (rankChangesTableBody) {
            rankChangesTableBody.innerHTML = `<tr><td colspan="10" style="text-align:center; color:red;">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</td></tr>`;
        }
    }
}

function renderRankChangesPage(page) {
    const rankChangesTableBody = document.getElementById('rankChangesTableBody');
    if (!rankChangesTableBody) return;

    if (allRankChangesData.length === 0) {
        rankChangesTableBody.innerHTML = `
            <tr>
                <td colspan="10" style="text-align: center; padding: 30px;">
                    <i class="fas fa-info-circle" style="font-size: 48px; color: #95a5a6; margin-bottom: 10px;"></i>
                    <p style="color: #7f8c8d; font-size: 16px;">Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØºÙŠÙŠØ±Ø§Øª ÙÙŠ Ø§Ù„Ù…Ø±Ø§ØªØ¨ Ø®Ù„Ø§Ù„ Ù‡Ø°Ù‡ Ø§Ù„ÙØªØ±Ø©</p>
                </td>
            </tr>
        `;
        renderRankChangesPaginationControls();
        return;
    }

    const startIndex = (page - 1) * RANK_CHANGES_PER_PAGE;
    const endIndex = startIndex + RANK_CHANGES_PER_PAGE;
    const pageData = allRankChangesData.slice(startIndex, endIndex);

    // Check if user is super_admin
    const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
    const isSuperAdmin = currentUser.role === 'super_admin';
    
    // Render table rows with truncated reason/action and click-to-expand
    rankChangesTableBody.innerHTML = pageData.map((change, index) => {
        const globalIndex = startIndex + index + 1;
        const date = new Date(change.createdAt);
        const formattedDate = date.toLocaleDateString('ar-EG', {
            year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
        });
        const truncate = (text, max=50) => {
            if (!text) return '';
            const t = String(text);
            return t.length > max ? t.slice(0, max) + 'â€¦' : t;
        };
        const esc = (s='') => String(s)
            .replace(/&/g,'&amp;')
            .replace(/</g,'&lt;')
            .replace(/>/g,'&gt;')
            .replace(/"/g,'&quot;')
            .replace(/'/g,'&#39;');
        const classification = change.classification || change.agent_classification || change.class || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
        const classificationSlug = classification ? classification.toString().trim().toLowerCase() : 'unknown';
        
        // Determine if this is a rank change or classification change
        const isClassificationChange = change.change_type === 'classification';
        
        // Ensure we have valid strings for ranks
        const oldRank = change.old_rank ? String(change.old_rank) : '---';
        const newRank = change.new_rank ? String(change.new_rank) : '---';

        let changeDisplay = '';
        if (isClassificationChange) {
            // Display classification change from â†’ to (Reversed for RTL: New <- Old)
            changeDisplay = `
                <td colspan="2" style="text-align: center;">
                    <div style="display: flex; justify-content: center; align-items: center; gap: 8px;">
                        <span class="classification-badge classification-${(change.old_classification || '').toLowerCase()}">${esc(change.old_classification || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}</span>
                        <i class="fas fa-arrow-left" style="color: #4fa3ff;"></i>
                        <span class="classification-badge classification-${(change.new_classification || '').toLowerCase()}">${esc(change.new_classification || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}</span>
                    </div>
                    <div style="font-size: 11px; color: #7f8c8d; margin-top: 4px;">ØªØºÙŠÙŠØ± Ø§Ù„ØªØµÙ†ÙŠÙ</div>
                </td>
            `;
        } else {
            // Display rank change - Using inline styles to debug visibility
            changeDisplay = `
                <td colspan="2" style="text-align: center; vertical-align: middle;">
                    <span style="color: #2ecc71; font-weight: bold; padding: 4px 8px; background: rgba(46, 204, 113, 0.1); border-radius: 4px;">${newRank}</span>
                    <i class="fas fa-arrow-left" style="color: #7f8c8d; margin: 0 8px;"></i>
                    <span style="color: #e74c3c; font-weight: bold; padding: 4px 8px; background: rgba(231, 76, 60, 0.1); border-radius: 4px;">${oldRank}</span>
                </td>
            `;
        }
        
        return `
            <tr>
                <td>${globalIndex}</td>
                <td><strong>${esc(change.agent_name)}</strong></td>
                <td>${esc(change.agent_number)}</td>
                <td><span class="classification-badge classification-${classificationSlug}">${esc(classification)}</span></td>
                ${changeDisplay}
                <td><div class="reason-cell" data-fulltext="${esc(change.reason)}">${truncate(change.reason, 60)}</div></td>
                <td><div class="action-cell" data-fulltext="${esc(change.action_taken)}">${truncate(change.action_taken, 60)}</div></td>
                <td style="white-space: nowrap;">${formattedDate}</td>
                <td style="text-align: center;">
                    <button class="btn btn-danger btn-sm delete-rank-change-btn" data-change-id="${change._id}" title="Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„ØªØºÙŠÙŠØ±">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                </td>
            </tr>
        `;
    }).join('');

    // Attach click handlers for expanding full text
    rankChangesTableBody.querySelectorAll('.reason-cell, .action-cell').forEach(el => {
        el.style.cursor = 'pointer';
        el.title = 'Ø§Ù†Ù‚Ø± Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù†Øµ ÙƒØ§Ù…Ù„Ù‹Ø§';
        el.addEventListener('click', () => {
            const full = el.getAttribute('data-fulltext') || '';
            const label = el.classList.contains('reason-cell') ? 'Ø§Ù„Ø³Ø¨Ø¨' : 'Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡';
            if (typeof showConfirmationModal === 'function') {
                const styled = `
                    <div class="dark-expand-modal-wrapper">
                        <div class="dark-expand-modal">
                            <div class="dark-expand-modal-header">
                                <i class="fas fa-align-left" style="color:#4fa3ff"></i>${label} Ø§Ù„ÙƒØ§Ù…Ù„
                            </div>
                            <div class="dark-expand-modal-body">
                                <pre>${full}</pre>
                            </div>
                        </div>
                    </div>`;
                showConfirmationModal(styled, async () => true, { title: '', confirmText: '<i class="fas fa-times"></i> Ø¥ØºÙ„Ø§Ù‚', showCancel: false });
            } else { alert(full); }
        });
    });

    // Attach delete handlers
    rankChangesTableBody.querySelectorAll('.delete-rank-change-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const changeId = btn.getAttribute('data-change-id');
            if (!changeId) return;
            
            const confirmDelete = await new Promise(resolve => {
                if (typeof showConfirmationModal === 'function') {
                    showConfirmationModal('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¬Ù„ØŸ', async () => {
                        resolve(true);
                    }, { title: 'ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù', confirmText: 'Ø­Ø°Ù', cancelText: 'Ø¥Ù„ØºØ§Ø¡' });
                } else {
                    resolve(confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¬Ù„ØŸ'));
                }
            });

            if (confirmDelete) {
                try {
                    const res = await fetchWithAuth(`/api/stats/rank-changes/${changeId}`, { method: 'DELETE' });
                    if (res.ok) {
                        showToast('ØªÙ… Ø­Ø°Ù Ø§Ù„Ø³Ø¬Ù„ Ø¨Ù†Ø¬Ø§Ø­', 'success');
                        // Remove from local data and re-render
                        allRankChangesData = allRankChangesData.filter(item => item._id !== changeId);
                        renderRankChangesPage(currentRankChangesPage);
                    } else {
                        showToast('ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ø³Ø¬Ù„', 'error');
                    }
                } catch (err) {
                    console.error(err);
                    showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø°Ù', 'error');
                }
            }
        });
    });

    renderRankChangesPaginationControls();
}

function renderRankChangesPaginationControls() {
    const table = document.getElementById('rankChangesTable');
    if (!table) return;
    
    let paginationContainer = document.getElementById('rankChangesPagination');
    if (!paginationContainer) {
        paginationContainer = document.createElement('div');
        paginationContainer.id = 'rankChangesPagination';
        paginationContainer.className = 'pagination-controls';
        paginationContainer.style.cssText = 'display: flex; justify-content: center; align-items: center; gap: 15px; margin-top: 15px; direction: ltr;';
        table.parentNode.insertAdjacentElement('afterend', paginationContainer);
    }

    const totalPages = Math.ceil(allRankChangesData.length / RANK_CHANGES_PER_PAGE);
    
    if (totalPages <= 1) {
        paginationContainer.style.display = 'none';
        return;
    }

    paginationContainer.style.display = 'flex';
    paginationContainer.innerHTML = `
        <button id="nextRankPage" class="btn btn-secondary btn-sm" ${currentRankChangesPage === totalPages ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>
            Ø§Ù„ØªØ§Ù„ÙŠ <i class="fas fa-chevron-right"></i>
        </button>
        <span style="font-weight: bold; color: var(--text-primary-color);">
            ØµÙØ­Ø© ${currentRankChangesPage} Ù…Ù† ${totalPages}
        </span>
        <button id="prevRankPage" class="btn btn-secondary btn-sm" ${currentRankChangesPage === 1 ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>
            <i class="fas fa-chevron-left"></i> Ø§Ù„Ø³Ø§Ø¨Ù‚
        </button>
    `;

    document.getElementById('prevRankPage')?.addEventListener('click', () => {
        if (currentRankChangesPage > 1) {
            currentRankChangesPage--;
            renderRankChangesPage(currentRankChangesPage);
        }
    });

    document.getElementById('nextRankPage')?.addEventListener('click', () => {
        if (currentRankChangesPage < totalPages) {
            currentRankChangesPage++;
            renderRankChangesPage(currentRankChangesPage);
        }
    });
}

// Function to update all charts and table with performance optimization
async function updateDashboard(filter) {
    const analyticsData = await fetchAnalyticsData(filter);
    if (analyticsData) {
    dlog && dlog('Analytics Data:', analyticsData);
    dlog && dlog('Completed Competitions:', analyticsData.completed_competitions);
        
        // Use requestAnimationFrame for smooth rendering
        requestAnimationFrame(() => {
            // Always pass full analytics object so KPI cards can access granted_balances
            renderKpiCards(analyticsData);
        });
        
        // Render table with virtual scrolling support
        requestAnimationFrame(() => {
            if (analyticsData.completed_competitions) {
                allCompetitionsData = analyticsData.completed_competitions;
                filteredCompetitionsData = [...allCompetitionsData];
                dlog && dlog('Rendering table with', filteredCompetitionsData.length, 'competitions');
                renderCompletedCompetitionsTable(filteredCompetitionsData);
            } else {
                renderCompletedCompetitionsTable([]);
            }
        });
        
        // Defer heavy chart rendering
        setTimeout(() => {
            renderCompetitionsByDayChart(analyticsData.competitions_by_day);
        }, 100);
        
        setTimeout(() => {
            renderGrantedBalances(analyticsData.granted_balances);
            renderWeeklyExcellence(analyticsData.weekly_excellence);
        }, 200);
        
        setTimeout(() => {
            renderCompetitionPerformanceChart(analyticsData.competition_performance);
        }, 300);
        
        // Lazy load interactive competitions
        setTimeout(async () => {
            try {
                await fetchAndRenderMostInteractiveCompetitions();
            } catch (e) { /* ignore */ }
        }, 400);
        
        // Lazy load rank changes
        setTimeout(async () => {
            await fetchAndRenderRankChanges(filter);
        }, 500);
    }
}


// Render comparison view
async function renderComparisonView() {
    if (!comparisonData.period1 || !comparisonData.period2) return;

    const data1 = comparisonData.period1;
    const data2 = comparisonData.period2;
    // 1. KPI Cards (enhanced: derive comparison object if backend didn't provide .kpis)
    const kpis1 = data1.kpis || {
        total_competitions_sent: data1.total_competitions_sent,
        new_agents_in_period: data1.new_agents_in_period,
        total_activities: data1.total_activities
    };
    const kpis2 = data2.kpis || {
        total_competitions_sent: data2.total_competitions_sent,
        new_agents_in_period: data2.new_agents_in_period,
        total_activities: data2.total_activities
    };
    renderKpiCardsComparison(kpis1, kpis2);

    // 2. Completed competitions table â€“ show period1 data, but add small comparison badge if template appears in both
    if (Array.isArray(data1.completed_competitions)) {
        allCompetitionsData = data1.completed_competitions.map(comp => {
            const match = (data2.completed_competitions||[]).find(c => c.template_id === comp.template_id);
            if (match) {
                return {
                    ...comp,
                    _comparison: {
                        views_change: (comp.views||0) - (match.views||0),
                        participations_change: (comp.participations||0) - (match.participations||0)
                    }
                };
            }
            return comp;
        });
        filteredCompetitionsData = [...allCompetitionsData];
        renderCompletedCompetitionsTable(filteredCompetitionsData);
        // Inject comparison badges after render
        try {
            document.querySelectorAll('#completedCompetitionsTableBody tr').forEach(row => {
                const idx = row.querySelector('td[data-label="#"]');
                const questionCell = row.querySelector('td[data-label="Ø³Ø¤Ø§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"]');
                if (!questionCell) return;
                const compIndex = parseInt(idx?.textContent||'0',10)-1;
                const compObj = filteredCompetitionsData[compIndex];
                if (compObj && compObj._comparison) {
                    const badge = document.createElement('span');
                    const v = compObj._comparison.views_change;
                    const p = compObj._comparison.participations_change;
                    const cls = (v>0||p>0) ? 'positive' : (v<0||p<0) ? 'negative' : 'neutral';
                    badge.className = 'comparison-mini-badge '+cls;
                    badge.title = 'Ù…Ù‚Ø§Ø±Ù†Ø© Ø¨Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©: ØªØºÙŠØ± Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª ÙˆØ§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª';
                    badge.textContent = `${v>=0?'+':''}${v}V / ${p>=0?'+':''}${p}P`;
                    questionCell.appendChild(badge);
                }
            });
        } catch(_){}
    } else {
        renderCompletedCompetitionsTable([]);
    }

    // 3. Most frequent competitions chart comparison (already dual)
    renderMostFrequentCompetitionsChartComparison(
        data1.most_frequent_competitions,
        data2.most_frequent_competitions
    );

    // 4. Competitions by day â€“ overlay both periods for visual diff
    if (agentGrowthCanvas && Array.isArray(data1.competitions_by_day)) {
        if (agentGrowthChart) agentGrowthChart.destroy();
        const daysSet = new Set();
        (data1.competitions_by_day||[]).forEach(d=>daysSet.add(d.day));
        (data2.competitions_by_day||[]).forEach(d=>daysSet.add(d.day));
        const labels = Array.from(daysSet);
        const counts1 = labels.map(l => (data1.competitions_by_day||[]).find(d=>d.day===l)?.count || 0);
        const counts2 = labels.map(l => (data2.competitions_by_day||[]).find(d=>d.day===l)?.count || 0);
        agentGrowthChart = new Chart(agentGrowthCanvas, {
            type: 'bar',
            data: { labels, datasets: [
                { label: 'Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰', data: counts1, backgroundColor: 'rgba(76,175,80,0.6)', borderColor: 'rgba(76,175,80,1)', borderWidth:1 },
                { label: 'Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©', data: counts2, backgroundColor: 'rgba(33,150,243,0.6)', borderColor: 'rgba(33,150,243,1)', borderWidth:1 }
            ]},
            options: { responsive:true, maintainAspectRatio:false, plugins:{ legend:{display:true}, title:{display:true, text:'Ù…Ù‚Ø§Ø±Ù†Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø­Ø³Ø¨ Ø§Ù„ÙŠÙˆÙ…'} }, scales:{ y:{ beginAtZero:true, ticks:{precision:0} } } },
            plugins: [ChartDataLabels]
        });
    }

    // 5. Agent classification â€“ show percentage change between periods if both available
    if (agentClassificationCanvas && data1.agent_classification && data2.agent_classification) {
        if (agentClassificationChart) agentClassificationChart.destroy();
        const allKeys = Array.from(new Set([...Object.keys(data1.agent_classification), ...Object.keys(data2.agent_classification)]));
        const vals1 = allKeys.map(k => data1.agent_classification[k]||0);
        const vals2 = allKeys.map(k => data2.agent_classification[k]||0);
        agentClassificationChart = new Chart(agentClassificationCanvas, {
            type: 'bar',
            data: { labels: allKeys, datasets: [
                { label: 'Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰', data: vals1, backgroundColor: 'rgba(244,162,97,0.6)', borderColor:'rgba(244,162,97,1)' },
                { label: 'Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©', data: vals2, backgroundColor: 'rgba(153,102,255,0.6)', borderColor:'rgba(153,102,255,1)' }
            ]},
            options: { responsive:true, maintainAspectRatio:false, plugins:{ legend:{display:true}, title:{display:true, text:'Ù…Ù‚Ø§Ø±Ù†Ø© ØªØµÙ†ÙŠÙØ§Øª Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡'} } },
            plugins:[ChartDataLabels]
        });
    } else {
        renderAgentClassificationChart(data1.agent_classification);
    }

    // 6. Competition performance â€“ overlay both periods
    if (competitionPerformanceCanvas && Array.isArray(data1.competition_performance)) {
        if (competitionPerformanceChart) competitionPerformanceChart.destroy();
        const templateSet = new Set();
        (data1.competition_performance||[]).forEach(d=>templateSet.add(d.template_name||'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'));
        (data2.competition_performance||[]).forEach(d=>templateSet.add(d.template_name||'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'));
        const labels = Array.from(templateSet);
        const views1 = labels.map(l => (data1.competition_performance||[]).find(d=> (d.template_name||'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')===l)?.total_views || 0);
        const views2 = labels.map(l => (data2.competition_performance||[]).find(d=> (d.template_name||'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')===l)?.total_views || 0);
        competitionPerformanceChart = new Chart(competitionPerformanceCanvas, {
            type: 'bar',
            data: { labels, datasets:[
                { label:'Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰', data: views1, backgroundColor:'rgba(255,99,132,0.6)', borderColor:'rgba(255,99,132,1)', borderWidth:1 },
                { label:'Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©', data: views2, backgroundColor:'rgba(54,162,235,0.6)', borderColor:'rgba(54,162,235,1)', borderWidth:1 }
            ]},
            options:{ indexAxis:'y', responsive:true, maintainAspectRatio:false, plugins:{ legend:{display:true}, title:{display:true, text:'Ù…Ù‚Ø§Ø±Ù†Ø© Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª'} } },
            plugins:[ChartDataLabels]
        });
    }

    // 7. Granted balances â€“ show both sets side by side (simple table build inside existing container)
    try {
        const depositBonusTableBody = document.getElementById('depositBonusTableBody');
        if (depositBonusTableBody && data1.granted_balances && data2.granted_balances) {
            const wrap = depositBonusTableBody.closest('.deposit-bonus-table');
            if (wrap) wrap.style.display = 'block';
            const list1 = Array.isArray(data1.granted_balances.deposit_bonus_dynamic) ? data1.granted_balances.deposit_bonus_dynamic : [];
            const list2 = Array.isArray(data2.granted_balances.deposit_bonus_dynamic) ? data2.granted_balances.deposit_bonus_dynamic : [];
            const percSet = new Set();
            list1.forEach(d=>percSet.add(d.percentage));
            list2.forEach(d=>percSet.add(d.percentage));
            const rows = Array.from(percSet).sort((a,b)=>a-b).map(p => {
                const r1 = list1.find(d=>d.percentage==p)?.winners_count||0;
                const r2 = list2.find(d=>d.percentage==p)?.winners_count||0;
                const diff = r1 - r2;
                const cls = diff>0?'positive':diff<0?'negative':'neutral';
                return `<tr><td>${p}%</td><td class="comparison ${cls}">${r1}</td><td class="comparison ${cls}">${r2}</td><td class="diff ${cls}">${diff>=0?'+':''}${diff}</td></tr>`;
            }).join('');
            depositBonusTableBody.innerHTML = rows || '<tr><td colspan="4">Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙØ§Ø¦Ø²ÙˆÙ† ÙÙŠ Ø£ÙŠ ÙØªØ±Ø©.</td></tr>';
        } else {
            renderGrantedBalances(data1.granted_balances);
        }
        // Trading bonus simple comparison
        const tradingBonusAmount = document.getElementById('tradingBonusAmount');
        const tradingBonusWinners = document.getElementById('tradingBonusWinners');
        if (tradingBonusAmount && data1.granted_balances?.trading_bonus) {
            const tb1 = data1.granted_balances.trading_bonus.total_amount||0;
            const tb2 = data2.granted_balances?.trading_bonus?.total_amount||0;
            tradingBonusAmount.innerHTML = `$${tb1.toLocaleString()} <span class="mini-diff ${(tb1-tb2)>0?'positive':(tb1-tb2)<0?'negative':'neutral'}">${(tb1-tb2)>=0?'+':''}${tb1-tb2}</span>`;
        }
        if (tradingBonusWinners && data1.granted_balances?.trading_bonus) {
            const w1 = data1.granted_balances.trading_bonus.winners_count||0;
            const w2 = data2.granted_balances?.trading_bonus?.winners_count||0;
            tradingBonusWinners.innerHTML = `${w1} <span class="mini-diff ${(w1-w2)>0?'positive':(w1-w2)<0?'negative':'neutral'}">${(w1-w2)>=0?'+':''}${w1-w2}</span>`;
        }
    } catch(_){}

    // 8. Weekly excellence â€“ fetch data for both periods with comparison columns
    try {
        const weeklyExcellenceTableBody = document.getElementById('weeklyExcellenceTableBody');
        if (weeklyExcellenceTableBody) {
            // Fetch fresh weekly excellence data for both periods
            const params1 = new URLSearchParams();
            if (comparisonData.periodInfo.period1.from) params1.set('from', comparisonData.periodInfo.period1.from);
            if (comparisonData.periodInfo.period1.to) params1.set('to', comparisonData.periodInfo.period1.to);
            const params2 = new URLSearchParams();
            if (comparisonData.periodInfo.period2.from) params2.set('from', comparisonData.periodInfo.period2.from);
            if (comparisonData.periodInfo.period2.to) params2.set('to', comparisonData.periodInfo.period2.to);
            
            const [resp1, resp2] = await Promise.all([
                fetchWithAuth(`/api/analytics?${params1.toString()}`),
                fetchWithAuth(`/api/analytics?${params2.toString()}`)
            ]);
            
            let we1 = null, we2 = null;
            if (resp1.ok) {
                const d1 = await resp1.json();
                we1 = d1.weekly_excellence;
            }
            if (resp2.ok) {
                const d2 = await resp2.json();
                we2 = d2.weekly_excellence;
            }
            
            if (we1 && we2) {
                const cw1 = we1.current_week||{};
                const cw2 = we2.current_week||{};
                const compDiff = (cw1.competitions_count||0) - (cw2.competitions_count||0);
                const partDiff = (cw1.total_participations||0) - (cw2.total_participations||0);
                weeklyExcellenceTableBody.innerHTML = `
                    <tr>
                        <td><strong>Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª</strong></td>
                        <td>${cw1.competitions_count||0}</td>
                        <td>${cw2.competitions_count||0}</td>
                        <td><span class="diff-badge ${compDiff>0?'positive':compDiff<0?'negative':'neutral'}">${compDiff>=0?'+':''}${compDiff}</span></td>
                    </tr>
                    <tr>
                        <td><strong>Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª</strong></td>
                        <td>${cw1.total_participations||0}</td>
                        <td>${cw2.total_participations||0}</td>
                        <td><span class="diff-badge ${partDiff>0?'positive':partDiff<0?'negative':'neutral'}">${partDiff>=0?'+':''}${partDiff}</span></td>
                    </tr>`;
            } else {
                renderWeeklyExcellence(data1.weekly_excellence);
            }
        }
    } catch(_){ renderWeeklyExcellence(data1.weekly_excellence); }

    // 9. Rank changes â€“ display only period1 but attach modal comparison when row clicked
    try {
        if (Array.isArray(data1.rank_changes) && Array.isArray(data2.rank_changes)) {
            // If backend names differ (rankChanges) unify
            const rc1 = data1.rank_changes || data1.rankChanges || [];
            const rc2 = data2.rank_changes || data2.rankChanges || [];
            // Simple render of period1
            fetchAndRenderRankChanges(comparisonData.periodInfo.period1);
            // Attach comparison modal enrich after slight delay
            setTimeout(() => {
                const body = document.getElementById('rankChangesTableBody');
                if (!body) return;
                const map2 = new Map(rc2.map(r=>[r.agent_id+'|'+r.createdAt, r]));
                body.querySelectorAll('tr').forEach(tr => {
                    const agentNameCell = tr.children[1];
                    if (!agentNameCell) return;
                    tr.addEventListener('click', () => {
                        const agent = agentNameCell.textContent.trim();
                        const matches1 = rc1.filter(r=>r.agent_name===agent);
                        const matches2 = rc2.filter(r=>r.agent_name===agent);
                        const diffCount = matches1.length - matches2.length;
                        const cls = diffCount>0?'positive':diffCount<0?'negative':'neutral';
                        const html = `<div class="rank-compare-modal"><h3>Ù…Ù‚Ø§Ø±Ù†Ø© ØªØºÙŠÙŠØ±Ø§Øª Ù…Ø±ØªØ¨Ø© Ø§Ù„ÙˆÙƒÙŠÙ„: ${agent}</h3><p>Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰: ${matches1.length} / Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©: ${matches2.length} <span class="diff-badge ${cls}">${diffCount>=0?'+':''}${diffCount}</span></p></div>`;
                        if (typeof showConfirmationModal === 'function') {
                            showConfirmationModal(html, async ()=>true, { title:'', confirmText:'Ø¥ØºÙ„Ø§Ù‚', showCancel:false });
                        } else { alert(html.replace(/<[^>]+>/g,'')); }
                    });
                });
            }, 600);
        } else {
            fetchAndRenderRankChanges(comparisonData.periodInfo.period1);
        }
    } catch(_){}
    
    // 10. Most Interactive Competitions â€“ fetch both periods and show comparison side-by-side
    try {
        const listEl = document.getElementById('mostInteractiveCompetitionsList');
        if (listEl) {
            listEl.innerHTML = '<div class="loading-spinner active"></div><p style="margin:8px 0 0; color:var(--text-secondary-color)">Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©...</p>';
            
            const sortSelect = document.getElementById('mostInteractiveSortBy');
            const limitSelect = document.getElementById('mostInteractiveLimit');
            const sortBy = sortSelect ? sortSelect.value : 'views';
            const limit = limitSelect ? parseInt(limitSelect.value, 10) : 50;
            
            const params1 = new URLSearchParams();
            params1.set('from', comparisonData.periodInfo.period1.from);
            params1.set('to', comparisonData.periodInfo.period1.to);
            params1.set('limit', limit);
            params1.set('sort', sortBy);
            
            const params2 = new URLSearchParams();
            params2.set('from', comparisonData.periodInfo.period2.from);
            params2.set('to', comparisonData.periodInfo.period2.to);
            params2.set('limit', limit);
            params2.set('sort', sortBy);
            
            const [resp1, resp2] = await Promise.all([
                fetchWithAuth(`/api/stats/interactive-competitions?${params1.toString()}`),
                fetchWithAuth(`/api/stats/interactive-competitions?${params2.toString()}`)
            ]);
            
            let comps1 = [], comps2 = [];
            if (resp1.ok) {
                const d1 = await resp1.json();
                comps1 = Array.isArray(d1?.data) ? d1.data : [];
            }
            if (resp2.ok) {
                const d2 = await resp2.json();
                comps2 = Array.isArray(d2?.data) ? d2.data : [];
            }
            
            // Normalize both sets
            const normalize = (arr) => arr.map(c => ({
                question: c.question || c.template_name || 'ØºÙŠØ± Ù…ØªÙˆÙØ±',
                views: c.views_count ?? 0,
                reactions: c.reactions_count ?? 0,
                participants: c.participants_count ?? 0,
                sends: c.send_count ?? c.competitions_count ?? 0,
                type: (c.template_type ?? c.type) ?? 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯',
                answer: c.correct_answer ?? 'ØºÙŠØ± Ù…ØªÙˆÙØ±'
            }));
            comps1 = normalize(comps1);
            comps2 = normalize(comps2);
            
            // Build merged list: for each question in period1, find match in period2
            const merged = comps1.map(c1 => {
                const c2 = comps2.find(x => x.question === c1.question) || {views:0, reactions:0, participants:0, sends:0};
                return {
                    question: c1.question,
                    type: c1.type,
                    answer: c1.answer,
                    views1: c1.views,
                    views2: c2.views,
                    reactions1: c1.reactions,
                    reactions2: c2.reactions,
                    participants1: c1.participants,
                    participants2: c2.participants,
                    sends1: c1.sends,
                    sends2: c2.sends
                };
            });
            
            // Sort merged by chosen metric period1
            const metricKey = { views: 'views1', reactions: 'reactions1', participants: 'participants1', sends: 'sends1' }[sortBy] || 'views1';
            merged.sort((a, b) => b[metricKey] - a[metricKey]);
            
            if (merged.length === 0) {
                listEl.innerHTML = '<div class="empty-state"><i class="fas fa-inbox"></i><p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ§Ø­Ø© Ø¶Ù…Ù† Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©.</p></div>';
            } else {
                const typeLegacyMap = { general: 'Ù…Ù…ÙŠØ²Ø§Øª', trading: 'ØªÙØ§Ø¹Ù„ÙŠØ©', deposit: 'Ø¥ÙŠØ¯Ø§Ø¹' };
                const itemsHtml = merged.slice(0, limit).map((comp, idx) => {
                    const raw = (comp.type || '').toString().trim();
                    const isArabic = raw === 'Ù…Ù…ÙŠØ²Ø§Øª' || raw === 'ØªÙØ§Ø¹Ù„ÙŠØ©' || raw === 'Ø¥ÙŠØ¯Ø§Ø¹';
                    const displayType = isArabic ? raw : (typeLegacyMap[raw.toLowerCase()] || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯');
                    let badgeKey = 'unknown';
                    if (displayType === 'Ù…Ù…ÙŠØ²Ø§Øª') badgeKey = 'features';
                    else if (displayType === 'ØªÙØ§Ø¹Ù„ÙŠØ©') badgeKey = 'interactive';
                    else if (displayType === 'Ø¥ÙŠØ¯Ø§Ø¹') badgeKey = 'deposit';
                    
                    const vDiff = comp.views1 - comp.views2;
                    const rDiff = comp.reactions1 - comp.reactions2;
                    const pDiff = comp.participants1 - comp.participants2;
                    const sDiff = comp.sends1 - comp.sends2;
                    
                    const diffCls = (v) => v>0?'positive':v<0?'negative':'neutral';
                    const escapedQ = (comp.question || 'ØºÙŠØ± Ù…ØªÙˆÙØ±').replace(/\"/g,'&quot;');
                    
                    return `
                      <div class="interactive-item comparison-mode" data-index="${idx+1}">
                        <div class="item-rank"><span class="index-badge">${idx+1}</span></div>
                        <div class="item-main">
                          <div class="item-question question-cell" title="${escapedQ}" data-fulltext="${escapedQ}">
                            <i class="fas fa-question-circle"></i>
                            <span class="question-text">${comp.question}</span>
                            <span class="answer-badge">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©: ${comp.answer}</span>
                          </div>
                          <div class="item-meta comparison-meta">
                            <span class="type-badge ${badgeKey}">${displayType}</span>
                            <div class="metric-comparison">
                              <span class="metric-chip period1"><i class="fas fa-paper-plane"></i> ${comp.sends1.toLocaleString('ar-EG')}</span>
                              <span class="metric-chip period2">${comp.sends2.toLocaleString('ar-EG')}</span>
                              <span class="mini-diff ${diffCls(sDiff)}">${sDiff>=0?'+':''}${sDiff}</span>
                            </div>
                            <div class="metric-comparison">
                              <span class="metric-chip period1"><i class="fas fa-eye"></i> ${comp.views1.toLocaleString('ar-EG')}</span>
                              <span class="metric-chip period2">${comp.views2.toLocaleString('ar-EG')}</span>
                              <span class="mini-diff ${diffCls(vDiff)}">${vDiff>=0?'+':''}${vDiff}</span>
                            </div>
                            <div class="metric-comparison">
                              <span class="metric-chip period1"><i class="fas fa-bolt"></i> ${comp.reactions1.toLocaleString('ar-EG')}</span>
                              <span class="metric-chip period2">${comp.reactions2.toLocaleString('ar-EG')}</span>
                              <span class="mini-diff ${diffCls(rDiff)}">${rDiff>=0?'+':''}${rDiff}</span>
                            </div>
                            <div class="metric-comparison">
                              <span class="metric-chip period1"><i class="fas fa-users"></i> ${comp.participants1.toLocaleString('ar-EG')}</span>
                              <span class="metric-chip period2">${comp.participants2.toLocaleString('ar-EG')}</span>
                              <span class="mini-diff ${diffCls(pDiff)}">${pDiff>=0?'+':''}${pDiff}</span>
                            </div>
                          </div>
                        </div>
                      </div>
                    `;
                }).join('');
                listEl.innerHTML = itemsHtml;
            }
        }
    } catch(_){}
}

// Render most frequent competitions chart with comparison
function renderMostFrequentCompetitionsChartComparison(data1, data2) {
    const mostFrequentCompetitionsCanvas = document.getElementById('mostFrequentCompetitionsChart');
    const mostFrequentCompetitionsError = document.getElementById('mostFrequentCompetitionsError');
    if (!mostFrequentCompetitionsCanvas) return;
    if (mostFrequentCompetitionsChart) mostFrequentCompetitionsChart.destroy();

    if (!data1 || data1.length === 0) {
        showError(mostFrequentCompetitionsError, ARABIC_LABELS.noData, true);
        return;
    }

    // Combine templates from both periods
    const templates = new Set();
    data1.forEach(item => templates.add(item.template_name || item.competition_name || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'));
    data2?.forEach(item => templates.add(item.template_name || item.competition_name || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'));
    
    const labels = Array.from(templates);
    const counts1 = labels.map(label => {
        const item = data1.find(d => (d.template_name || d.competition_name) === label);
        return item ? item.count : 0;
    });
    const counts2 = labels.map(label => {
        const item = data2?.find(d => (d.template_name || d.competition_name) === label);
        return item ? item.count : 0;
    });

    mostFrequentCompetitionsChart = new Chart(mostFrequentCompetitionsCanvas, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰',
                    data: counts1,
                    backgroundColor: 'rgba(76, 175, 80, 0.6)',
                    borderColor: 'rgba(76, 175, 80, 1)',
                    borderWidth: 1
                },
                {
                    label: 'Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©',
                    data: counts2,
                    backgroundColor: 'rgba(33, 150, 243, 0.6)',
                    borderColor: 'rgba(33, 150, 243, 1)',
                    borderWidth: 1
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    position: 'top'
                },
                title: {
                    display: true,
                    text: 'Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ø£ÙƒØ«Ø± ØªÙƒØ±Ø§Ø±Ø§Ù‹',
                    font: { size: 16 }
                },
                datalabels: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: ARABIC_LABELS.count
                    }
                },
                x: {
                    title: {
                        display: true,
                        text: ARABIC_LABELS.competitionName
                    }
                }
            }
        },
        plugins: [ChartDataLabels]
    });
}

// Initializationfunction init() {
    // DOM Elements - moved inside init()
    const fromDateInput = document.getElementById('fromDate');
    const toDateInput = document.getElementById('toDate');
    const applyDateFilterBtn = document.getElementById('applyDateFilter');
    const clearDateFilterBtn = document.getElementById('clearDateFilter');
    const quickFiltersContainer = document.getElementById('quick-date-filters');

    // Comparison mode elements
    const comparisonModeToggle = document.getElementById('comparisonModeToggle');
    const normalFilters = document.getElementById('normalFilters');
    const comparisonFilters = document.getElementById('comparisonFilters');
    const quickComparisonButtons = document.querySelector('.quick-comparison-buttons');
    const applyComparisonBtn = document.getElementById('applyComparisonFilter');
    const clearComparisonBtn = document.getElementById('clearComparisonFilter');
    
    const period1FromInput = document.getElementById('period1From');
    const period1ToInput = document.getElementById('period1To');
    const period2FromInput = document.getElementById('period2From');
    const period2ToInput = document.getElementById('period2To');

    // Assign global canvas and error elements
    agentGrowthCanvas = document.getElementById('agentGrowthChart');
    agentClassificationCanvas = document.getElementById('agentClassificationChart');
    competitionPerformanceCanvas = document.getElementById('competitionPerformanceChart');
    // activityDistributionCanvas ØªÙ…Øª Ø¥Ø²Ø§Ù„ØªÙ‡ Ù…Ø¹ Ø§Ù„Ù‚Ø³Ù…

    agentGrowthError = document.getElementById('agentGrowthError');
    agentClassificationError = document.getElementById('agentClassificationError');
    competitionPerformanceError = document.getElementById('competitionPerformanceError');
    // activityDistributionError ØªÙ…Øª Ø¥Ø²Ø§Ù„ØªÙ‡ Ù…Ø¹ Ø§Ù„Ù‚Ø³Ù…

    // Initial load â€” default to last 30 days
    updateDashboard('30');

    // Toggle comparison mode
    if (comparisonModeToggle) {
        comparisonModeToggle.addEventListener('change', (e) => {
            isComparisonMode = e.target.checked;
            
            if (isComparisonMode) {
                normalFilters.style.display = 'none';
                comparisonFilters.style.display = 'flex';
                showToast('ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©', 'info');
            } else {
                normalFilters.style.display = 'flex';
                comparisonFilters.style.display = 'none';
                // Reset to normal view
                updateDashboard('30');
                showToast('ØªÙ… Ø¥Ù„ØºØ§Ø¡ ÙˆØ¶Ø¹ Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©', 'info');
            }
        });
    }

    // Quick comparison buttons
    if (quickComparisonButtons) {
        quickComparisonButtons.addEventListener('click', (e) => {
            const btn = e.target.closest('.comparison-btn');
            if (!btn) return;

            const comparisonType = btn.dataset.comparison;
            const periods = calculateComparisonPeriods(comparisonType);
            
            if (periods) {
                // Update UI
                document.querySelectorAll('.comparison-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Fetch comparison data
                fetchComparisonData(periods.period1, periods.period2);
            }
        });
    }

    // Apply custom comparison
    if (applyComparisonBtn) {
        applyComparisonBtn.addEventListener('click', () => {
            const period1From = period1FromInput?.value;
            const period1To = period1ToInput?.value;
            const period2From = period2FromInput?.value;
            const period2To = period2ToInput?.value;

            // Validation
            if (!period1From || !period1To || !period2From || !period2To) {
                showToast('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙˆØ§Ø±ÙŠØ®', 'warning');
                return;
            }

            if (new Date(period1From) > new Date(period1To)) {
                showToast('ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ù„Ù„ÙØªØ±Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‚Ø¨Ù„ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù†Ù‡Ø§ÙŠØ©', 'error');
                return;
            }

            if (new Date(period2From) > new Date(period2To)) {
                showToast('ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ù„Ù„ÙØªØ±Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ© ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‚Ø¨Ù„ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù†Ù‡Ø§ÙŠØ©', 'error');
                return;
            }

            // Clear active quick comparison buttons
            document.querySelectorAll('.comparison-btn').forEach(b => b.classList.remove('active'));

            // Fetch comparison data
            const period1 = { from: period1From, to: period1To };
            const period2 = { from: period2From, to: period2To };
            fetchComparisonData(period1, period2);
        });
    }

    // Clear comparison
    if (clearComparisonBtn) {
        clearComparisonBtn.addEventListener('click', () => {
            // Clear comparison inputs
            period1FromInput.value = '';
            period1ToInput.value = '';
            period2FromInput.value = '';
            period2ToInput.value = '';
            
            // Clear active quick comparison buttons
            document.querySelectorAll('.comparison-btn').forEach(b => b.classList.remove('active'));
            
            // Reset comparison data
            comparisonData = { period1: null, period2: null };
            
            // Clear date filter inputs
            if (fromDateInput) fromDateInput.value = '';
            if (toDateInput) toDateInput.value = '';
            
            // Reset to default 30 days and activate its button
            if (quickFiltersContainer) {
                quickFiltersContainer.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                quickFiltersContainer.querySelector('[data-range="30"]').classList.add('active');
            }
            
            // Reload dashboard with default data (30 days)
            updateDashboard('30');
            
            showToast('ØªÙ… Ù…Ø³Ø­ Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø© ÙˆØ§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ', 'info');
        });
    }

    // Apply date filter (from/to)
    if (applyDateFilterBtn) {
        applyDateFilterBtn.addEventListener('click', () => {
            const from = fromDateInput?.value || '';
            const to = toDateInput?.value || '';

            // Validation: Check if at least one date is provided
            if (!from && !to) {
                showToast('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± ØªØ§Ø±ÙŠØ® ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„', 'warning');
                return;
            }

            // Validation: Check if 'from' is before or equal to 'to'
            if (from && to && new Date(from) > new Date(to)) {
                showToast('ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‚Ø¨Ù„ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù†Ù‡Ø§ÙŠØ©', 'error');
                return;
            }

            // Deactivate quick filter buttons
            quickFiltersContainer.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));

            updateDashboard({ from, to });
            showToast('ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„ØªØ± Ø¨Ù†Ø¬Ø§Ø­', 'success');
        });
    }

    // Clear date filter
    if (clearDateFilterBtn) {
        clearDateFilterBtn.addEventListener('click', () => {
            fromDateInput.value = '';
            toDateInput.value = '';
            
            // Reset to default 30 days and activate its button
            quickFiltersContainer.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            quickFiltersContainer.querySelector('[data-range="30"]').classList.add('active');
            
            updateDashboard('30');
            showToast('ØªÙ… Ù…Ø³Ø­ Ø§Ù„ÙÙ„ØªØ±', 'info');
        });
    }

    // Quick date filters
    if (quickFiltersContainer) {
        quickFiltersContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('filter-btn')) {
                const range = e.target.dataset.range;
                
                // Clear custom date inputs
                fromDateInput.value = '';
                toDateInput.value = '';
                
                // Update active state
                quickFiltersContainer.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                
                updateDashboard(range);
            }
        });
    }
    
    // Competition filter buttons
    const competitionFilterButtons = document.querySelector('.competition-filter-buttons');
    if (competitionFilterButtons) {
        competitionFilterButtons.addEventListener('click', (e) => {
            const btn = e.target.closest('.competition-filter-btn');
            if (!btn) return;
            
            const filterType = btn.dataset.filter;
            
            // Update active state
            document.querySelectorAll('.competition-filter-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            // Filter competitions
            filterCompetitions(filterType);
        });
    }
    
    // Pagination buttons
    const prevPageBtn = document.getElementById('prevPage');
    const nextPageBtn = document.getElementById('nextPage');
    
    if (prevPageBtn) {
        prevPageBtn.addEventListener('click', () => {
            if (currentCompetitionsPage > 1) {
                currentCompetitionsPage--;
                renderCompletedCompetitionsTable(filteredCompetitionsData);
                // Scroll to table
                document.getElementById('completedCompetitionsCard').scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        });
    }
    
    if (nextPageBtn) {
        nextPageBtn.addEventListener('click', () => {
            const totalPages = Math.ceil(filteredCompetitionsData.length / competitionsPerPage);
            if (currentCompetitionsPage < totalPages) {
                currentCompetitionsPage++;
                renderCompletedCompetitionsTable(filteredCompetitionsData);
                // Scroll to table
                document.getElementById('completedCompetitionsCard').scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        });
    }

    // NEW: Ø¨Ø¹Ø¯ Ø§ÙƒØªÙ…Ø§Ù„ ØªÙ‡ÙŠØ¦Ø© ØµÙØ­Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§ØªØŒ Ø§Ø¬Ù„Ø¨ Ø£Ø¨Ø±Ø² Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ù„ÙƒÙ„ ØªØµÙ†ÙŠÙ
    fetchTopAgentsPerClassification();
    
    // NEW: Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ ÙˆØ§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª
    fetchAndRenderAgentsCompetitions();
    
    // NEW: Ø¥Ø¶Ø§ÙØ© event listeners Ù„ÙÙ„ØªØ±Ø© Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø­Ø³Ø¨ Ø§Ù„ØªØµÙ†ÙŠÙ
    const agentsCompetitionsFilterButtons = document.querySelectorAll('#agentsCompetitionsCard .competition-filter-btn');
    if (agentsCompetitionsFilterButtons.length > 0) {
        agentsCompetitionsFilterButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                // Update active state
                agentsCompetitionsFilterButtons.forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                
                const filterType = e.target.dataset.filter;
                fetchAndRenderAgentsCompetitions(filterType);
            });
        });
    }

    // ============================================
    // ÙÙ„Ø§ØªØ± Ø§Ù„ØªØ§Ø±ÙŠØ® Ù„ÙƒÙ„ Ù‚Ø³Ù… Ù…Ù† Ø§Ù„Ø£Ù‚Ø³Ø§Ù…
    // ============================================

    // 1. ÙÙ„ØªØ± ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©
    setupSectionDateFilter(
        'completedCompetitions',
        () => {
            const filter = getSectionDateFilter('completedCompetitions');
            fetchAnalyticsData(filter).then(data => {
                if (data && data.completed_competitions) {
                    allCompetitionsData = data.completed_competitions;
                    filteredCompetitionsData = [...allCompetitionsData];
                    // Ø¥Ø¹Ø§Ø¯Ø© ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„ØªØ± Ø§Ù„Ù†Ø´Ø·
                    const activeFilter = document.querySelector('#completedCompetitionsCard .competition-filter-btn.active');
                    const filterType = activeFilter ? activeFilter.dataset.filter : 'all';
                    filterCompetitions(filterType);
                }
            });
        }
    );

    // 2. ÙÙ„ØªØ± Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ø±Ø³Ù„Ø© / ÙŠÙˆÙ…
    setupSectionDateFilter(
        'agentGrowth',
        () => {
            const filter = getSectionDateFilter('agentGrowth');
            fetchAnalyticsData(filter).then(data => {
                if (data) {
                    renderCompetitionsByDayChart(data.competitions_by_day);
                }
            });
        }
    );

    // 3. ÙÙ„ØªØ± Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø§Ù„Ù…Ù…Ù†ÙˆØ­Ø©
    setupSectionDateFilter(
        'grantedBalances',
        () => {
            const filter = getSectionDateFilter('grantedBalances');
            fetchAnalyticsData(filter).then(data => {
                if (data) {
                    renderGrantedBalances(data.granted_balances);
                }
            });
        }
    );

    // 4. ÙÙ„ØªØ± Ø§Ù„ØªÙ…ÙŠØ² Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠ
    setupSectionDateFilter(
        'weeklyExcellence',
        () => {
            const filter = getSectionDateFilter('weeklyExcellence');
            fetchAnalyticsData(filter).then(data => {
                if (data) {
                    renderWeeklyExcellence(data.weekly_excellence);
                }
            });
        }
    );

    // 5. ÙÙ„ØªØ± ØªØºÙŠÙŠØ±Ø§Øª Ù…Ø±Ø§ØªØ¨ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡
    setupSectionDateFilter(
        'rankChanges',
        () => {
            const filter = getSectionDateFilter('rankChanges');
            fetchAndRenderRankChanges(filter);
        }
    );

    // 6. ÙÙ„ØªØ± Ø£ÙƒØ«Ø± Ù…Ø³Ø§Ø¨Ù‚Ø§Øª ØªÙØ§Ø¹Ù„Ø§Ù‹
    setupSectionDateFilter(
        'mostInteractive',
        () => {
            fetchAndRenderMostInteractiveCompetitions();
        }
    );

    // 7. ÙÙ„ØªØ± Ø£Ø¨Ø±Ø² Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ù„ÙƒÙ„ ØªØµÙ†ÙŠÙ
    setupSectionDateFilter(
        'topAgents',
        () => {
            fetchTopAgentsPerClassification();
        }
    );

    // 8. ÙÙ„ØªØ± Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ ÙˆØ§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ø±Ø³Ù„Ø©
    setupSectionDateFilter(
        'agentsCompetitions',
        () => {
            const filterBtn = document.querySelector('#agentsCompetitionsCard .competition-filter-btn.active');
            const classification = filterBtn ? filterBtn.dataset.filter : 'all';
            fetchAndRenderAgentsCompetitions(classification);
        }
    );
}

// --- Ø¯Ø§Ù„Ø© Ø¬Ù„Ø¨ ÙˆØ¹Ø±Ø¶ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ ÙˆØ§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª ---
const fetchAndRenderAgentsCompetitions = (classification = 'all') => {
    (async () => {
    const tableBody = document.getElementById('agentsCompetitionsTableBody');
    const errorEl = document.getElementById('agentsCompetitionsError');
    
    if (!tableBody) return;
    
    // Ø¹Ø±Ø¶ Ø­Ø§Ù„Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
    tableBody.innerHTML = `
        <tr class="loading-row">
            <td colspan="9">
                <div class="loading-spinner active"></div>
                <p>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ ÙˆØ§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª...</p>
            </td>
        </tr>
    `;
    if (errorEl) errorEl.textContent = '';
    
    try {
        // Ø¨Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… - Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙ„ØªØ± Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø®Ø§Øµ
        let query = '';
        const fromDateInput = document.getElementById('agentsCompetitionsFromDate');
        const toDateInput = document.getElementById('agentsCompetitionsToDate');
        const fromVal = fromDateInput?.value;
        const toVal = toDateInput?.value;
        
        if (fromVal && toVal) {
            query += `from=${fromVal}&to=${toVal}`;
        } else {
            query += 'range=30';
        }
        
        if (classification && classification !== 'all') {
            query += `&classification=${classification}`;
        }
        
        // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† API
        const res = await fetchWithAuth(`/api/stats/agents-competitions?${query}`);
        if (!res.ok) {
            throw new Error('ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ ÙˆØ§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª');
        }
        
        const data = await res.json();
        const agents = data.agents || [];
        const stats = data.aggregated_stats || {};
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø¬Ù…Ø¹Ø©
        updateAgentsCompetitionsStats(stats);
        
        // Ø¹Ø±Ø¶ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ ÙÙŠ Ø§Ù„Ø¬Ø¯ÙˆÙ„
        if (agents.length === 0) {
            tableBody.innerHTML = `
                <tr>
                    <td colspan="9" style="text-align: center; padding: 40px;">
                        <i class="fas fa-inbox" style="font-size: 48px; color: var(--text-secondary-color); margin-bottom: 16px;"></i>
                        <p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ§Ø­Ø© Ù„Ù„ÙØªØ±Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©</p>
                    </td>
                </tr>
            `;
            return;
        }
        
        const rowsHtml = agents.map((item, index) => {
            const agent = item.agent;
            const latestComp = item.latest_competition;
            const stats = item.statistics;
            
            if (!latestComp) return '';
            
            // Ø§Ø®ØªØµØ§Ø± Ø§Ù„Ø³Ø¤Ø§Ù„ - Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø§Ø³Ù… (Ø§Ù„Ø³Ø¤Ø§Ù„) Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„ÙˆØµÙ (Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø§Ù„ÙƒØ§Ù…Ù„)
            const questionText = latestComp.name || latestComp.description || 'ØºÙŠØ± Ù…ØªÙˆÙØ±';
            const shortQuestion = questionText.length > 50 
                ? questionText.substring(0, 50) + '...' 
                : questionText;
            
            // ØªØ­Ø¯ÙŠØ¯ Ù„ÙˆÙ† Ù†Ø³Ø¨Ø© Ø§Ù„Ø§Ù„ØªØ²Ø§Ù…
            let complianceColor = '#e74c3c'; // Ø£Ø­Ù…Ø±
            if (stats.compliance_rate >= 80) complianceColor = '#27ae60'; // Ø£Ø®Ø¶Ø±
            else if (stats.compliance_rate >= 50) complianceColor = '#f39c12'; // Ø¨Ø±ØªÙ‚Ø§Ù„ÙŠ
            
            // ØªØ­Ø¯ÙŠØ¯ Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§Ù„ØªØµÙ†ÙŠÙ
            const classIcons = {
                'R': 'fa-crown',
                'A': 'fa-star',
                'B': 'fa-certificate',
                'C': 'fa-medal'
            };
            const classIcon = classIcons[agent.classification] || 'fa-tag';
            
            return `
                <tr class="agent-row" data-agent-id="${agent._id}">
                    <td>${index + 1}</td>
                    <td>
                        <div class="agent-info" style="display: flex; align-items: center; gap: 10px;">
                            ${agent.avatar_url 
                                ? `<img src="${agent.avatar_url}" alt="${agent.name}" class="agent-avatar" style="width: 32px; height: 32px; border-radius: 50%; object-fit: cover;">` 
                                : '<div class="agent-avatar-placeholder" style="width: 32px; height: 32px; border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px;">' + agent.name.charAt(0) + '</div>'
                            }
                            <a href="/pages/agent-competitions.html?agent_id=${agent._id}" class="agent-name-link" style="color: var(--primary-color); text-decoration: none; font-weight: 600;">
                                ${agent.name}
                            </a>
                        </div>
                    </td>
                    <td><span class="agent-id-badge">${agent.agent_id}</span></td>
                    <td>
                        <div class="question-cell question-clickable" title="${questionText}" data-question="${questionText.replace(/"/g, '&quot;')}" style="cursor: pointer; color: var(--primary-color);">
                            ${shortQuestion}
                        </div>
                    </td>
                    <td>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div class="compliance-bar" style="flex: 1; height: 8px; background: #2c3e50; border-radius: 4px; overflow: hidden;">
                                <div style="width: ${stats.compliance_rate}%; height: 100%; background: ${complianceColor}; transition: width 0.3s;"></div>
                            </div>
                            <span style="font-weight: 600; color: ${complianceColor};">${stats.compliance_rate}%</span>
                        </div>
                    </td>
                    <td><span class="stat-number">${(latestComp.views_count || 0).toLocaleString('ar-EG')}</span></td>
                    <td><span class="stat-number">${(latestComp.reactions_count || 0).toLocaleString('ar-EG')}</span></td>
                    <td><span class="stat-number">${(latestComp.participants_count || 0).toLocaleString('ar-EG')}</span></td>
                    <td><span class="classification-badge class-${agent.classification}"><i class="fas ${classIcon}"></i> ${agent.classification}</span></td>
                </tr>
            `;
        }).filter(row => row !== '').join('');
        
        tableBody.innerHTML = rowsHtml;
        
        // Ø¥Ø¶Ø§ÙØ© event listeners Ù„Ù„Ø£Ø³Ø¦Ù„Ø© Ù„ÙØªØ­ modal
        const questionCells = tableBody.querySelectorAll('.question-clickable');
        questionCells.forEach(cell => {
            cell.addEventListener('click', (e) => {
                const questionText = e.target.dataset.question || e.target.getAttribute('title') || 'ØºÙŠØ± Ù…ØªÙˆÙØ±';
                showQuestionModal(questionText);
            });
        });
        
    } catch (error) {
        console.error('Error fetching agents competitions:', error);
        if (errorEl) {
            errorEl.textContent = 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.';
        }
        tableBody.innerHTML = `
            <tr>
                <td colspan="9" style="text-align: center; padding: 40px; color: var(--error-color);">
                    <i class="fas fa-exclamation-triangle" style="font-size: 48px; margin-bottom: 16px;"></i>
                    <p>Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</p>
                </td>
            </tr>
        `;
    }
        
    })();
}

// --- Ø¯Ø§Ù„Ø© ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø¬Ù…Ø¹Ø© ---
function updateAgentsCompetitionsStats(stats) {
    const totalAgentsEl = document.getElementById('totalAgentsWithCompetitions');
    const totalCompetitionsEl = document.getElementById('totalAgentCompetitions');
    const totalViewsEl = document.getElementById('totalAgentViews');
    const totalReactionsEl = document.getElementById('totalAgentReactions');
    const totalParticipantsEl = document.getElementById('totalAgentParticipants');
    const averageComplianceEl = document.getElementById('averageCompliance');
    
    if (totalAgentsEl) totalAgentsEl.textContent = (stats.total_agents || 0).toLocaleString('ar-EG');
    if (totalCompetitionsEl) totalCompetitionsEl.textContent = (stats.total_competitions || 0).toLocaleString('ar-EG');
    if (totalViewsEl) totalViewsEl.textContent = (stats.total_views || 0).toLocaleString('ar-EG');
    if (totalReactionsEl) totalReactionsEl.textContent = (stats.total_reactions || 0).toLocaleString('ar-EG');
    if (totalParticipantsEl) totalParticipantsEl.textContent = (stats.total_participants || 0).toLocaleString('ar-EG');
    if (averageComplianceEl) averageComplianceEl.textContent = `${stats.average_compliance_rate || 0}%`;
}

// ============================================
// Delete Single Rank Change
// ============================================
async function handleDeleteRankChange(changeId, currentFilter) {
    if (!confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„ØªØºÙŠÙŠØ±ØŸ\n\nÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡.')) {
        return;
    }

    try {
        const response = await fetchWithAuth(`/api/stats/rank-changes/${changeId}`, {
            method: 'DELETE',
        });

        const data = await response.json();

        if (response.ok) {
            showToast(data.message || 'ØªÙ… Ø­Ø°Ù Ø§Ù„ØªØºÙŠÙŠØ± Ø¨Ù†Ø¬Ø§Ø­', 'success');
            // Reload the table with current filter
            await fetchAndRenderRankChanges(currentFilter);
        } else {
            showToast(data.message || 'ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„ØªØºÙŠÙŠØ±', 'error');
        }
    } catch (error) {
        console.error('Error deleting rank change:', error);
        showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„ØªØºÙŠÙŠØ±', 'error');
    }
}

// ============================================
// Purge Rank Changes (Super Admin Only)
// ============================================
let rankChangesPurgeInitialized = false;

async function initRankChangesPurgeButton() {
    if (rankChangesPurgeInitialized) return; // Prevent multiple initializations
    
    const purgeBtn = document.getElementById('purgeRankChangesBtn');
    if (!purgeBtn) return;

    // Check user role
    const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
    const isSuperAdmin = currentUser.role === 'super_admin';

    if (isSuperAdmin) {
        purgeBtn.style.display = 'inline-block';
        purgeBtn.addEventListener('click', handlePurgeRankChanges);
        rankChangesPurgeInitialized = true;
    }
}

async function handlePurgeRankChanges() {
    if (!confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ù…Ø±Ø§ØªØ¨ ÙˆØ§Ù„ØªØµÙ†ÙŠÙØ§ØªØŸ Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡!')) {
        return;
    }

        try {
            const response = await fetchWithAuth('/api/stats/rank-changes', {
                method: 'DELETE',
            });        const data = await response.json();

        if (response.ok) {
            showToast(data.message || 'ØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ù…Ø±Ø§ØªØ¨ Ø¨Ù†Ø¬Ø§Ø­', 'success');
            // Reload rank changes section
            fetchAndRenderRankChanges();
        } else {
            showToast(data.message || 'ÙØ´Ù„ Ø­Ø°Ù ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ù…Ø±Ø§ØªØ¨', 'error');
        }
    } catch (error) {
        console.error('Error purging rank changes:', error);
        showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ù…Ø±Ø§ØªØ¨', 'error');
    }
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', initRankChangesPurgeButton);

// --- Ø¯Ø§Ù„Ø© Ø¹Ø±Ø¶ modal Ù„Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„ÙƒØ§Ù…Ù„ ---




// == winner-roulette.js ==
ï»¿// == winner-roulette.js ==
// winner-roulette.js
// Module to manage a roulette wheel for selecting winners

(function() {
'use strict';

// Ensure the modern winner modal with email field exists (handles legacy cached HTML without the input)
    function ensureWinnerModalStructure(){
      // [ensureWinnerModalStructure] START
      
      // FORCE RECREATE: Always remove and rebuild modal to ensure latest structure
      const oldModal = document.getElementById('winner-modal');
      if(oldModal){
        // Removing old modal if exists
        oldModal.remove();
      } else {
        // No old modal found
      }
      
      // Create fresh modal every time
      // Creating fresh modal
      const modal = document.createElement('div');
      modal.id='winner-modal';
      modal.className='wr-celebration-modal';
      modal.style.display='none';
      modal.innerHTML = `
        <div class="wr-celebration-content" role="dialog" aria-modal="true" style="width: 100%; max-width: 600px; padding: 2rem; box-sizing: border-box;">
          <h2 class="wr-celebration-title" style="font-size: 2rem; margin-bottom: 1rem;">Ù…Ø¨Ø±ÙˆÙƒ Ø§Ù„ÙÙˆØ²!</h2>
          <div class="wr-winner-card" style="margin-bottom: 1.5rem; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 12px;">
              <div class="wr-winner-name" id="celebration-winner-name" style="font-size: 1.5rem; font-weight: bold; color: #fff;">â€”</div>
              <div class="wr-winner-account" id="celebration-winner-account" style="color: #ccc;">â€”</div>
          </div>
          
          <div class="wr-form-group" style="text-align: right; margin-bottom: 1rem; position: relative; z-index: 10;">
              <label for="winner-email" class="wr-label" style="display: block; margin-bottom: 0.5rem; color: #ddd;">
                  <i class="fas fa-envelope"></i> Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
              </label>
              <input type="email" id="winner-email" class="wr-form-input" placeholder="example@email.com" autocomplete="email" tabindex="0" style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #444; background: #222; color: #fff; position: relative; z-index: 10;" />
              <div id="winner-email-error" class="wr-error-msg" style="display:none;color:#f87171;font-size:.75rem;margin-top:4px;">Ø§Ù„Ø¨Ø±ÙŠØ¯ ØºÙŠØ± ØµØ§Ù„Ø­</div>
            </div>
  
            <div class="wr-form-group" style="text-align: right; margin-bottom: 1rem; position: relative; z-index: 10;">
              <label for="winner-id-image" class="wr-label" style="display: block; margin-bottom: 0.5rem; color: #ddd;">
                <i class="fas fa-image"></i> ØµÙˆØ±Ø© Ø§Ù„Ù‡ÙˆÙŠØ©
              </label>
              <input type="file" id="winner-id-image" accept="image/*" class="wr-form-input" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #444; background: #222; color: #fff;" />
              <div style="color:#9ca3af; font-size:.8rem; margin-top:6px;">ÙŠÙ…ÙƒÙ†Ùƒ Ù„ØµÙ‚ Ø§Ù„ØµÙˆØ±Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ctrl+V</div>
              <img id="winner-id-image-preview" alt="Ù…Ø¹Ø§ÙŠÙ†Ø© ØµÙˆØ±Ø© Ø§Ù„Ù‡ÙˆÙŠØ©" style="display:none; margin-top:8px; max-width:100%; max-height:80px; border-radius:8px; border:1px solid #444; background:#111; object-fit: contain; cursor: zoom-in;" />
          </div>
  
          <div class="wr-form-group" style="text-align: right; margin-bottom: 1rem; position: relative; z-index: 10;">
              <label class="wr-label" style="display: block; margin-bottom: 0.5rem; color: #ddd;">
                  <i class="fas fa-gift"></i> Ù†ÙˆØ¹ Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©
              </label>
              <select id="winner-prize-type" class="wr-form-input" style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #444; background: #222; color: #fff;">
                  <option value="trading">Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ</option>
                <option value="deposit">Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹</option>
                <option value="deposit_prev">Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹ ÙƒÙˆÙ†Ù‡ ÙØ§Ø¦Ø² Ù…Ø³Ø¨Ù‚Ø§Ù‹ Ø¨Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ</option>
              </select>
          </div>
  
          <div class="wr-form-group" style="text-align: right; margin-bottom: 1.5rem; position: relative; z-index: 10;">
              <label class="wr-label" style="display: block; margin-bottom: 0.5rem; color: #ddd;">
                  <i class="fas fa-dollar-sign"></i> Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©
              </label>
              <div id="winner-prize-auto-display" style="display:block; padding: 12px; border-radius: 8px; border: 1px solid #10b981; background: rgba(16, 185, 129, 0.1); color: #10b981; font-weight: bold; text-align: center;">
                  --
              </div>
          </div>
  
          <div style="display: flex; gap: 10px;">
              <button id="confirm-winner" class="wr-confirm-btn" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #2563eb, #1d4ed8); color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; position: relative; z-index: 10;">
                  <i class="fas fa-check-circle"></i> ØªØ¬Ù‡ÙŠØ² ÙØ§Ø¦Ø²
              </button>
              <button id="skip-winner" class="wr-skip-btn" style="flex: 1; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; position: relative; z-index: 10;">
                  <i class="fas fa-redo"></i> ØªØ®Ø·ÙŠ
              </button>
          </div>
        </div>`;
      document.body.appendChild(modal);
      
      // Modal created and structure verified
      
      const contentBox = modal.querySelector('.wr-celebration-content');
      if (contentBox) {
        // Content box styles can be adjusted here if needed
      }
      
      // [ensureWinnerModalStructure] END
    }
    
    let state = {
      entries: [], // { id, name, account, label, selected }
      winners: [],
      spinning: false,
      angle: 0,
      targetAngle: 0,
      spinStart: 0,
      spinDuration: 0,
      excludeWinner: true,
      spinQueue: 0,
      spinSnapshot: null, // snapshot of candidates used during a spin
      chosenIndex: null, // index within snapshot chosen at spin start
      startAngle: 0,
      autoMode: false,
      autoRemaining: 0,
      autoBatchPicked: [],
      selectedAgent: null, // Store selected agent info
      activeCompetition: null, // Store active competition info
      logoImage: null, // Store logo image for wheel center
      pulseTime: 0, // For animated background pulse effect
      isAnimating: false, // Control animation loop
      showLogoHint: true, // whether to show the 'Ø§Ø¶ØºØ· Ù‡Ù†Ø§' hint over the logo
      lastPickedIndex: -1, // Track last picked index for sequential selection
      reportSent: false, // Winners report sent to agent flag
      includeWarnMeet: false,
      includeWarnPrev: false
    };
    
    const LS_KEY = 'winnerRouletteSession.v1';
    const STAGED_WINNERS_KEY = 'winnerRouletteStagedWinners.v1';
    // Persist session across reloads
    
    function cleanName(name) {
      if (!name) return '';
      // Remove sequential numbers like "1- ", "2- ", etc. from the beginning
      return name.replace(/^\d+\s*-\s*/, '').trim();
    }
    
    function truncateText(str, max) {
      if (!str) return '';
      return str.length > max ? str.slice(0, Math.max(0, max - 1)) + 'â€¦' : str;
    }
    
    function getWheelDisplayName(name, n) {
      // Return full name without truncation
      return cleanName(name || '');
    }
    
    async function loadAgents() {
      const select = document.getElementById('agent-select');
      if (!select) return;
      try {
        const authedFetch = window.authedFetch || fetch;
        const response = await authedFetch('/api/agents?limit=1000');
        const result = await response.json();
        const agents = result.data || [];
        
        agents.forEach(agent => {
          const option = document.createElement('option');
          option.value = agent._id;
          option.textContent = `${agent.name} (#${agent.agent_id})`;
          option.dataset.agentId = agent.agent_id;
          select.appendChild(option);
        });
        
        // Don't restore selected agent - always start with default "-- Ø§Ø®ØªØ± Ø§Ù„ÙˆÙƒÙŠÙ„ --"
        // User must select agent explicitly each time
      } catch(e) {
        console.warn('Failed to load agents:', e);
      }
    }
    
    function updateAgentStatus(name, agentId) {
      const status = document.getElementById('agent-selection-status');
      if (!status) return;
      if (name && agentId) {
        status.textContent = `${name} (#${agentId})`;
        status.className = 'wr-agent-status selected';
      } else {
        status.textContent = '';
        status.className = 'wr-agent-status';
      }
    }
    
    async function loadAgentCompetitionInfo(agentId) {
      const infoBox = document.getElementById('agent-info-box');
      const nameEl = document.getElementById('agent-info-name');
      const idEl = document.getElementById('agent-info-id');
      const competitionInfo = document.getElementById('agent-competition-info');
      
      if (!infoBox || !state.selectedAgent) return;
      
      // Show box and populate agent basic info
      infoBox.style.display = 'block';
      nameEl.textContent = state.selectedAgent.name || 'â€”';
      idEl.textContent = state.selectedAgent.agentId || 'â€”';
      
      // Clear active competition before loading new one
      state.activeCompetition = null;
      // restoreSession(true); // Clear UI while loading - REMOVED to prevent loading stale entries

      // Show loading state
      competitionInfo.innerHTML = '<div class="wr-agent-info-empty"><i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...</div>';

      // Render the competitions dropdown AND auto-load the default competition
      await renderAgentCompetitionsDropdown(agentId);
    }

    async function renderAgentCompetitionsDropdown(agentId) {
      // Target the agent selector container in the header
      const agentSelector = document.querySelector('.wr-agent-selector');
      if (!agentSelector) {
          console.warn('Agent selector container not found');
          return;
      }

      // Check if dropdown container exists
      let dropdownContainer = document.getElementById('agent-competitions-dropdown-container');
      if (!dropdownContainer) {
        dropdownContainer = document.createElement('div');
        dropdownContainer.id = 'agent-competitions-dropdown-container';
        dropdownContainer.className = 'wr-competitions-selector';
        dropdownContainer.style.display = 'inline-flex';
        dropdownContainer.style.alignItems = 'center';
        dropdownContainer.style.gap = '10px';
        dropdownContainer.style.marginLeft = '20px';
        
        dropdownContainer.innerHTML = `
            <label for="agent-competitions-select" style="font-weight:600; color:var(--wr-text-primary); display:flex; align-items:center; gap:6px;">
                <i class="fas fa-history" style="color:var(--wr-primary);"></i>
                Ø³Ø¬Ù„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª:
            </label>
            <select id="agent-competitions-select" class="wr-agent-dropdown" style="min-width: 250px;">
                <option value="">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...</option>
            </select>
        `;
        // Append to the agent selector container
        agentSelector.appendChild(dropdownContainer);
      }

      try {
        const authedFetch = window.authedFetch || fetch;
        // console.log(`Fetching competitions for agent: ${agentId}`);
        // Ensure agentId is passed correctly as query param (backend expects 'agentId', not 'agent_id')
        const response = await authedFetch(`/api/competitions?agentId=${agentId}&sort=-createdAt&limit=100`);
        
        if (response.ok) {
            const data = await response.json();
            // console.log('Competitions data:', data);
            // Support both formats (data.competitions or data.data)
            const competitions = data.competitions || data.data || [];
            
            // --- DEBUG LOGS ---
            // console.log(`[DEBUG] Found ${competitions.length} competitions for agent ${agentId}`);
            // console.log('[DEBUG] All competition statuses:', competitions.map(c => c.status));
            // ------------------

            const select = document.getElementById('agent-competitions-select');
            
            if (competitions.length === 0) {
                // console.log('[DEBUG] No competitions found, showing empty message.');
                select.innerHTML = '<option value="">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„</option>';
                return;
            }

            const activeCompetitions = competitions.filter(c => ['active', 'awaiting_winners', 'sent'].includes(c.status));
            // const endedCompetitions = competitions.filter(c => ['completed', 'archived'].includes(c.status)); // Hidden as per request

            // console.log(`[DEBUG] Active count: ${activeCompetitions.length}`);
            // console.log(`[DEBUG] Ended count: ${endedCompetitions.length}`);

            // Determine default selection (Latest Active only)
            let defaultCompId = null;
            if (activeCompetitions.length > 0) {
                defaultCompId = activeCompetitions[0]._id;
            }

            const renderOption = (c) => {
                const date = new Date(c.createdAt).toLocaleDateString('ar-EG');
                const statusMap = {
                    'active': 'Ù†Ø´Ø·Ø©',
                    'completed': 'Ù…ÙƒØªÙ…Ù„Ø©',
                    'sent': 'Ø¬Ø¯ÙŠØ¯Ø©',
                    'awaiting_winners': 'Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†',
                    'archived': 'Ù…Ø¤Ø±Ø´ÙØ©'
                };
                const status = statusMap[c.status] || c.status;
                // Select if it matches active competition OR if it's the default and no active competition is set
                const isSelected = (state.activeCompetition && state.activeCompetition.id === c._id) || 
                                   (!state.activeCompetition && c._id === defaultCompId);
                return `<option value="${c._id}" ${isSelected ? 'selected' : ''}>
                    ${c.name || 'Ù…Ø³Ø§Ø¨Ù‚Ø©'} (${date}) - ${status}
                </option>`;
            };

            const renderAllOptions = () => {
                let html = '<option value="">-- Ø§Ø®ØªØ± Ù…Ø³Ø§Ø¨Ù‚Ø© --</option>';

                if (activeCompetitions.length > 0) {
                    // No optgroup needed if only showing active, but keeping structure is fine or just listing them
                    html += activeCompetitions.map(renderOption).join('');
                } else {
                    html += '<option value="" disabled>Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ù†Ø´Ø·Ø©</option>';
                }

                return html;
            };
            
            select.innerHTML = renderAllOptions();

            // Remove old listener
            const newSelect = select.cloneNode(true);
            select.parentNode.replaceChild(newSelect, select);
            
            newSelect.addEventListener('change', async (e) => {
                const compId = e.target.value;
                if (compId) {
                    await loadCompetitionById(compId);
                }
            });
            
            // Store render function to update selection later
            state.renderCompetitionsDropdown = () => {
                const s = document.getElementById('agent-competitions-select');
                if(s) s.innerHTML = renderAllOptions();
            };

            // Auto-load default competition if none is active
            if (defaultCompId && !state.activeCompetition) {
                // console.log(`[DEBUG] Auto-loading default competition: ${defaultCompId}`);
                await loadCompetitionById(defaultCompId);
            } else if (!defaultCompId) {
                 const competitionInfo = document.getElementById('agent-competition-info');
                 if(competitionInfo) competitionInfo.innerHTML = '<div class="wr-agent-info-empty">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ù†Ø´Ø·Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„</div>';
            }

        } else {
            console.error('Failed to fetch competitions:', response.status);
        }
      } catch (e) {
        console.error('Failed to load agent competitions list', e);
      }
    }

    async function loadCompetitionById(compId) {
        const competitionInfo = document.getElementById('agent-competition-info');
        competitionInfo.innerHTML = '<div class="wr-agent-info-empty"><i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...</div>';
        
        // Clear current state
        const previousCompetitionId = state.activeCompetition ? state.activeCompetition.id : null;
        state.activeCompetition = null;
        
        try {
            const authedFetch = window.authedFetch || fetch;
            
            // 1. Fetch Competition Details
            const response = await authedFetch(`/api/competitions/${compId}`);
            if (response.ok) {
                const data = await response.json();
                const competition = data.competition;

                // 2. Fetch Winners for this competition
                const winnersResponse = await authedFetch(`/api/agents/${state.selectedAgent.id}/winners?competition_id=${compId}`);
                let winners = [];
                if (winnersResponse.ok) {
                    const winnersData = await winnersResponse.json();
                    if (winnersData.competitions && winnersData.competitions.length > 0) {
                        winners = winnersData.competitions[0].winners || [];
                    }
                }

                // Set reportSent state based on competition status
                if (competition.status === 'completed' || competition.status === 'archived') {
                    state.reportSent = true;
                    // If there are no winners but status is completed, it means "No Winners" was approved
                    if (winners.length === 0) {
                        state.noWinnersApproved = true;
                    }
                } else {
                    state.reportSent = false;
                    state.noWinnersApproved = false;
                }

                // Map backend winners to frontend state.winners format
                let mappedWinners = winners.map(w => ({
                    id: w.id,
                    name: w.name,
                    account: w.account_number,
                    email: w.email,
                    prizeType: w.prize_type === 'deposit_prev' ? 'deposit_prev' : (w.prize_type === 'deposit' ? 'deposit' : (w.prize_type === 'trading' ? 'trading' : 'deposit')),
                    prizeValue: w.prize_value,
                    videoUrl: w.video_url,
                    nationalIdImage: w.national_id_image,
                    selected: true,
                    _id: w.id // Ensure _id is set for DB winners
                }));

                // --- NEW: Merge with staged winners (local edits) ---
                const staged = getStagedWinnersForCompetition(compId);
                if (staged.length > 0) {
                    // 1. Update existing DB winners with staged changes
                    mappedWinners = mappedWinners.map(w => {
                        const stagedW = staged.find(s => s.id === w.id);
                        if (stagedW) {
                            // Merge staged properties. Staged takes precedence.
                            return { ...w, ...stagedW };
                        }
                        return w;
                    });

                    // 2. Add new staged winners that are NOT in DB
                    const newStagedWinners = staged.filter(s => {
                        // Check by ID
                        if (mappedWinners.find(mw => mw.id === s.id)) return false;
                        
                        // Check by Name + Account (to prevent duplicates if ID update failed)
                        if (mappedWinners.find(mw => mw.name === s.name && mw.account === s.account)) return false;
                        
                        return true;
                    });
                    if (newStagedWinners.length > 0) {
                        mappedWinners = [...mappedWinners, ...newStagedWinners];
                    }
                }

                // --- FIX: Merge with local session winners if they belong to this competition ---
                // If we have local winners in state (restored from session) and they are NOT in the DB list,
                // and the DB list is empty (or we are in active state), we should probably keep the local ones.
                // However, to be safe, let's check if the local winners match the current competition ID.
                // Since local winners don't store competition ID explicitly in the array, we rely on the fact
                // that restoreSession runs before this.
                
                // If DB returns winners, they are the source of truth.
                // If DB returns NO winners, but we have local winners, we should keep them IF the competition status allows.
                
                if (mappedWinners.length > 0) {
                    state.winners = mappedWinners;
                } else {
                    // DB has no winners. Check if we have local winners restored from session.
                    // We only keep them if we are NOT switching to a different competition.
                    // If previousCompetitionId is null (first load) or same as current, we might keep them.
                    // But wait, loadCompetitionById is called when switching dropdowns too.
                    
                    // Better approach: Check if the restored session's activeCompetitionId matches this compId.
                    // We need to access the raw session data or store activeCompetitionId in state during restore.
                    
                    const key = getSessionKey();
                    let sessionCompId = null;
                    try {
                        const raw = localStorage.getItem(key);
                        if (raw) {
                            const saved = JSON.parse(raw);
                            // We need to check if the saved session was for THIS competition
                            // But the saved object structure in saveSession uses 'activeCompetitionId'
                            // Let's check if we can retrieve it.
                            // Note: saveSession saves: activeCompetitionId: state.activeCompetition ? state.activeCompetition.id : null
                            sessionCompId = saved.activeCompetitionId;
                        }
                    } catch(e) {}

                    if (sessionCompId === compId && state.winners.length > 0) {
                        console.log('[loadCompetitionById] Keeping local winners from session for this competition.');
                        // Keep state.winners as is (restored from session)
                    } else {
                        state.winners = [];
                    }
                }
                
                // state.entries = []; // Clear entries as we are loading a specific state -> REMOVED to allow restoring entries from session if needed
                // Actually, if we switch competitions, we probably want to clear entries unless they are generic.
                // But if we are reloading the page, we want to keep entries.
                
                // Re-declare sessionCompId here because it's block-scoped above
                let currentSessionCompId = null;
                try {
                    const key = getSessionKey();
                    const raw = localStorage.getItem(key);
                    if (raw) currentSessionCompId = JSON.parse(raw).activeCompetitionId;
                } catch(e) {}

                if (currentSessionCompId !== compId) {
                     state.entries = [];
                     // Clear input field to avoid showing previous participants
                     const ta = document.getElementById('participants-input');
                     if (ta) ta.value = '';
                }

                // Render without restoring session (since we just loaded it)
                renderCompetitionData(competition, previousCompetitionId, state.selectedAgent.id, false);
                
                // Update dropdown selection
                if(state.renderCompetitionsDropdown) state.renderCompetitionsDropdown();
                
                // Force update of winners list UI
                renderWinners();
                updateCounts();
                drawWheel();

            } else {
                 competitionInfo.innerHTML = '<div class="wr-agent-info-empty">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</div>';
            }
        } catch (e) {
             competitionInfo.innerHTML = '<div class="wr-agent-info-empty">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</div>';
             console.error(e);
        }
    }

    async function renderCompetitionData(competition, previousCompetitionId, agentId, shouldRestoreSession = true) {
        const competitionInfo = document.getElementById('agent-competition-info');
        
        // Display comprehensive competition information
        // Support both new schema (trading_winners_count, deposit_winners_count) and old schema (winners_count)
        // FIX: Check for undefined/null explicitly because 0 is a valid value
        const tradingWinners = (competition.trading_winners_count !== undefined && competition.trading_winners_count !== null)
            ? competition.trading_winners_count
            : (competition.winners_count || 0);
            
        const depositWinners = competition.deposit_winners_count || 0;
        const totalWinners = tradingWinners + depositWinners;
        const currentWinners = competition.current_winners_count || 0;
        
        // Store competition info in state for reference (include prize data)
        // console.log('Active competition loaded:', competition);
        state.activeCompetition = {
          id: competition._id || competition.id,
          tradingWinnersRequired: tradingWinners,
          depositWinnersRequired: depositWinners,
          // Prefer backend required_winners if provided; fallback to sum
          totalRequired: (typeof competition.required_winners === 'number' && competition.required_winners > 0)
            ? competition.required_winners
            : totalWinners,
          requiredWinners: (typeof competition.required_winners === 'number' && competition.required_winners > 0)
            ? competition.required_winners
            : totalWinners,
          currentWinners: currentWinners,
          prizePerWinner: competition.prize_per_winner || 0,
          depositBonusPercentage: competition.deposit_bonus_percentage || 0
        };
        
        // If competition ID changed, ensure we start fresh (though restoreSession handles it, we can be explicit)
        if (previousCompetitionId && previousCompetitionId !== competition._id) {
             console.log('[winner-roulette] Competition changed from', previousCompetitionId, 'to', competition._id, '- forcing clean slate');
             // Only clear if we are going to restore session or if we didn't load anything
             if (shouldRestoreSession) {
                 state.winners = [];
                 state.entries = [];
                 const ta = document.getElementById('participants-input');
                 if (ta) ta.value = '';
             }
        }

        // Restore session for this specific competition ONLY if requested
        if (shouldRestoreSession) {
            await restoreSession(true);
        }
    
        // --- NEW: Fetch agent winner history for validation ---
        try {
            const historyResp = await window.authedFetch(`/api/agents/${agentId}/winners`);
            if (historyResp.ok) {
                const historyData = await historyResp.json();
                // Flatten the competitions structure to get a simple list of winners
                state.agentHistory = [];
                if (historyData.competitions) {
                    historyData.competitions.forEach(c => {
                        if (c.winners) {
                            c.winners.forEach(w => {
                                state.agentHistory.push({
                                    ...w,
                                    competitionName: c.title,
                                    competitionId: c.id
                                });
                            });
                        }
                    });
                }
                // console.log('Loaded agent winner history:', state.agentHistory.length);
            }
        } catch (e) {
            console.warn('Failed to load agent history:', e);
            state.agentHistory = [];
        }
        // -----------------------------------------------------
    
        // Check if competition is completed (only if winners are already sent/approved)
        if (currentWinners >= totalWinners && totalWinners > 0) {
          // Don't show completion message here, only show it after approval
          // This prevents showing "completed" when user just loads the page
        }
    
        // Show engagement stats modal if stats are missing (0)
        if ((!competition.views_count && !competition.reactions_count && !competition.participants_count) || 
            (competition.views_count === 0 && competition.reactions_count === 0 && competition.participants_count === 0)) {
          showEngagementModal(competition._id);
        }
        
        // Format competition data
        const createdDate = new Date(competition.createdAt).toLocaleDateString('ar-EG', {
          year: 'numeric',
          month: 'long',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        const statusText = {
          'sent': 'ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„',
          'active': 'Ù†Ø´Ø·Ø©',
          'awaiting_winners': 'Ù‚ÙŠØ¯ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±',
          'completed': 'Ù…ÙƒØªÙ…Ù„Ø©'
        }[competition.status] || competition.status;
        
        const statusColor = {
          'sent': '#f59e0b',
          'active': '#10b981',
          'awaiting_winners': '#3b82f6',
          'completed': '#6b7280'
        }[competition.status] || '#6b7280';
        
        let html = `
          <div class="wr-competition-header">
            <div class="wr-competition-title">
              <i class="fas fa-trophy"></i>
              <span>${competition.name || 'Ù…Ø³Ø§Ø¨Ù‚Ø©'}</span>
            </div>
            <div class="wr-competition-status" style="background-color: ${statusColor}">
              ${statusText}
            </div>
          </div>
          
          <div class="wr-competition-meta">
            <div class="wr-meta-row">
              <i class="fas fa-calendar"></i>
              <span>ØªÙ… Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡: ${createdDate}</span>
            </div>
            ${state.selectedAgent && state.selectedAgent.agentId ? `
            <div class="wr-meta-row">
              <i class="fas fa-id-badge"></i>
              <span>Ø±Ù‚Ù… Ø§Ù„ÙˆÙƒØ§Ù„Ø©: ${state.selectedAgent.agentId}</span>
            </div>` : ''}
            ${competition.correct_answer ? `
            <div class="wr-meta-row">
              <i class="fas fa-question-circle"></i>
              <span>Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©: ${competition.correct_answer}</span>
            </div>` : ''}
            ${(() => {
              // Determine Arabic type label from template.type or legacy competition_type
              const t = competition.template?.type; // Arabic preferred
              const legacy = competition.template?.competition_type; // 'standard' | 'special'
              let label = '';
              if (t && (t === 'Ù…Ù…ÙŠØ²Ø§Øª' || t === 'ØªÙØ§Ø¹Ù„ÙŠØ©')) {
                label = t;
              } else if (legacy) {
                label = legacy === 'special' ? 'ØªÙØ§Ø¹Ù„ÙŠØ©' : 'Ù…Ù…ÙŠØ²Ø§Øª';
              }
              return label ? `
            <div class="wr-meta-row">
              <i class="fas fa-tag"></i>
              <span>Ù†ÙˆØ¹ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©: ${label}</span>
            </div>` : '';
            })()}
            ${competition.duration ? `
            <div class="wr-meta-row">
              <i class="fas fa-clock"></i>
              <span>Ø§Ù„Ù…Ø¯Ø©: ${competition.duration}</span>
            </div>` : ''}
          </div>
          
          <div class="wr-competition-stats">
            <div class="wr-stats-header">
              <i class="fas fa-users"></i>
              <span>Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ÙŠÙ†</span>
            </div>`;
        
        // Always show stats - even if totalWinners is 0, we need to display the breakdown
        // Use local session selections for clearer UX while picking
        const requiredTotal = (typeof competition.required_winners === 'number' && competition.required_winners > 0) 
          ? competition.required_winners 
          : totalWinners;
        const localSelected = (state && Array.isArray(state.winners)) ? state.winners.length : 0;
        const remainingLocal = Math.max(requiredTotal - localSelected, 0);

        html += `<div class="wr-competition-stat-row wr-stat-total">
          <span class="wr-competition-stat-label"><i class="fas fa-trophy"></i> Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†</span>
          <span class="wr-competition-stat-value">${requiredTotal} ÙØ§Ø¦Ø²</span>
        </div>`;

        html += `<div class="wr-competition-stat-row">
          <span class="wr-competition-stat-label"><i class="fas fa-hourglass-half"></i> Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ</span>
          <span class="wr-competition-stat-value">${remainingLocal}</span>
        </div>`;

        // Bonus breakdown - show REQUIRED counts from competition, not selected
        const depositWinnersRequired = competition.deposit_winners_count || 0;
        const tradingWinnersRequired = competition.trading_winners_count || 0;
        
        // Also show how many have been selected locally (for progress)
        const localDepositCount = (state && Array.isArray(state.winners)) ? state.winners.filter(w => w.prizeType === 'deposit' || w.prizeType === 'deposit_prev').length : 0;
        const localTradingCount = (state && Array.isArray(state.winners)) ? state.winners.filter(w => w.prizeType === 'trading').length : 0;

        html += `<div class="wr-competition-stat-row">
            <span class="wr-competition-stat-label"><i class="fas fa-dollar-sign"></i> Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹</span>
            <span class="wr-competition-stat-value deposit">${localDepositCount} / ${depositWinnersRequired} ÙØ§Ø¦Ø²</span>
          </div>`;

        html += `<div class="wr-competition-stat-row">
            <span class="wr-competition-stat-label"><i class="fas fa-chart-line"></i> Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ</span>
            <span class="wr-competition-stat-value trading">${localTradingCount} / ${tradingWinnersRequired} ÙØ§Ø¦Ø²</span>
          </div>`;
        
        // Add prize information - always show if deposit bonus percentage exists
        if (competition.deposit_bonus_percentage) {
          html += `<div class="wr-prize-info">
            <div class="wr-prize-header">
              <i class="fas fa-gift"></i>
              <span>ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¬ÙˆØ§Ø¦Ø²</span>
            </div>`;
          
          if (competition.prize_per_winner) {
            html += `<div class="wr-prize-row">
              <span class="wr-prize-label">Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¬Ø§Ø¦Ø²Ø© Ù„ÙƒÙ„ ÙØ§Ø¦Ø²:</span>
              <span class="wr-prize-value">$${competition.prize_per_winner}</span>
            </div>`;
          }
          
          html += `<div class="wr-prize-row">
            <span class="wr-prize-label">Ù†Ø³Ø¨Ø© Ø§Ù„Ø¨ÙˆÙ†Øµ Ø§Ù„Ø¥ÙŠØ¯Ø§Ø¹ÙŠ:</span>
            <span class="wr-prize-value">${competition.deposit_bonus_percentage}%</span>
          </div>`;
          
          html += '</div>';
        }
        
        // Add engagement stats
        if (competition.views_count || competition.reactions_count || competition.participants_count) {
          html += `<div class="wr-engagement-stats">
            <div class="wr-engagement-header">
              <i class="fas fa-chart-bar"></i>
              <span>Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªÙØ§Ø¹Ù„</span>
            </div>
            <div class="wr-engagement-grid">`;
          
          if (competition.views_count !== undefined) {
            html += `<div class="wr-engagement-item">
              <div class="wr-engagement-value">${competition.views_count || 0}</div>
              <div class="wr-engagement-label">Ù…Ø´Ø§Ù‡Ø¯Ø©</div>
            </div>`;
          }
          
          if (competition.reactions_count !== undefined) {
            html += `<div class="wr-engagement-item">
              <div class="wr-engagement-value">${competition.reactions_count || 0}</div>
              <div class="wr-engagement-label">ØªÙØ§Ø¹Ù„</div>
            </div>`;
          }
          
          if (competition.participants_count !== undefined) {
            html += `<div class="wr-engagement-item">
              <div class="wr-engagement-value">${competition.participants_count || 0}</div>
              <div class="wr-engagement-label">Ù…Ø´Ø§Ø±Ùƒ</div>
            </div>`;
          }
          
          html += '</div></div>';
        }
        
        html += '</div>';
        competitionInfo.innerHTML = html;
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙÙˆÙ‚ Ø§Ù„Ø±ÙˆÙ„ÙŠØª
        updateCompetitionStats();
    }
    
    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    function updateCompetitionStats() {
      if (!state.activeCompetition) return;
      
      const requiredTotal = state.activeCompetition.requiredWinners || state.activeCompetition.totalRequired || 0;
      const localSelected = (state && Array.isArray(state.winners)) ? state.winners.length : 0;
      const remainingLocal = Math.max(requiredTotal - localSelected, 0);
      
      const depositWinnersRequired = state.activeCompetition.depositWinnersRequired || 0;
      const tradingWinnersRequired = state.activeCompetition.tradingWinnersRequired || 0;
      
      const localDepositCount = (state && Array.isArray(state.winners)) ? state.winners.filter(w => w.prizeType === 'deposit' || w.prizeType === 'deposit_prev').length : 0;
      const localTradingCount = (state && Array.isArray(state.winners)) ? state.winners.filter(w => w.prizeType === 'trading').length : 0;
      
      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¹Ù†Ø§ØµØ± ÙÙŠ Ù‚Ø³Ù… Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© (Ø§Ù„Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø£ÙŠØ³Ø±)
      const remainingEl = document.querySelector('.wr-competition-stat-row:nth-child(2) .wr-competition-stat-value');
      if (remainingEl) {
        remainingEl.textContent = remainingLocal;
      }
      
      const depositEl = document.querySelector('.wr-competition-stat-row:nth-child(3) .wr-competition-stat-value.deposit');
      if (depositEl) {
        depositEl.textContent = `${localDepositCount} / ${depositWinnersRequired} ÙØ§Ø¦Ø²`;
      }
      
      const tradingEl = document.querySelector('.wr-competition-stat-row:nth-child(4) .wr-competition-stat-value.trading');
      if (tradingEl) {
        tradingEl.textContent = `${localTradingCount} / ${tradingWinnersRequired} ÙØ§Ø¦Ø²`;
      }
      
      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¹Ù†Ø§ØµØ± ÙÙˆÙ‚ Ø§Ù„Ø±ÙˆÙ„ÙŠØª (Ø§Ù„Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø£ÙŠÙ…Ù†)
      const wrDepositCount = document.getElementById('wr-deposit-count');
      if (wrDepositCount) {
        wrDepositCount.textContent = `${localDepositCount} / ${depositWinnersRequired} ÙØ§Ø¦Ø²`;
      }
      
      const wrTradingCount = document.getElementById('wr-trading-count');
      if (wrTradingCount) {
        wrTradingCount.textContent = `${localTradingCount} / ${tradingWinnersRequired} ÙØ§Ø¦Ø²`;
      }
    }
    
    function hideAgentInfoBox() {
      const infoBox = document.getElementById('agent-info-box');
      if (infoBox) infoBox.style.display = 'none';
    }
    
    function drawWheel() {
      const canvas = document.getElementById('winner-roulette-wheel');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      
      const baseSize = 520;
      canvas.width = baseSize;
      canvas.height = baseSize;
      const W = canvas.width, H = canvas.height;
      const cx = W / 2, cy = H / 2;
      const radius = Math.min(W, H) / 2 - 15;
    
      // ØªØ­Ø¯ÙŠØ« ÙˆÙ‚Øª Ø§Ù„Ù†Ø¨Ø¶ Ù„Ù„ØªØ£Ø«ÙŠØ± Ø§Ù„Ù…ØªØ­Ø±Ùƒ
      state.pulseTime += 0.05;
    
      ctx.clearRect(0, 0, W, H);
    
      // Ø§Ù„Ù…Ø±Ø´Ø­ÙŠÙ† Ù„Ù„Ø§Ø®ØªÙŠØ§Ø± (ÙŠØ³ØªØ«Ù†Ù‰ Ø§Ù„ÙØ§Ø¦Ø² Ø¥Ø°Ø§ ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ¨Ø¹Ø§Ø¯)
      const candidates = state.entries.filter(e => !e.selected || !state.excludeWinner);
      // If a spin is in progress and we have a snapshot, use it for consistent visuals
      const candidatesSource = (state.spinning && state.spinSnapshot && state.spinSnapshot.length) ? state.spinSnapshot : candidates;
      // Ø¥Ù† Ø§ÙƒØªÙ…Ù„ Ø¹Ø¯Ø¯ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù„Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ø¹Ø±Ø¶ Ø§Ù„Ø±ÙˆÙ„ÙŠØª Ø¨Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† ÙÙ‚Ø·
      const showWinnersOnly = state.activeCompetition && state.winners.length === state.activeCompetition.totalRequired && state.winners.length > 0;
      const wheelData = showWinnersOnly ? state.winners : candidatesSource;
      const n = wheelData.length === 0 ? 1 : wheelData.length; // Ù„Ø§ ØªØ¬Ø¹Ù„Ù‡Ø§ ØµÙØ± Ù„ØªÙØ§Ø¯ÙŠ Ø§Ù„Ù‚Ø³Ù…Ø© Ø¹Ù„Ù‰ ØµÙØ±
      const slice = (Math.PI * 2) / n;
      
      // Ù„ÙˆØ­Ø© Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø¨Ø¯Ø±Ø¬Ø§Øª Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø²Ø±Ù‚ Ø§Ù„Ø¯Ø§ÙƒÙ† Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
      const baseColor = 'rgb(12, 33, 64)';
      const colors = [
        { base: baseColor, light: 'rgb(18, 45, 82)', dark: 'rgb(8, 22, 43)' },
        { base: baseColor, light: 'rgb(18, 45, 82)', dark: 'rgb(8, 22, 43)' },
        { base: baseColor, light: 'rgb(18, 45, 82)', dark: 'rgb(8, 22, 43)' }
      ];
    
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(-state.angle);
    
      for (let i = 0; i < n; i++) {
        const start = i * slice + Math.PI/2;
        const end = start + slice;
        const midAngle = start + slice / 2;
        const colorSet = colors[i % 3];
        
        // Ù†ØµÙ Ù‚Ø·Ø± Ø§Ù„Ø´Ø¹Ø§Ø± ÙÙŠ Ø§Ù„Ù…Ù†ØªØµÙ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¯Ø§Ø®Ù„
        const innerRadius = 60; // Ø£ØµØºØ± Ù…Ù† Ù‚Ø¨Ù„ Ù„Ø¥Ø¹Ø·Ø§Ø¡ Ù…Ø³Ø§Ø­Ø© Ø£ÙƒØ¨Ø± Ù„Ù„Ù†ØµÙˆØµ
        
        // Ø±Ø³Ù… Ø§Ù„Ù‚Ø·Ø§Ø¹ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ (Ø­Ù„Ù‚ÙŠ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ù…Ø«Ù„Ø«)
        ctx.beginPath();
        ctx.arc(0, 0, radius, start, end);
        ctx.arc(0, 0, innerRadius, end, start, true);
        ctx.closePath();
        
        // ØªØ¯Ø±Ø¬ Ù„ÙˆÙ†ÙŠ Ù…Ù† Ø§Ù„Ù…Ø±ÙƒØ² Ø¥Ù„Ù‰ Ø§Ù„Ø®Ø§Ø±Ø¬
        const baseGradient = ctx.createRadialGradient(0, 0, innerRadius, 0, 0, radius);
        baseGradient.addColorStop(0, colorSet.dark);
        baseGradient.addColorStop(0.4, colorSet.base);
        baseGradient.addColorStop(1, colorSet.light);
        ctx.fillStyle = baseGradient;
        ctx.fill();
    
        // ØªØ£Ø«ÙŠØ± Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø© Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
        ctx.save();
        ctx.clip();
        
        // Ø¥Ø¶Ø§Ø¡Ø© Ø¹Ù„ÙˆÙŠØ©
        const lightGradient = ctx.createRadialGradient(
          Math.cos(midAngle) * radius * 0.3, 
          Math.sin(midAngle) * radius * 0.3, 
          0,
          Math.cos(midAngle) * radius * 0.5, 
          Math.sin(midAngle) * radius * 0.5, 
          radius * 0.9
        );
        lightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
        lightGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.3)');
        lightGradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.1)');
        lightGradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
        
        ctx.fillStyle = lightGradient;
        ctx.beginPath();
        ctx.arc(0, 0, radius, start, end);
        ctx.arc(0, 0, innerRadius, end, start, true);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    
        // Ø±Ø³Ù… Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„ÙØ§ØµÙ„Ø© Ø¨ÙŠÙ† Ø§Ù„Ù‚Ø·Ø§Ø¹Ø§Øª (Ù…Ù† Ø§Ù„Ø´Ø¹Ø§Ø± Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ© Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ©)
        ctx.beginPath();
        ctx.moveTo(Math.cos(start) * innerRadius, Math.sin(start) * innerRadius);
        ctx.lineTo(Math.cos(start) * radius, Math.sin(start) * radius);
        
        // Ø®Ø· ÙØ§ØµÙ„ Ø°Ù‡Ø¨ÙŠ
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 3;
        ctx.shadowColor = 'rgba(245, 158, 11, 0.6)';
        ctx.shadowBlur = 6;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.stroke();
        
        // Ø®Ø· Ø¯Ø§Ø®Ù„ÙŠ Ù„Ù„Ø¹Ù…Ù‚
        ctx.shadowBlur = 0;
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.shadowColor = 'transparent';
        
        // Ø¯ÙˆØ§Ø¦Ø± Ø²Ø®Ø±ÙÙŠØ© Ø¯Ø§Ø®Ù„ÙŠØ© (Ø¶Ù…Ù† Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø­Ù„Ù‚ÙŠØ© ÙÙ‚Ø·)
        const decorRadius1 = innerRadius + (radius - innerRadius) * 0.4;
        const decorRadius2 = innerRadius + (radius - innerRadius) * 0.7;
        
        ctx.strokeStyle = 'rgba(245, 158, 11, 0.35)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, decorRadius2, start, end);
        ctx.stroke();
        
        ctx.strokeStyle = 'rgba(245, 158, 11, 0.18)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, 0, decorRadius1, start, end);
        ctx.stroke();
    
        // Ø§Ù„Ù†Øµ: Ø§Ø³Ù… Ø§Ù„Ù…Ø´Ø§Ø±Ùƒ (Ø£ÙÙ‚ÙŠ)
        // Note: We draw in the same order as the array (don't reverse)
        const entry = wheelData[i];
        // Ø¥Ø°Ø§ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª (n=1 Ùˆ wheelData ÙØ§Ø±Øº) Ø§Ø¹Ø±Ø¶ Ù†Øµ Ø§ÙØªØ±Ø§Ø¶ÙŠ
        const displayName = entry ? getWheelDisplayName(entry.name, n) : 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø³Ù…Ø§Ø¡';
        const seqPrefix = entry && (entry.seq || entry.seq === 0) ? `${entry.seq}- ` : '';
        const text = seqPrefix + displayName;
        ctx.save();
        ctx.rotate(midAngle);
        // ÙˆØ¶Ø¹ Ø§Ù„Ù†Øµ ÙÙŠ Ù…Ù†ØªØµÙ Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ø´Ø¹Ø§Ø± ÙˆØ§Ù„Ø­Ø§ÙØ© Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ©
        const textRadius = (innerRadius + radius) / 2;
        ctx.translate(textRadius, 0);
        // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ø¹Ù…ÙˆØ¯ÙŠ Ù„Ø¬Ø¹Ù„ Ø§Ù„Ù†Øµ Ø£ÙÙ‚ÙŠØ§Ù‹
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Ø¸Ù„ Ø«Ù„Ø§Ø«ÙŠ Ù„Ù„Ù†Øµ
        ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
        ctx.shadowBlur = 8;
        ctx.shadowOffsetX = 3;
        ctx.shadowOffsetY = 3;
        
        // Ø¶Ø¨Ø· Ø­Ø¬Ù… Ø§Ù„Ø®Ø· Ø­Ø³Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ø·Ø§Ø¹Ø§Øª
        const baseFontSize = 18;
        let dynamicSize = n <= 3 ? 32 : n <= 6 ? 26 : n <= 10 ? 22 : baseFontSize;
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…ØªØ§Ø­ Ù„Ù„Ù†Øµ ÙÙŠ Ø§Ù„Ù‚Ø·Ø§Ø¹ Ø§Ù„Ø­Ù„Ù‚ÙŠ
        const availableWidth = (radius - innerRadius) * 0.85; // Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø·Ø§Ø¹ Ù…Ø¹ Ù‡Ø§Ù…Ø´
        
        // ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ø®Ø· ÙˆÙ‚ÙŠØ§Ø³ Ø¹Ø±Ø¶ Ø§Ù„Ù†Øµ
        ctx.font = `bold ${dynamicSize}px Arial`;
        let textWidth = ctx.measureText(text).width;
        
        // ØªØµØºÙŠØ± Ø§Ù„Ø®Ø· ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù†Øµ Ø£Ø·ÙˆÙ„ Ù…Ù† Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…ØªØ§Ø­
        while (textWidth > availableWidth && dynamicSize > 8) {
          dynamicSize -= 1;
          ctx.font = `bold ${dynamicSize}px Arial`;
          textWidth = ctx.measureText(text).width;
        }
    
        // Ø§Ù„Ù†Øµ Ø§Ù„Ø£Ø¨ÙŠØ¶ ÙÙ‚Ø· Ù…Ø¹ Ø¸Ù„ Ø£Ø³ÙˆØ¯ Ø¨Ø³ÙŠØ·
        ctx.fillStyle = '#ffffff';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        ctx.fillText(text, 0, 0);
        
        ctx.shadowColor = 'transparent';
        ctx.restore();
      }
    
      ctx.restore();
    
      // Ø±Ø³Ù… Ø¯Ø§Ø¦Ø±Ø© Ø¨Ø®Ù„ÙÙŠØ© Ø²Ø±Ù‚Ø§Ø¡ Ø¯Ø§ÙƒÙ†Ø© ÙÙŠ Ø§Ù„Ù…Ù†ØªØµÙ Ù„Ù„Ø´Ø¹Ø§Ø±
      ctx.beginPath();
      ctx.arc(cx, cy, 55, 0, Math.PI * 2);
      ctx.fillStyle = 'rgb(19, 53, 91)';
      ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
      ctx.shadowBlur = 15;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 5;
      ctx.fill();
      ctx.shadowColor = 'transparent';
      
      // Ø­Ø¯ÙˆØ¯ Ø¨Ù†ÙØ³ Ù„ÙˆÙ† Ø§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„Ø²Ø±Ù‚Ø§Ø¡
      ctx.strokeStyle = 'rgb(19, 53, 91)';
      ctx.lineWidth = 4;
      ctx.stroke();
    
      // Ø±Ø³Ù… Ø§Ù„Ø´Ø¹Ø§Ø± ÙÙŠ Ø§Ù„Ù…Ù†ØªØµÙ
      if (!state.logoImage) {
        state.logoImage = new Image();
        state.logoImage.src = '/images/logo.png';
        state.logoImage.onload = () => {
          drawWheel(); // Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø³Ù… Ø§Ù„Ø¹Ø¬Ù„Ø© Ø¨Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø´Ø¹Ø§Ø±
        };
      }
      
      if (state.logoImage && state.logoImage.complete) {
        const logoSize = 60; // Ø­Ø¬Ù… Ø§Ù„Ø´Ø¹Ø§Ø± Ø£ØµØºØ± Ù„ÙˆØ¶ÙˆØ­ Ø£ÙØ¶Ù„
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, 50, 0, Math.PI * 2);
        ctx.clip();
        ctx.drawImage(
          state.logoImage,
          cx - logoSize / 2,
          cy - logoSize / 2,
          logoSize,
          logoSize
        );
        ctx.restore();
      }
      
      // Ø±Ø³Ù… Ø§Ù„Ø³Ù‡Ù… Ø§Ù„Ø£Ø­Ù…Ø± (Ø§Ù„Ù…Ø¤Ø´Ø±)
      ctx.save();
      ctx.translate(cx, cy - radius - 10); // Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø³Ù‡Ù… ÙÙˆÙ‚ Ø§Ù„Ø¹Ø¬Ù„Ø©
      ctx.beginPath();
      ctx.moveTo(-15, -20); // Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„ÙŠØ³Ø±Ù‰ Ø§Ù„Ø¹Ù„ÙŠØ§
      ctx.lineTo(15, -20);  // Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„ÙŠÙ…Ù†Ù‰ Ø§Ù„Ø¹Ù„ÙŠØ§
      ctx.lineTo(0, 10);    // Ø±Ø£Ø³ Ø§Ù„Ø³Ù‡Ù… (Ù„Ù„Ø£Ø³ÙÙ„)
      ctx.closePath();
      
      ctx.fillStyle = '#ef4444'; // Ù„ÙˆÙ† Ø£Ø­Ù…Ø±
      ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
      ctx.shadowBlur = 4;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 2;
      ctx.fill();
      
      // Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø³Ù‡Ù…
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
      
      // Ø¥Ø¶Ø§ÙØ© Ù†Øµ "Ø§Ø¶ØºØ· Ù‡Ù†Ø§" Ù…Ø¹ Ø®Ù„ÙÙŠØ© Ø´ÙØ§ÙØ© ÙÙˆÙ‚ Ø§Ù„Ø´Ø¹Ø§Ø±
      if (state.showLogoHint) {
        ctx.save();
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
    
        // Ù‚ÙŠØ§Ø³ Ø­Ø¬Ù… Ø§Ù„Ù†Øµ
        const text = 'Ø§Ø¶ØºØ· Ù‡Ù†Ø§';
        const textMetrics = ctx.measureText(text);
        const textWidth = textMetrics.width;
        const textHeight = 24;
    
        // Ø±Ø³Ù… Ø®Ù„ÙÙŠØ© Ø¯Ø§Ø¦Ø±ÙŠØ© Ù…ØªØ­Ø±ÙƒØ© Ø¨Ø­Ø¬Ù… Ø§Ù„Ø´Ø¹Ø§Ø± ÙƒÙ„Ù‡
        const pulseOpacity = 0.2 + 0.2 * Math.sin(state.pulseTime); // ØªØªØ±Ø§ÙˆØ­ Ø¨ÙŠÙ† 0.2 Ùˆ 0.4
        ctx.beginPath();
        ctx.arc(cx, cy, 70, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(0, 0, 0, ${pulseOpacity})`; // Ø´ÙØ§ÙÙŠØ© Ù…ØªØ­Ø±ÙƒØ©
        ctx.fill();
    
        // Ø±Ø³Ù… Ø§Ù„Ù†Øµ Ù…Ø¹ Ø¸Ù„
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 3;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        ctx.fillStyle = 'white';
        ctx.fillText(text, cx, cy);
    
        ctx.restore();
      }
    }
    
    // ==========================================
    // IndexedDB Helper for Video Persistence
    // ==========================================
    const DB_NAME = 'WinnerRouletteDB';
    const STORE_NAME = 'videos';
    let dbInstance = null;

    function getDB() {
        if (dbInstance) return Promise.resolve(dbInstance);
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, 1);
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    db.createObjectStore(STORE_NAME);
                }
            };
            request.onsuccess = (event) => {
                dbInstance = event.target.result;
                resolve(dbInstance);
            };
            request.onerror = (event) => reject(event.target.error);
        });
    }

    async function saveVideoToDB(id, blob) {
        try {
            const db = await getDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readwrite');
                tx.objectStore(STORE_NAME).put(blob, id);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        } catch (e) {
            console.warn('IndexedDB save failed', e);
        }
    }

    async function getVideoFromDB(id) {
        try {
            const db = await getDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readonly');
                const req = tx.objectStore(STORE_NAME).get(id);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        } catch (e) {
            console.warn('IndexedDB get failed', e);
            return null;
        }
    }

    async function deleteVideoFromDB(id) {
        try {
            const db = await getDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readwrite');
                tx.objectStore(STORE_NAME).delete(id);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        } catch (e) {
            console.warn('IndexedDB delete failed', e);
        }
    }

    // ==========================================
    // Initialize Winner Roulette
    // ==========================================
    function init() {
      // [init] Winner Roulette initialization started
      
      try { document.body.classList.add('dark-mode'); } catch(e) {}
      
      // Make sure the modal structure is up-to-date before any winner selection occurs
      // Calling ensureWinnerModalStructure
      ensureWinnerModalStructure();
      // ensureWinnerModalStructure completed
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† agent_id ÙÙŠ URL Ù„Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
      const hash = window.location.hash;
      const [route, query] = hash.split('?');
      const urlParams = new URLSearchParams(query || '');
      const agentIdFromUrl = urlParams.get('agent_id');
      
      // Clear selected agent on page load - always start fresh
      state.selectedAgent = null;
      state.activeCompetition = null;
      
      loadAgents();
      bindUI();
      startPulseAnimation(); // Ø¨Ø¯Ø¡ Ø§Ù„ØªØ£Ø«ÙŠØ± Ø§Ù„Ù…ØªØ­Ø±Ùƒ Ù„Ù„Ø®Ù„ÙÙŠØ©
      
      // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ agent_id ÙÙŠ URLØŒ Ø­Ø¯Ø¯ Ø§Ù„ÙˆÙƒÙŠÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
      if (agentIdFromUrl) {
        setTimeout(() => {
          autoSelectAgent(agentIdFromUrl);
        }, 500); // Ø§Ù†ØªØ¸Ø§Ø± ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡
      }
      
      restoreSession(true); // Ù„Ø§ Ù†Ø³ØªØ¹ÙŠØ¯ Ø§Ù„ÙˆÙƒÙŠÙ„ Ø¨Ø¹Ø¯ Ø§Ù„Ø¢Ù†
      state.selectedAgent = null; // ØªØ£ÙƒÙŠØ¯ Ø§Ù„ØªÙØ±ÙŠØº Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ø³ØªØ±Ø¬Ø§Ø¹
      updateSpinControls?.();
      drawWheel();

      // Ù…Ø²Ø§Ù…Ù†Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ù„Ù„Ù…ØªØ¨Ù‚ÙŠ: Ø­Ø¯Ø« Ø¯ÙˆØ±ÙŠ ÙŠØ­Ø¯Ø« ÙƒÙ„ 25 Ø«Ø§Ù†ÙŠØ© Ù„Ø¬Ù„Ø¨ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
      try {
        if (window._wrAutoSyncTimer) { clearInterval(window._wrAutoSyncTimer); }
        window._wrAutoSyncTimer = setInterval(async () => {
          try {
            if (!state.selectedAgent || !state.selectedAgent.id) return;
            const authedFetch = window.authedFetch || fetch;
            const resp = await authedFetch(`/api/competitions/agent/${state.selectedAgent.id}/active`);
            if (!resp.ok) return;
            const result = await resp.json();
            const competition = result.competition;
            if (!competition) return;
            const currentWinners = competition.current_winners_count || 0;
            const requiredTotal = (typeof competition.required_winners === 'number' && competition.required_winners > 0)
              ? competition.required_winners
              : ((competition.trading_winners_count || 0) + (competition.deposit_winners_count || 0));
            state.activeCompetition = {
              ...(state.activeCompetition || {}),
              id: competition._id,
              tradingWinnersRequired: competition.trading_winners_count || 0,
              depositWinnersRequired: competition.deposit_winners_count || 0,
              totalRequired: requiredTotal,
              requiredWinners: requiredTotal,
              currentWinners: currentWinners,
              prizePerWinner: competition.prize_per_winner || 0,
              depositBonusPercentage: competition.deposit_bonus_percentage || 0
            };
            updateCounts();
          } catch (e) {
            // ØªØ¬Ø§Ù‡Ù„ Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ù…Ø¤Ù‚ØªØ©
          }
        }, 25000);
      } catch (e) { /* ignore */ }
    
      // Log screen size for debugging
      // Screen size log removed to reduce noise
    }
    
    function autoSelectAgent(agentId) {
      const agentSelect = document.getElementById('agent-select');
      if (!agentSelect) return;
      
      // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„Ø°ÙŠ ÙŠØ·Ø§Ø¨Ù‚ agent _id
      const option = Array.from(agentSelect.options).find(opt => opt.value === agentId);
      if (option) {
        agentSelect.value = option.value;
        // Ù…Ø­Ø§ÙƒØ§Ø© Ø­Ø¯Ø« change Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙˆÙƒÙŠÙ„
        agentSelect.dispatchEvent(new Event('change'));
        // console.log(`ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙˆÙƒÙŠÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹: ${option.textContent}`);
      } else {
        console.warn(`Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ÙˆÙƒÙŠÙ„ Ø¨Ø§Ù„Ù…Ø¹Ø±Ù: ${agentId}`);
      }
    }
    
    function startPulseAnimation() {
      if (state.isAnimating) return; // ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø±
      state.isAnimating = true;
      
      const animate = () => {
        if (!state.isAnimating) return;
        state.pulseTime += 0.05;
        drawWheel(); // Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø³Ù… Ø§Ù„Ø¹Ø¬Ù„Ø© Ù…Ø¹ Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¬Ø¯ÙŠØ¯
        requestAnimationFrame(animate);
      };
      
      animate();
    }
    
    function bindUI() {
      const applyBtn = document.getElementById('apply-list');
      const autoBtn = document.getElementById('auto-pick-btn');
      const resetBtn = document.getElementById('reset-wheel');
      const openWheelBtn = document.getElementById('open-wheelofnames');
      const excludeCb = document.getElementById('exclude-winner');
      const saveBtn = document.getElementById('save-session');
      const restoreBtn = document.getElementById('restore-session');
      const exportBtn = document.getElementById('export-winners');
      const batchInput = document.getElementById('batch-count');
      const speedSelect = document.getElementById('spin-speed');
      const confettiCanvas = document.getElementById('wr-confetti-canvas');
      const searchInput = document.getElementById('participants-search');
      const resetWinnersBtn = document.getElementById('reset-winners');
      const agentSelect = document.getElementById('agent-select');
      const refreshParticipantsBtn = document.getElementById('refresh-participants');
      const sendReportBtn = document.getElementById('send-winners-report');
      sendReportBtn?.addEventListener('click', sendWinnersReport);
      const sendDetailsBtn = document.getElementById('send-winners-details');
      sendDetailsBtn?.addEventListener('click', sendWinnersDetails);
      const warnMeetCb = document.getElementById('warn-meet-client');
      const warnPrevCb = document.getElementById('warn-prev-winner');
      // If toggles are missing (cached HTML), inject them
      if (!warnMeetCb || !warnPrevCb) {
        const inlineActions = document.querySelector('.wr-inline-actions');
        if (inlineActions && !document.getElementById('warn-meet-client')) {
          const wrapper = document.createElement('div');
          wrapper.className = 'wr-warning-toggles';
          wrapper.style.cssText = 'display:flex;flex-direction:column;gap:4px;margin-top:6px;width:100%;';
          wrapper.innerHTML = `
            <label class="wr-toggle-label" style="display:flex;align-items:center;gap:6px;font-size:0.9rem;">
              <input type="checkbox" id="warn-meet-client">
              <span>Ø¥Ø¶Ø§ÙØ© ØªÙ†Ø¨ÙŠÙ‡: âš ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ Ù…Ø¹ Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù†Ù‡ Ø£ÙˆÙ„Ø§Ù‹</span>
            </label>
            <label class="wr-toggle-label" style="display:flex;align-items:center;gap:6px;font-size:0.9rem;">
              <input type="checkbox" id="warn-prev-winner">
              <span>Ø¥Ø¶Ø§ÙØ© ØªÙ†Ø¨ÙŠÙ‡: â€¼ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ø£ÙˆÙ„Ù‹Ø§ Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¹Ù…ÙŠÙ„ØŒ Ø­ÙŠØ« Ø³Ø¨Ù‚ Ø£Ù† ÙØ§Ø² Ø¨Ø¬Ø§Ø¦Ø²Ø© (Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ) Ø®Ù„Ø§Ù„ Ø§Ù„Ø£ÙŠØ§Ù… Ø§Ù„Ù…Ø§Ø¶ÙŠØ©</span>
            </label>
          `;
          inlineActions.appendChild(wrapper);
        }
      }
      const warnMeetEl = document.getElementById('warn-meet-client');
     const warnPrevEl = document.getElementById('warn-prev-winner');
      warnMeetEl?.addEventListener('change', (e) => { state.includeWarnMeet = !!e.target.checked; });
      warnPrevEl?.addEventListener('change', (e) => { state.includeWarnPrev = !!e.target.checked; });
      if(confettiCanvas){confettiCanvas.width=window.innerWidth;confettiCanvas.height=window.innerHeight;}
    
      agentSelect?.addEventListener('change', async (e) => {
        const agentId = e.target.value;
        if (!agentId) {
          state.selectedAgent = null;
          updateAgentStatus('', '');
          hideAgentInfoBox();
          updateSpinControls?.();
          updateBatchCount?.();
          return;
        }
        const option = e.target.selectedOptions[0];
        const agentIdNum = option.dataset.agentId;
        const agentName = option.textContent.split(' (#')[0]; // Extract name only
        state.selectedAgent = {
          id: agentId,
          name: agentName,
          agentId: agentIdNum
        };
        updateAgentStatus(agentName, agentIdNum);
        await loadAgentCompetitionInfo(agentId);
        updateSpinControls?.();
        updateBatchCount?.();
      });
    
      const participantsInput = document.getElementById('participants-input');
      participantsInput?.addEventListener('input', (e) => {
        // Auto-parse and add participants when typing (line by line)
        const raw = e.target.value;
        const lines = raw.split('\n');
        
        // Re-parse all entries from scratch to ensure accuracy
        const parsedEntries = [];
        
        for (let i = 0; i < lines.length; i++) {
          let line = lines[i].trim();
          // Ignore fully empty or non-text lines (e.g., only dashes/punctuation)
          const contentOnly = line.replace(/[-â€“â€”_|.,;:~*+=#\s]+/g, '');
          if (!line || contentOnly.length === 0) {
            continue;
          }
    
          // Remove sequential numbers from the beginning (like "1- ", "2- ", etc.)
          const cleanedLine = line.replace(/^\d+\s*[-â€“â€”]\s*/, '');
          
          // Parse this single line
          const parts = cleanedLine.split(/[â€”\-â€“]/).map(p => p.trim());
          
          if (parts.length >= 2) {
            const name = parts[0];
            const account = parts[1].replace(/[^\d]/g, '');
    
            if (name && account) {
              // Check if this entry already exists (by name and account)
              const exists = parsedEntries.find(e => e.name === name && e.account === account);
              if (!exists) {
                const newEntry = {
                  id: `entry_${Date.now()}_${i}_${Math.random()}`,
                  name: name,
                  account: account,
                  label: `${name} â€” ${account}`,
                  selected: false
                };
                parsedEntries.push(newEntry);
              }
            }
          } else if (parts.length === 1) {
            const name = parts[0];
            
            if (name) {
              // Check if this entry already exists (by name only)
              const exists = parsedEntries.find(e => e.name === name && !e.account);
              if (!exists) {
                const newEntry = {
                  id: `entry_${Date.now()}_${i}_${Math.random()}`,
                  name: name,
                  account: '',
                  label: name,
                  selected: false
                };
                parsedEntries.push(newEntry);
              }
            }
          }
        }
    
        // Update state with parsed entries, preserving selected status
        const oldSelected = state.entries.filter(e => e.selected);
        
        parsedEntries.forEach(newEntry => {
          const wasSelected = oldSelected.find(e => e.name === newEntry.name && e.account === newEntry.account);
          if (wasSelected) {
            newEntry.selected = true;
            newEntry.id = wasSelected.id; // Preserve original ID
          }
        });
        
        state.entries = parsedEntries;
        // Ù…Ø³Ø­ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†
        state.winners = [];
        
        renderParticipants();
        renderWinners();
        drawWheel();
        saveSession();
      });
    
      applyBtn?.addEventListener('click', () => {
        // This button is now hidden, but we keep the logic just in case
        const raw = document.getElementById('participants-input').value;
        state.entries = parseEntries(raw);
        // Ù…Ø³Ø­ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†
        state.winners = [];
        renderParticipants();
        renderWinners();
        drawWheel();
        toast('ØªÙ… ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†', 'success');
      });
    
      excludeCb?.addEventListener('change', (e) => {
        state.excludeWinner = !!e.target.checked;
      });
    
      // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø¹Ø§Ø± Ù„Ù„Ø¯ÙˆØ±Ø§Ù†
      const wheelCanvas = document.getElementById('winner-roulette-wheel');
      wheelCanvas?.addEventListener('click', (e) => {
        const canvas = e.target;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const distance = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
        
        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù†Ù‚Ø± Ø¯Ø§Ø®Ù„ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø´Ø¹Ø§Ø± (Ù†ØµÙ Ù‚Ø·Ø± 70)
        // ADJUSTMENT: Increased click radius to 80 to cover border
        if (distance <= 80) {
          // Hide the overlay hint when user interacts with the logo
          state.showLogoHint = false;
          drawWheel();
          queueSpin(1);
        }
      });
      
      autoBtn?.addEventListener('click', () => {
        const c = parseInt(batchInput?.value || '1',10);
        const count = c>0 ? c : 1;
        startAutoPick(count);
      });
      resetBtn?.addEventListener('click', () => {
        state.angle = 0; state.targetAngle = 0; drawWheel();
      });
    
      // Open entries in Wheel of Names via backend integration (secure API key)
      openWheelBtn?.addEventListener('click', async () => {
        try {
          const entries = (state.entries && state.entries.length)
            ? state.entries.map(e => (e.account ? `${e.name} â€” ${e.account}` : e.name))
            : (document.getElementById('participants-input')?.value || '')
                .split('\n')
                .map(s => s.trim())
                .filter(Boolean);
    
          if (!entries.length) {
            toast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø³Ù…Ø§Ø¡ Ù„ÙØªØ­Ù‡Ø§ ÙÙŠ Wheel of Names', 'warning');
            return;
          }
    
          const authedFetch = window.authedFetch || fetch;
          const title = state.selectedAgent?.name ? `Ù…Ø³Ø§Ø¨Ù‚Ø© ${state.selectedAgent.name}` : 'Ù…Ø³Ø§Ø¨Ù‚Ø© INZO';
          const body = { entries, title, agent: state.selectedAgent || undefined, shareMode: 'copyable' };
          const resp = await authedFetch('/api/integrations/wheelofnames/wheels', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });
    
          if (!resp.ok) {
            // Fallback: construct a prefilled URL on wheelofnames.com/view
            const txt = encodeURIComponent(entries.join(','));
            const fallbackUrl = `https://wheelofnames.com/view?entries=${txt}`;
            toast('ØªØ¹Ø°Ø± Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ø¬Ù„Ø© Ø¹Ø¨Ø± Ø§Ù„Ù€ APIØŒ ØªÙ… ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ø¨Ø¯ÙŠÙ„', 'info');
            window.open(fallbackUrl, '_blank');
            return;
          }
    
          const data = await resp.json();
          if (data && data.url) {
            window.open(data.url, '_blank');
            toast('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ø¬Ù„Ø© Ø¹Ù„Ù‰ Wheel of Names', 'success');
          } else {
            const txt = encodeURIComponent(entries.join(','));
            const fallbackUrl = `https://wheelofnames.com/view?entries=${txt}`;
            window.open(fallbackUrl, '_blank');
          }
        } catch (e) {
          console.error('Wheel of Names open failed', e);
          const entries = state.entries?.map(e => (e.account ? `${e.name} â€” ${e.account}` : e.name)) || [];
          if (entries.length) {
            const txt = encodeURIComponent(entries.join(','));
            const fallbackUrl = `https://wheelofnames.com/view?entries=${txt}`;
            window.open(fallbackUrl, '_blank');
          } else {
            toast('ÙØ´Ù„ ÙØªØ­ Wheel of Names', 'error');
          }
        }
      });
    
      saveBtn?.addEventListener('click', () => saveSession());
      restoreBtn?.addEventListener('click', () => restoreSession());
      exportBtn?.addEventListener('click', exportWinners);
      
      // Bottom section buttons
      const exportBottomBtn = document.getElementById('export-winners-bottom');
      const resetBottomBtn = document.getElementById('reset-winners-bottom');
      // Hide and disable reset button under roulette per request
      if (resetBottomBtn) { resetBottomBtn.style.display = 'none'; }
      exportBottomBtn?.addEventListener('click', exportWinners);
      resetBottomBtn?.addEventListener('click', ()=> { 
        showConfirmModal(
          'Ø³ÙŠØªÙ… Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† ÙˆØ¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ† Ù„Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ù…Ù† Ø¬Ø¯ÙŠØ¯. Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ØŸ',
          () => {
            // Clear winners
            state.winners = [];
            // Re-add all participants from textarea/source
            const ta = document.getElementById('participants-input');
            const lines = (ta?.value || '').split('\n').map(s=>s.trim()).filter(Boolean);
            state.entries = lines.map((line, idx) => {
              const parts = line.split(' â€” ');
              const name = parts[0] || line;
              const account = parts[1] || '';
              return { id: `entry_${idx}_${Date.now()}`, name, account, label: account ? `${name} â€” ${account}` : name, selected: false };
            });
            renderParticipants();
            renderWinners();
            updateCounts();
            saveSession();
            toast('ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙ‡ÙŠØ¦Ø©: Ù…Ø³Ø­ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† ÙˆØ¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†', 'success');
          }
        );
      });
      
      window.addEventListener('resize', () => { drawWheel(); if(confettiCanvas){confettiCanvas.width=window.innerWidth;confettiCanvas.height=window.innerHeight;} });
      searchInput?.addEventListener('input', ()=> { state.filterTerm = searchInput.value.trim(); renderParticipants(); updateCounts(); });
      /* Reset button removed per request
      resetWinnersBtn?.addEventListener('click', ()=> { 
        showConfirmModal(
          'Ø³ÙŠØªÙ… Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø¨Ø´ÙƒÙ„ Ø¯Ø§Ø¦Ù… Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©. Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŸ',
          () => {
            state.winners = [];
            renderWinners();
            updateCounts();
            saveSession();
            toast('ØªÙ… Ù…Ø³Ø­ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø¨Ù†Ø¬Ø§Ø­', 'success');
          }
        );
      });
      */
      
      // Refresh participants button - adds winner to roulette after confirmation
      refreshParticipantsBtn?.addEventListener('click', () => {
        if (state.winners.length === 0) {
          toast('Ù„Ø§ ØªÙˆØ¬Ø¯ ÙØ§Ø¦Ø²ÙŠÙ† Ù„Ø¥Ø¶Ø§ÙØªÙ‡Ù… Ù„Ù„Ø±ÙˆÙ„ÙŠØª', 'warning');
          return;
        }
        
        // Add the latest winner to the roulette
        const latestWinner = state.winners[state.winners.length - 1];
        const existingEntry = state.entries.find(e => e.name === latestWinner.name && e.account === latestWinner.account);
        
        if (!existingEntry) {
          // Add winner to participants list
          const newEntry = {
            id: `winner_${Date.now()}`,
            name: latestWinner.name,
            account: latestWinner.account,
            label: `${latestWinner.name} â€” ${latestWinner.account}`,
            selected: false
          };
          state.entries.push(newEntry);
          // Also reflect this in the participants textarea to satisfy the rule
          const ta = document.getElementById('participants-input');
          if (ta) {
            const line = `${latestWinner.name} â€” ${latestWinner.account}`;
            const existing = ta.value.split('\n').map(s=>s.trim()).filter(Boolean);
            if (!existing.includes(line)) {
              ta.value = (ta.value ? (ta.value.replace(/\n+$/,'') + '\n') : '') + line;
            }
          }
          renderParticipants();
          renderWinners();
          drawWheel();
          toast(`ØªÙ… Ø¥Ø¶Ø§ÙØ© ${latestWinner.name} Ù„Ù„Ø±ÙˆÙ„ÙŠØª`, 'success');
        } else {
          toast('Ø§Ù„ÙØ§Ø¦Ø² Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ø§Ù„Ø±ÙˆÙ„ÙŠØª', 'info');
        }
      });
    }
    
    // --- Helper Functions & Missing Definitions ---
    
    function toast(msg, type = 'info') {
        if (window.showToast) {
            window.showToast(msg, type);
        } else {
            console.log(`[${type}] ${msg}`);
            // Fallback: create a simple toast if window.showToast is missing
            const toastEl = document.createElement('div');
            toastEl.style.cssText = `
                position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
                background: ${type === 'error' ? '#ef4444' : '#10b981'};
                color: white; padding: 10px 20px; border-radius: 8px; z-index: 10000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1); font-weight: bold;
            `;
            toastEl.textContent = msg;
            document.body.appendChild(toastEl);
            setTimeout(() => {
                toastEl.style.opacity = '0';
                setTimeout(() => document.body.removeChild(toastEl), 300);
            }, 3000);
        }
    }
    
    function getSessionKey() {
        if (state.selectedAgent && state.selectedAgent.id && state.activeCompetition && state.activeCompetition.id) {
            return `winnerRouletteSession_${state.selectedAgent.id}_${state.activeCompetition.id}`;
        }
        return null;
    }

    function getStagedWinners() {
      try {
        const raw = localStorage.getItem(STAGED_WINNERS_KEY);
        const parsed = raw ? JSON.parse(raw) : [];
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }

    function getStagedWinnersForCompetition(competitionId) {
      if (!competitionId) return [];
      return getStagedWinners().filter(w => w.competitionId === competitionId);
    }

    function addStagedWinner(stagedWinner) {
      const staged = getStagedWinners();
      staged.push(stagedWinner);
      try { localStorage.setItem(STAGED_WINNERS_KEY, JSON.stringify(staged)); } catch {}
    }

    function saveStagedWinner(winner, competitionId) {
      const staged = getStagedWinners();
      const index = staged.findIndex(w => w.id === winner.id);
      if (index >= 0) {
        // Update existing
        staged[index] = { ...staged[index], ...winner, competitionId };
      } else {
        // Add new
        staged.push({ ...winner, competitionId });
      }
      try { localStorage.setItem(STAGED_WINNERS_KEY, JSON.stringify(staged)); } catch {}
    }

    function updateStagedWinner(winnerId, competitionId, patch) {
      const staged = getStagedWinners();
      const next = staged.map(w => {
        if (w.id !== winnerId) return w;
        if (competitionId && w.competitionId !== competitionId) return w;
        return { ...w, ...patch };
      });
      try { localStorage.setItem(STAGED_WINNERS_KEY, JSON.stringify(next)); } catch {}
    }

    function removeStagedWinner(winnerId, competitionId) {
      const staged = getStagedWinners();
      const next = staged.filter(w => {
        if (w.id !== winnerId) return true;
        if (competitionId && w.competitionId !== competitionId) return true;
        return false;
      });
      try { localStorage.setItem(STAGED_WINNERS_KEY, JSON.stringify(next)); } catch {}
    }

    function clearStagedWinnersForCompetition(competitionId) {
      if (!competitionId) return;
      const staged = getStagedWinners();
      const next = staged.filter(w => w.competitionId !== competitionId);
      try { localStorage.setItem(STAGED_WINNERS_KEY, JSON.stringify(next)); } catch {}
    }

    function saveSession() {
      // Persist entries and winners as requested
      const session = {
        entries: state.entries,
        winners: state.winners,
        selectedAgent: state.selectedAgent,
        excludeWinner: state.excludeWinner,
        filterTerm: state.filterTerm,
        activeCompetitionId: state.activeCompetition ? state.activeCompetition.id : null
      };
      try { localStorage.setItem(LS_KEY, JSON.stringify(session)); } catch {}
    }
    
    async function restoreVideosFromDB() {
      if (!state.winners || state.winners.length === 0) return;
      let updated = false;
      for (const winner of state.winners) {
        if (!winner.pendingVideoBlob && !winner.videoUrl) {
           try {
             const blob = await getVideoFromDB(winner.id);
             if (blob) {
               winner.pendingVideoBlob = blob;
               updated = true;
             }
           } catch(e) {
             console.error('Error restoring video for winner:', winner.id, e);
           }
        }
      }
      if (updated) {
        renderWinners();
      }
    }

    async function restoreSession(skipAgent = false) {
      try {
        const raw = localStorage.getItem(LS_KEY);
        if (!raw) return;
        const session = JSON.parse(raw);
        
        state.entries = session.entries || [];
        state.winners = session.winners || [];
        
        // Restore videos from IndexedDB immediately after loading winners
        await restoreVideosFromDB();

        state.excludeWinner = !!session.excludeWinner;
        state.filterTerm = session.filterTerm || '';
        
        if (!skipAgent && session.selectedAgent) {
          state.selectedAgent = session.selectedAgent;
          // We need to re-select the agent in the dropdown if possible
          const agentSelect = document.getElementById('agent-select');
          if (agentSelect) {
             agentSelect.value = session.selectedAgent.id;
             // Trigger change event to load competition info
             agentSelect.dispatchEvent(new Event('change'));
          }
        }

        const excludeCb = document.getElementById('exclude-winner');
        if (excludeCb) excludeCb.checked = state.excludeWinner;
        
        const searchInput = document.getElementById('participants-search');
        if (searchInput) searchInput.value = state.filterTerm;
        
        // Restore participants text area
        const ta = document.getElementById('participants-input');
        if (ta && state.entries.length > 0) {
             ta.value = state.entries.map(e => e.account ? `${e.name} â€” ${e.account}` : e.name).join('\n');
        }

        renderParticipants();
        renderWinners();
        updateCounts();
        drawWheel();
      } catch (e) {
        console.warn('Session restore failed', e);
      }
    }
    
    function exportWinners() {
      if (state.winners.length === 0) {
        toast('Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙØ§Ø¦Ø²ÙŠÙ† Ù„Ù„ØªØµØ¯ÙŠØ±', 'warning');
        return;
      }
      
      let csvContent = "data:text/csv;charset=utf-8,\uFEFF";
      csvContent += "Ø§Ù„Ø§Ø³Ù…,Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨,Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ,Ù†ÙˆØ¹ Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©,Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©,Ø§Ù„ÙˆÙƒÙŠÙ„\n";
      
      state.winners.forEach(w => {
        const agentName = w.agent ? w.agent.name : (state.selectedAgent ? state.selectedAgent.name : '');
        const row = [
          w.name,
          w.account,
          w.email || '',
          w.prizeType === 'deposit' ? 'Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹' : 'Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ',
          w.prizeValue || '',
          agentName
        ].map(f => `"${f}"`).join(",");
        csvContent += row + "\n";
      });
      
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", `winners_${new Date().toISOString().slice(0,10)}.csv`);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
    
    function updateSpinSpeed(speed) {
      switch(speed) {
        case 'slow': state.spinDuration = 8000; break;
        case 'fast': state.spinDuration = 3000; break;
        default: state.spinDuration = 5000; // normal
      }
    }
    
    function showEngagementModal(competitionId) {
        // Check if modal already exists
        let modal = document.getElementById('engagement-modal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'engagement-modal';
            modal.className = 'wr-confirm-overlay';
            modal.innerHTML = `
                <div class="wr-confirm-modal" style="max-width: 400px;">
                    <div class="wr-confirm-icon" style="color: #3b82f6;"><i class="fas fa-chart-bar"></i></div>
                    <h3 class="wr-confirm-title">ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª</h3>
                    <p class="wr-confirm-message">ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªÙØ§Ø¹Ù„ Ù„Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©</p>
                    
                    <div class="wr-form-group" style="text-align: right; margin-bottom: 15px;">
                        <label style="display:block; margin-bottom:5px; color:#cbd5e1;">Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª (Views)</label>
                        <input type="number" id="eng-views" class="wr-form-input" placeholder="0" min="0">
                    </div>
                    
                    <div class="wr-form-group" style="text-align: right; margin-bottom: 15px;">
                        <label style="display:block; margin-bottom:5px; color:#cbd5e1;">Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª (Reactions)</label>
                        <input type="number" id="eng-reactions" class="wr-form-input" placeholder="0" min="0">
                    </div>
                    
                    <div class="wr-form-group" style="text-align: right; margin-bottom: 20px;">
                        <label style="display:block; margin-bottom:5px; color:#cbd5e1;">Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª (Shares/Participants)</label>
                        <input type="number" id="eng-participants" class="wr-form-input" placeholder="0" min="0">
                    </div>
    
                    <div class="wr-confirm-actions">
                        <button class="wr-btn wr-btn-secondary" id="eng-cancel">Ø¥Ù„ØºØ§Ø¡</button>
                        <button class="wr-btn wr-btn-primary" id="eng-save">Ø­ÙØ¸</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        modal.style.display = 'flex';
        
        const viewsInput = document.getElementById('eng-views');
        const reactionsInput = document.getElementById('eng-reactions');
        const participantsInput = document.getElementById('eng-participants');
        
        // Reset inputs
        viewsInput.value = '';
        reactionsInput.value = '';
        participantsInput.value = '';
        
        // Focus first input
        setTimeout(() => viewsInput.focus(), 100);
        
        const cleanup = () => {
            modal.style.display = 'none';
        };
        
        const onSave = async () => {
            const views = parseInt(viewsInput.value) || 0;
            const reactions = parseInt(reactionsInput.value) || 0;
            const participants = parseInt(participantsInput.value) || 0;
            
            const saveBtn = document.getElementById('eng-save');
            saveBtn.disabled = true;
            saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...';
            
            try {
                const authedFetch = window.authedFetch || fetch;
                const resp = await authedFetch(`/api/competitions/${competitionId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        views_count: views,
                        reactions_count: reactions,
                        participants_count: participants
                    })
                });
                
                if (resp.ok) {
                    toast('ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø¨Ù†Ø¬Ø§Ø­', 'success');
                    clearStagedWinnersForCompetition(state.activeCompetition.id);
                    cleanup();
                    // Refresh agent info and engagement stats immediately
                    if (state.selectedAgent) {
                        state.activeCompetition = {
                            ...(state.activeCompetition || {}),
                            views_count: views,
                            reactions_count: reactions,
                            participants_count: participants
                        };
                        await loadAgentCompetitionInfo(state.selectedAgent.id);
                        updateAgentStatus(state.selectedAgent.name, state.selectedAgent.agentId);
                    }
                } else {
                    toast('ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª', 'error');
                }
            } catch (e) {
                console.error(e);
                toast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­ÙØ¸', 'error');
            } finally {
                saveBtn.disabled = false;
                saveBtn.textContent = 'Ø­ÙØ¸';
            }
        };
        
        const cancelBtn = document.getElementById('eng-cancel');
        const saveBtn = document.getElementById('eng-save');
        
        // Remove old listeners to avoid duplicates if modal is reused
        const newCancel = cancelBtn.cloneNode(true);
        cancelBtn.parentNode.replaceChild(newCancel, cancelBtn);
        newCancel.addEventListener('click', cleanup);
        
        const newSave = saveBtn.cloneNode(true);
        saveBtn.parentNode.replaceChild(newSave, saveBtn);
        newSave.addEventListener('click', onSave);
    }
    
    function updateSpinControls() {
      const autoBtn = document.getElementById('auto-pick-btn');
      const hasAgent = !!state.selectedAgent;
      if(autoBtn){ autoBtn.disabled = !hasAgent; autoBtn.classList.toggle('wr-btn-disabled', !hasAgent); }
    }
    
    function updateBatchCount() {
      const input = document.getElementById('batch-count');
      if(!input) return;
      if(!state.selectedAgent || !state.activeCompetition){
        input.disabled = true;
        return;
      }
      input.disabled = false;
    }
    
    function updateCounts() {
        // Total participants
        const totalEl = document.getElementById('participants-count-total');
        if (totalEl) totalEl.textContent = state.entries.length;
        // Winners selected
        const winnersCountEl = document.getElementById('winners-count');
        if (winnersCountEl) winnersCountEl.textContent = state.winners.length;
        // Remaining required winners (bind to backend required_winners if available)
        const remainingEl = document.getElementById('participants-count-remaining');
        if (remainingEl) {
          if (state.activeCompetition) {
            const totalReq = state.activeCompetition.totalRequired || state.activeCompetition.requiredWinners || 0;
            const current = (state.activeCompetition.currentWinners ?? state.winners.length);
            const remaining = Math.max(totalReq - current, 0);
            remainingEl.textContent = remaining;
          } else {
            remainingEl.textContent = Math.max(state.entries.length - state.winners.length, 0);
          }
        }
    }
    
    function showConfirmModal(message, onConfirm) {
      const overlay = document.createElement('div');
      overlay.className = 'wr-confirm-overlay';
      overlay.innerHTML = `
        <div class="wr-confirm-modal">
          <div class="wr-confirm-icon"><i class="fas fa-exclamation-triangle"></i></div>
          <h3 class="wr-confirm-title">ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©</h3>
          <p class="wr-confirm-message">${message}</p>
          <div class="wr-confirm-actions">
            <button class="wr-btn wr-btn-secondary" id="wr-confirm-cancel">Ø¥Ù„ØºØ§Ø¡</button>
            <button class="wr-btn wr-btn-danger" id="wr-confirm-ok">ØªØ£ÙƒÙŠØ¯</button>
          </div>
        </div>
      `;
      document.body.appendChild(overlay);
      
      const cancelBtn = overlay.querySelector('#wr-confirm-cancel');
      const okBtn = overlay.querySelector('#wr-confirm-ok');
      
      const cleanup = () => overlay.remove();
      
      cancelBtn?.addEventListener('click', cleanup);
      okBtn?.addEventListener('click', () => {
        if (onConfirm) onConfirm();
        cleanup();
      });
      
      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) cleanup();
      });
    }
    
    function queueSpin(count){
      if(count<=0) return;
      if (!state.selectedAgent) {
        toast('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ÙˆÙƒÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹', 'warning');
        return;
      }
      if (!state.activeCompetition) {
        toast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù†Ø´Ø·Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„', 'warning');
        return;
      }
      // Ù…Ù†Ø¹ Ø§Ù„Ø¯ÙˆØ±Ø§Ù† Ø¥Ø°Ø§ ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ÙŠÙ†
      const currentTotal = state.winners.length;
      if (state.activeCompetition && currentTotal >= state.activeCompetition.totalRequired) {
        const agentLabel = state.selectedAgent ? state.selectedAgent.name : 'Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„';
        toast(`ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ù„Ù„ÙˆÙƒÙŠÙ„ ${agentLabel} (Ø¹Ø¯Ø¯Ù‡Ù… ${state.activeCompetition.totalRequired}). ÙŠØ±Ø¬Ù‰ Ø§Ø¹ØªÙ…Ø§Ø¯ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø£Ùˆ Ø§Ø³ØªØ±Ø¬Ø§Ø¹ ÙØ§Ø¦Ø² Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¯ÙˆØ±Ø§Ù†.`, 'warning');
        return;
      }
      state.spinQueue = count; // Set directly instead of adding
      if(!state.spinning) startSpin();
    }
    
    function startAutoPick(count){
      if(state.spinning){return;}
      if (!state.selectedAgent) {
        toast('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ÙˆÙƒÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹', 'warning');
        return;
      }
      
      // Check if the number of winners has been reached
      const currentTotal = state.winners.length;
      if (state.activeCompetition && currentTotal >= state.activeCompetition.totalRequired) {
        const agentLabel = state.selectedAgent ? state.selectedAgent.name : 'Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„';
        toast(`ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ù„Ù„ÙˆÙƒÙŠÙ„ ${agentLabel} (Ø¹Ø¯Ø¯Ù‡Ù… ${state.activeCompetition.totalRequired}).`, 'info');
        return;
      }
      
      const available = state.entries.filter(e=> !e.selected || !state.excludeWinner).length;
      if(available===0){ toast('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø´Ø§Ø±ÙƒÙˆÙ† ÙƒØ§ÙÙŠÙˆÙ†'); return; }
      state.autoMode = true;
      state.autoRemaining = Math.min(count, available);
      state.autoBatchPicked = [];
      startSpin();
    }
    
    function startSpin(){
      if(state.spinning){return;}
      if (!state.selectedAgent) {
        toast('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ÙˆÙƒÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹', 'warning');
        return;
      }
      if (!state.activeCompetition) {
        toast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù†Ø´Ø·Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„', 'warning');
        return;
      }
      // Ù…Ù†Ø¹ Ø§Ù„Ø¯ÙˆØ±Ø§Ù† Ø¥Ø°Ø§ ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ÙŠÙ†
      const currentTotal = state.winners.length;
      if (state.activeCompetition && currentTotal >= state.activeCompetition.totalRequired) {
        const agentLabel = state.selectedAgent ? state.selectedAgent.name : 'Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„';
        toast(`ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ù„Ù„ÙˆÙƒÙŠÙ„ ${agentLabel} (Ø¹Ø¯Ø¯Ù‡Ù… ${state.activeCompetition.totalRequired}). ÙŠØ±Ø¬Ù‰ Ø§Ø¹ØªÙ…Ø§Ø¯ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø£Ùˆ Ø§Ø³ØªØ±Ø¬Ø§Ø¹ ÙØ§Ø¦Ø² Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¯ÙˆØ±Ø§Ù†.`, 'warning');
        return;
      }
      const candidates = state.entries.filter(e => {
          // Filter out if not selected (unless excludeWinner is false, but wait...)
          // The logic was: !e.selected || !state.excludeWinner
          // This means: include if NOT selected OR (selected AND we don't exclude winners)
          
          // BUT, we also want to strictly filter out anyone who is ALREADY in state.winners
          // regardless of the 'selected' flag on the entry itself, to be safe.
          const isAlreadyWinner = state.winners.some(w => {
              // Strict check:
              // 1. If both have accounts, they MUST match.
              // 2. If accounts don't match (and both exist), they are different people (even if names match).
              if (w.account && e.account) {
                  return w.account === e.account;
              }
              // If one or both lack account, fallback to name
              return w.name === e.name;
          });
          
          if (isAlreadyWinner) return false; // Always exclude confirmed winners from spinning again
          
          return !e.selected || !state.excludeWinner;
      });
      
      if(candidates.length===0){toast('Ø£Ø¶Ù Ù…Ø´Ø§Ø±ÙƒÙŠÙ† Ø£ÙˆÙ„Ø§Ù‹ (Ø£Ùˆ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ† ÙØ§Ø²ÙˆØ§ Ø¨Ø§Ù„ÙØ¹Ù„)'); state.spinQueue=0; return;}
    
      // Normalize starting angle so each spin has consistent full rotations
      state.angle = 0;
      state.spinning = true;
      const n = candidates.length;
      const slice = (Math.PI*2)/n;
      
      // Select random winner using crypto.getRandomValues for 100% randomness
      const randomBuffer = new Uint32Array(1);
      window.crypto.getRandomValues(randomBuffer);
      const randomFraction = randomBuffer[0] / (0xFFFFFFFF + 1);
      const winningIndex = Math.floor(randomFraction * n);
    
      // Create a snapshot of candidates to lock the wheel state for this spin
      state.spinSnapshot = candidates.slice();
      state.chosenIndex = winningIndex;
      
      // Store chosen winner based on snapshot/index
      const chosenWinner = state.spinSnapshot[winningIndex];

      // --- NEW: Check if this winner has already been selected in the current session ---
      // This prevents re-selecting the same winner if they are still on the wheel (e.g. excludeWinner=false)
      // or if they were manually added back but somehow still flagged.
      const alreadyWon = state.winners.find(w => {
          if (w.account && chosenWinner.account) {
              return w.account === chosenWinner.account;
          }
          return w.name === chosenWinner.name;
      });

      if (alreadyWon) {
          toast(`ØªÙ†Ø¨ÙŠÙ‡: Ù‡Ø°Ø§ Ø§Ù„Ù…ØªØ³Ø§Ø¨Ù‚ (${chosenWinner.name}) ÙØ§Ø² Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©!`, 'warning');
          // We can either stop the spin or let it spin but show a different modal at the end.
          // For better UX, let's stop immediately or re-spin.
          // Re-spinning might be complex if only 1 candidate left.
          // Let's just proceed but flag it, or maybe we should have filtered them out in candidates?
          // Ideally, candidates should filter out state.winners if we want to strictly enforce "one win per person per competition".
          
          // Let's filter candidates properly at the start of startSpin instead.
          // But if we are here, let's just continue and handle it in the completion callback.
      }
      
      // Calculate target angle to make the chosen slice land under the pointer
      // In drawWheel: slice i center is at (i * slice + slice/2 + PI/2)
      // After rotation by -state.angle, it appears at: (i * slice + slice/2 + PI/2 - state.angle)
      // We want it to be at PI/2 (pointer position)
      // Therefore: i * slice + slice/2 + PI/2 - state.angle = PI/2
      // Solving: state.angle = i * slice + slice/2
      // ADJUSTMENT: Pointer is at TOP (3PI/2), so we need to rotate by an extra PI so the winner lands on top
      const targetAngleBase = winningIndex * slice + slice / 2 + Math.PI;
      
      // Add multiple full rotations for effect. MUST be integer spins
      // so the normalized target lands on the intended slice center.
      const integerRotations = 4 + Math.floor(Math.random() * 2); // 4 or 5 full spins
      const fullSpins = integerRotations * Math.PI * 2;
      const epsilon = 1e-6; // tiny nudge to avoid boundary float issues
      state.targetAngle = targetAngleBase + fullSpins + epsilon;
      state.spinStart = performance.now();
      if(!state.spinDuration){updateSpinSpeed(document.getElementById('spin-speed')?.value || 'normal');}
      // Always override if chosen speed is slow to be more gradual
      if((document.getElementById('spin-speed')?.value || 'normal') === 'slow'){
        state.spinDuration = 8500 + Math.random()*1500; // 8.5s - 10s
      }
      // Capture start angle for accurate interpolation
      state.startAngle = state.angle;
      
      // --- START RECORDING ---
      startRecording();
      // -----------------------
      
      animateSpin(() => {
        state.spinning = false;
        // Calculate winner based on final visual position
        // Use state.angle directly (don't normalize) since our math expects positive cumulative angle
        const visualData = state.spinSnapshot || candidates;
        const visualIdx = pickIndexByAngle(visualData.length, state.angle);
        const winner = visualData[visualIdx];
        
        // Clear spin snapshot data
        state.spinSnapshot = null;
        state.chosenIndex = null;
    
        // --- RECORDING EPILOGUE ---
        // Keep drawing the overlay for 3 seconds to ensure it's captured and visible
        const recordingDuration = 3000;
        const startTime = performance.now();
        
        function keepDrawingOverlay() {
            const elapsed = performance.now() - startTime;
            if (elapsed < recordingDuration) {
                drawWinnerOverlay(winner);
                requestAnimationFrame(keepDrawingOverlay);
            } else {
                // Stop recording after 3 seconds
                stopRecording((blob) => {
                    showVideoPreview(blob, winner);
                });
            }
        }
        keepDrawingOverlay();
        // --------------------------
      });
    }
    
    function startRecording() {
      try {
        const canvas = document.getElementById('winner-roulette-wheel');
        if (!canvas) return;
        
        // console.log(`ğŸ¥ [Recording] Initializing MediaRecorder...`);
        const stream = canvas.captureStream(30); // 30 FPS
        
            // Detect supported mimeType
            const mimeTypes = [
                'video/mp4',
                'video/webm;codecs=vp9',
                'video/webm;codecs=vp8',
                'video/webm'
            ];    let mimeType = '';
        for (const type of mimeTypes) {
            if (MediaRecorder.isTypeSupported(type)) {
                mimeType = type;
                break;
            }
        }
        
        if (!mimeType) {
            console.warn('ğŸ¥ [Recording] No supported mimeType found, trying default constructor');
        }
        
        state.recordingMimeType = mimeType;
        // console.log(`ğŸ¥ [Recording] Using mimeType: ${mimeType}`);
        
        const options = mimeType ? { mimeType } : undefined;
        state.mediaRecorder = new MediaRecorder(stream, options);
        state.recordedChunks = [];
        
        state.mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) {
            state.recordedChunks.push(e.data);
          }
        };
        
        state.mediaRecorder.onstart = () => {
            // Recording started
        };
    
        state.mediaRecorder.onerror = (e) => {
            console.error('ğŸ¥ [Recording] Error:', e);
        };
        
        state.mediaRecorder.start();
      } catch (e) {
        console.error('ğŸ¥ [Recording] Failed to start:', e);
        // toast('ÙØ´Ù„ Ø¨Ø¯Ø¡ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ', 'error');
      }
    }
    
    function stopRecording(callback) {
      if (state.mediaRecorder && state.mediaRecorder.state !== 'inactive') {
        state.mediaRecorder.onstop = () => {
          const blobType = state.recordingMimeType || 'video/webm';
          const blob = new Blob(state.recordedChunks, { type: blobType });
          // console.log(`ğŸ¥ [Recording] Finished. Blob size: ${blob.size}, Type: ${blobType}`);
          if (callback) callback(blob);
        };
        state.mediaRecorder.stop();
      } else {
        if (callback) callback(null);
      }
    }
    
    function drawWinnerOverlay(winner) {
      const canvas = document.getElementById('winner-roulette-wheel');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const W = canvas.width;
      const H = canvas.height;
      
      // Draw semi-transparent overlay
      ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
      ctx.fillRect(0, 0, W, H);
      
      // Draw Winner Info
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Icon/Emoji
      ctx.font = '60px Arial';
      ctx.fillText('ğŸ‰', W/2, H/2 - 100);
      
      // "Winner" Label
      ctx.font = 'bold 32px Arial';
      ctx.fillStyle = '#fbbf24'; // Amber
      ctx.fillText('Ø§Ù„ÙØ§Ø¦Ø²', W/2, H/2 - 40);
      
      // Name
      ctx.font = 'bold 40px Arial';
      ctx.fillStyle = '#ffffff';
      ctx.fillText(winner.name, W/2, H/2 + 20);
      
      // Account
      ctx.font = '24px Arial';
      ctx.fillStyle = '#94a3b8';
      ctx.fillText(`Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: ${winner.account}`, W/2, H/2 + 70);
      
      // Agent Name
      if (state.selectedAgent) {
        ctx.font = '18px Arial';
        ctx.fillStyle = '#64748b';
        ctx.fillText(`Ø§Ù„ÙˆÙƒÙŠÙ„: ${state.selectedAgent.name}`, W/2, H/2 + 120);
      }
    }
    
    function showVideoPreview(blob, winner) {
      /* console.log('ğŸ¥ [Video Preview] Starting showVideoPreview');
      console.log('ğŸ¥ [Video Preview] Blob:', blob);
      console.log('ğŸ¥ [Video Preview] Winner:', winner); */
      
      if (!blob) {
        console.warn('ğŸ¥ [Video Preview] No blob provided, falling back to normal flow');
        // Fallback to normal flow if recording failed
        if(state.autoMode){ showAutoWinnerModal(winner); } else { showWinnerModal(winner); }
        return;
      }
    
      const url = URL.createObjectURL(blob);
      
      const overlay = document.createElement('div');
      overlay.id = 'video-preview-modal';
      overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.9); z-index: 11000;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        animation: fadeIn 0.3s ease;
      `;
      
      // Create container
      const container = document.createElement('div');
      container.style.cssText = 'background: #1e293b; padding: 20px; border-radius: 16px; max-width: 90%; width: 500px; text-align: center; border: 1px solid #334155;';
      
      // Title
      const title = document.createElement('h3');
      title.style.cssText = 'color: white; margin-bottom: 15px;';
      title.textContent = 'Ù…Ø¹Ø§ÙŠÙ†Ø© ÙÙŠØ¯ÙŠÙˆ Ø§Ù„ÙÙˆØ²';
      container.appendChild(title);
    
      // Video Element
      const video = document.createElement('video');
      video.id = 'preview-video-el';
      video.controls = true;
      video.autoplay = false;
      video.muted = false;
      video.loop = true;
      video.playsInline = true;
      video.style.cssText = 'width: 100%; border-radius: 8px; margin-bottom: 20px; max-height: 400px;';
      // Set src directly to avoid innerHTML safety checks
      video.src = url;
      container.appendChild(video);
    
      // Buttons Container
      const btnContainer = document.createElement('div');
      btnContainer.style.cssText = 'display: flex; gap: 10px; justify-content: center;';
    
      // Save Button
      const saveBtn = document.createElement('button');
      saveBtn.id = 'save-video-btn';
      saveBtn.style.cssText = 'background: #10b981; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 16px;';
      saveBtn.innerHTML = '<i class="fas fa-save"></i> Ø­ÙØ¸ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ÙˆØ§Ù„Ù…ØªØ§Ø¨Ø¹Ø©';
      btnContainer.appendChild(saveBtn);
    
      // Skip Winner Button (Cancel Winner)
      const skipWinnerBtn = document.createElement('button');
      skipWinnerBtn.id = 'skip-winner-btn';
      skipWinnerBtn.style.cssText = 'background: #ef4444; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 16px;';
      skipWinnerBtn.innerHTML = '<i class="fas fa-redo"></i> ØªØ®Ø·ÙŠ Ø§Ù„ÙØ§Ø¦Ø²';
      btnContainer.appendChild(skipWinnerBtn);
    
      container.appendChild(btnContainer);
      overlay.appendChild(container);
      document.body.appendChild(overlay);
    
      // Load metadata and prepare video
      video.onloadedmetadata = () => {
        // console.log('ğŸ¥ [Preview] Metadata loaded, duration:', video.duration);
      };
      video.onerror = (e) => {
          console.error('ğŸ¥ [Preview] Video error:', video.error);
          const errDiv = document.createElement('div');
          errDiv.style.color = '#ef4444';
          errDiv.style.padding = '10px';
          errDiv.style.marginBottom = '20px';
          
          const msgText = document.createElement('div');
          msgText.textContent = 'Ø¹Ø°Ø±Ø§Ù‹ØŒ ØªØ¹Ø°Ø± ØªØ´ØºÙŠÙ„ Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…ØªØµÙØ­.';
          errDiv.appendChild(msgText);
    
          const downloadLink = document.createElement('a');
          downloadLink.href = url;
          downloadLink.download = 'winner-preview.webm';
          downloadLink.style.cssText = 'color: #3b82f6; text-decoration: underline; margin-top: 5px; display: inline-block;';
          downloadLink.innerHTML = '<i class="fas fa-download"></i> ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù„Ù„Ù…Ø´Ø§Ù‡Ø¯Ø©';
          errDiv.appendChild(downloadLink);
    
          video.style.display = 'none';
          container.insertBefore(errDiv, video);
      };
      
      const cleanup = () => {
        document.body.removeChild(overlay);
        URL.revokeObjectURL(url);
      };
      
      skipWinnerBtn.addEventListener('click', () => {
        cleanup();
        // Do NOT proceed to showWinnerModal.
        // Just close the preview. The winner is not added to state.winners yet (that happens in showWinnerModal).
        // We might want to re-spin if in auto mode or queue, similar to the other skip button.
        // But for now, just closing effectively "skips" this winner selection.
        toast('ØªÙ… ØªØ®Ø·ÙŠ Ø§Ù„ÙØ§Ø¦Ø² ÙˆØ¥Ù„ØºØ§Ø¡ Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±', 'info');
      });
      
      saveBtn.addEventListener('click', async () => {
        // Ø­ÙØ¸ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø«Ù… ÙØªØ­ Ù†Ø§ÙØ°Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙØ§Ø¦Ø² Ø¨Ø´ÙƒÙ„ Ù…ÙˆØ«ÙˆÙ‚
        /* console.log('ğŸ¬ [Save Video Continue] Button clicked');
        console.log('ğŸ¬ [Save Video Continue] Winner:', winner);
        console.log('ğŸ¬ [Save Video Continue] Auto mode:', state.autoMode);
        console.log('ğŸ¬ [Save Video Continue] Blob:', blob); */
        
        try {
          state.pendingVideoBlob = blob;
          // console.log('ğŸ¬ [Save Video Continue] Pending video blob stored');
          
          // ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…ÙˆØ¯Ø§Ù„ Ù‚Ø¨Ù„ Ø§Ù„ÙØªØ­
          try { 
            // console.log('ğŸ¬ [Save Video Continue] Ensuring winner modal structure...');
            ensureWinnerModalStructure(); 
            // console.log('ğŸ¬ [Save Video Continue] Winner modal structure ensured');
          } catch(e) {
            console.error('ğŸ¬ [Save Video Continue] Failed to ensure modal structure:', e);
          }
          
          // console.log('ğŸ¬ [Save Video Continue] Calling cleanup...');
          cleanup();
          // console.log('ğŸ¬ [Save Video Continue] Cleanup done');
          
          // Ø§ÙØªØ­ Ø§Ù„Ù…ÙˆØ¯Ø§Ù„ Ø¨Ø¹Ø¯ Ø¥Ø²Ø§Ù„Ø© Ø·Ø¨Ù‚Ø© Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ù„Ø¶Ù…Ø§Ù† Ø§Ù„Ø·Ø¨Ù‚Ø§Øª/z-index ØµØ­ÙŠØ­Ø©
          // console.log('ğŸ¬ [Save Video Continue] Setting timeout to open modal...');
          setTimeout(() => {
            try {
              // console.log('ğŸ¬ [Save Video Continue] Timeout callback executing...');
              if (state.autoMode) {
                // console.log('ğŸ¬ [Save Video Continue] Opening AUTO winner modal');
                showAutoWinnerModal(winner);
              } else {
                // console.log('ğŸ¬ [Save Video Continue] Opening MANUAL winner modal');
                showWinnerModal(winner);
              }
              // console.log('ğŸ¬ [Save Video Continue] Modal opened successfully');
            } catch (e) {
              console.error('ğŸ¬ [Save Video Continue] Failed to open winner modal after video save:', e);
              // ÙƒØ­Ù„ Ø£Ø®ÙŠØ±ØŒ Ø£Ø¹Ø¯ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ÙˆØ¯Ø§Ù„ ÙˆØ§ÙØªØ­Ù‡ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
              try { ensureWinnerModalStructure(); } catch {}
              if (state.autoMode) {
                showAutoWinnerModal(winner);
              } else {
                showWinnerModal(winner);
              }
            }
          }, 50);
        } catch (e) {
          console.error('ğŸ¬ [Save Video Continue] CRITICAL ERROR in flow:', e);
          toast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©. Ø³Ù†ÙØªØ­ Ù†Ù…ÙˆØ°Ø¬ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙØ§Ø¦Ø² Ù…Ø¨Ø§Ø´Ø±Ø©.', 'warning');
          // ÙÙ„Ùˆ Ø¨Ø¯ÙŠÙ„ Ù…Ø¨Ø§Ø´Ø±
          try { ensureWinnerModalStructure(); } catch {}
          if (state.autoMode) {
            showAutoWinnerModal(winner);
          } else {
            showWinnerModal(winner);
          }
        }
      });
    }
    
    function checkCompletion() {
      // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¹Ø¯Ø¯ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø§Ù„Ù…Ø­Ù„ÙŠÙŠÙ† ÙÙ‚Ø· (state.winners.length)
      const currentTotal = state.winners.length;
      if (state.activeCompetition && currentTotal >= state.activeCompetition.totalRequired) {
        if (state.reportSent) {
          const agentLabel = state.selectedAgent ? state.selectedAgent.name : 'Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„';
          // Ø¹Ø±Ø¶ Ø¥Ø´Ø¹Ø§Ø± Ø¨Ø³ÙŠØ· Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† modal
          setTimeout(() => {
            toast(`ØªÙ… Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† (${state.activeCompetition.totalRequired}) Ù„Ù„ÙˆÙƒÙŠÙ„ ${agentLabel}`, 'success');
          }, 500);
        } else {
          // Do not show completion text until winners are sent to agent
        }
      }
    }
    
    function animateSpin(onDone) {
      function step(ts) {
        const t = Math.min(1, (ts - state.spinStart)/state.spinDuration);
        // Composite easing: Ø³Ø±ÙŠØ¹ ÙÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ø«Ù… ØªØ¨Ø§Ø·Ø¤ ÙˆØ§Ø¶Ø­
        const eased = compositeEase(t);
        state.angle = state.startAngle + (state.targetAngle - state.startAngle) * eased;
        drawWheel();
        if (t < 1) {
          requestAnimationFrame(step);
        } else {
          // Snap to exact target to be safe
          state.angle = state.targetAngle;
          drawWheel();
          onDone && onDone();
        }
      }
      requestAnimationFrame(step);
    }
    
    function easeOutCubic(x){ return 1 - Math.pow(1 - x, 3); }
    function easeInQuad(x){ return x*x; }
    function easeOutQuint(x){ return 1 - Math.pow(1 - x, 5); }
    function compositeEase(x){
      // First 30% accelerate (easeInQuad), remaining 70% decelerate (easeOutQuint) normalized
      if(x <= 0.3){ return 0.3 * easeInQuad(x/0.3); }
      const rest = (x - 0.3)/0.7; // 0..1
      return 0.3 + 0.7 * easeOutQuint(rest);
    }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function normalizeAngle(a){
      let v = a % (Math.PI*2);
      if (v > Math.PI) v -= Math.PI*2;
      if (v < -Math.PI) v += Math.PI*2;
      return v;
    }
    function pickIndexByAngle(n, angle) {
      // After rotating canvas by -angle, the fixed pointer at PI/2 corresponds
      // to an effective pointer angle of PI/2 + angle in wheel coordinates.
      // Slices span [i*slice + PI/2, (i+1)*slice + PI/2). Therefore the index
      // is simply floor(angle / slice) modulo n when using angle in [0, 2Ï€).
      // ADJUSTMENT: Pointer is at TOP (3PI/2), so we shift by PI.
      const twoPi = Math.PI * 2;
      const slice = twoPi / n;
      let a = (angle + Math.PI) % twoPi;
      if (a < 0) a += twoPi;
      let index = Math.floor(a / slice);
      return index % n;
    }
    
    function getAutoPrizeInfo(candidateAccount) {
      if (!state.activeCompetition) {
        return { prizeType: 'trading', prizeValue: 0, prizeUnit: '$' };
      }
    
      const {
        tradingWinnersRequired,
        depositWinnersRequired,
        prizePerWinner,
        depositBonusPercentage
      } = state.activeCompetition;
    
      const currentDepositWinners = state.winners.filter(w => w.prizeType === 'deposit').length;
      const currentTradingWinners = state.winners.filter(w => w.prizeType === 'trading').length;
    
      let prizeType = 'trading';
      
      // Prioritize Trading Bonus ($) first, then Deposit Bonus (%)
      if (currentTradingWinners < tradingWinnersRequired) {
        prizeType = 'trading';
      } else if (currentDepositWinners < depositWinnersRequired) {
        prizeType = 'deposit';
      }
    
      let prizeValue = 0;
      let prizeUnit = '$';
    
      if (prizeType === 'deposit') {
        prizeValue = depositBonusPercentage || 0;
        prizeUnit = '%';
      } else {
        prizeValue = prizePerWinner || 0;
        prizeUnit = '$';
      }
    
      return { prizeType, prizeValue, prizeUnit };
    }
    
    function renderParticipants() {
      const container = document.getElementById('participants-list');
      if (!container) return;
      // Ensure each entry has a stable sequence number based on current order
      try {
        for (let i = 0; i < state.entries.length; i++) {
          state.entries[i].seq = i + 1;
        }
      } catch(e) {}
      if (state.entries.length === 0) {
        container.innerHTML = '<div class="empty">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø³Ù…Ø§Ø¡</div>';
        return;
      }
      const term = (state.filterTerm||'').toLowerCase();
      const list = state.entries.filter(e => !term || e.name.toLowerCase().includes(term) || e.account.includes(term));
      container.innerHTML = list.map((e,i) => `
        <div class="wr-item ${e.selected?'wr-item-selected':''}" data-id="${e.id}" title="${e.label}">
          <div class="wr-item-body">
            <div class="wr-item-label"><span class="wr-badge-num">${e.seq || (i+1)}</span> ${e.name}</div>
            <div class="wr-item-meta">${e.account}</div>
          </div>
          <div class="wr-item-actions">
            ${e.selected ? '<span class="wr-tag wr-tag-winner">ÙØ§Ø¦Ø²</span>' : ''}
            <button class="wr-icon-btn" data-action="remove" title="Ø¥Ø²Ø§Ù„Ø©"><i class="fas fa-times"></i></button>
          </div>
        </div>
      `).join('');
    
      container.querySelectorAll('[data-action="remove"]').forEach(btn => {
        btn.addEventListener('click', (ev) => {
          const el = ev.currentTarget.closest('.participant-item');
          const id = el?.dataset.id;
          if (!id) return;
          state.entries = state.entries.filter(x => x.id !== id);
          state.winners = state.winners.filter(x => x.id !== id);
          renderParticipants();
          renderWinners();
          drawWheel();
        });
      });
    }
    
    function renderWinners() {
      const bottomContainer = document.getElementById('winners-list-bottom');
      
      if (!bottomContainer) return;

      const activeCompetitionId = state.activeCompetition?.id || null;
      if (state.winners.length === 0 && activeCompetitionId) {
        const stagedForCompetition = getStagedWinnersForCompetition(activeCompetitionId);
        if (stagedForCompetition.length > 0) {
          state.winners = stagedForCompetition.map(w => ({ ...w }));
        }
      }
      
      // Separate winners by prize type
      const depositWinners = state.winners.filter(w => w.prizeType === 'deposit' || w.prizeType === 'deposit_prev');
      const tradingWinners = state.winners.filter(w => w.prizeType === 'trading');
      
      let html = '';

      if (state.winners.length === 0) {
        html += '<div class="wr-winner-empty"><i class="fas fa-trophy" style="font-size:2rem;opacity:.3;margin-bottom:8px;"></i><p>Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø³Ù…Ø§Ø¡</p></div>';
      }
    
      // Add "Send All" button at the top of the bottom container if there are winners
      // Only show these buttons if the competition is NOT approved yet
      if (state.winners.length > 0 && !state.reportSent && !state.noWinnersApproved) {
          html += `
          <div style="width:100%; margin-bottom: 20px;">
            <button id="send-all-winners-btn" class="wr-btn" style="
              width: 100%;
              background: #0ea5e9;
              color: #fff;
              border: none;
              padding: 12px 16px;
              font-size: 1rem;
              font-weight: 600;
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 10px;
              border-radius: 999px;
              cursor: pointer;
              transition: transform 0.2s ease, box-shadow 0.2s ease;
              box-shadow: 0 4px 12px rgba(14, 165, 233, 0.35);
            " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 6px 16px rgba(14, 165, 233, 0.45)'" 
               onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(14, 165, 233, 0.35)'">
              <i class="fas fa-paper-plane" style="font-size: 1em;"></i> 
              <span>Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙƒÙ„ Ù„Ù„ÙˆÙƒÙŠÙ„ (${state.winners.length})</span>
            </button>
            <div style="height: 15px;"></div>
            <button id="send-winners-ids-btn" style="
              width: 100%;
              background: #22c55e;
              color: #fff;
              border: none;
              padding: 12px 16px;
              font-size: 1rem;
              font-weight: 600;
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 10px;
              border-radius: 999px;
              cursor: pointer;
              transition: transform 0.2s ease, box-shadow 0.2s ease;
              box-shadow: 0 4px 12px rgba(34, 197, 94, 0.35);
            " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 6px 16px rgba(34, 197, 94, 0.45)'" 
               onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(34, 197, 94, 0.35)'">
              <i class="fas fa-id-card" style="font-size: 1em;"></i> 
              <span>Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù‡ÙˆÙŠØ© ÙˆØ§Ù„ÙƒÙ„ÙŠØ´Ø© Ù„Ø¬Ø±ÙˆØ¨ Agent competitions (${state.winners.length})</span>
            </button>
          </div>
          `;
      }
      
      // Deposit bonus section
      if (depositWinners.length > 0) {
        html += `<div class="wr-prize-section">
          <h4 class="wr-prize-section-title"><i class="fas fa-dollar-sign"></i> Ø¨ÙˆÙ†Øµ Ø§Ù„Ø¥ÙŠØ¯Ø§Ø¹ (${depositWinners.length})</h4>
          <div class="wr-winners-grid">`;
        
        depositWinners.forEach((w, i) => {
          const warnMeetChecked = w.includeWarnMeet ? 'checked' : '';
          const warnPrevChecked = w.includeWarnPrev ? 'checked' : '';
          
          let prizeDisplay = '';
          if (w.prizeType === 'deposit_prev') {
              prizeDisplay = `${w.prizeValue || 0}% Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹ ÙƒÙˆÙ†Ù‡ ÙØ§Ø¦Ø² Ù…Ø³Ø¨Ù‚Ø§Ù‹ Ø¨Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ`;
          } else {
              prizeDisplay = `${w.prizeValue || 0}% Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹`;
          }

          html += `
            <div class="wr-winner-card" data-id="${w.id}">
              <div class="wr-winner-card-badge">#${i+1}</div>
              <div class="wr-winner-card-body">
                <div class="wr-winner-card-name" style="color: #000000; font-weight: bold; font-size: 1.1rem;">Ø§Ù„Ø§Ø³Ù…: ${w.name}</div>
                <div class="wr-winner-card-account">Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: ${w.account}</div>
                ${w.email ? `<div class="wr-winner-card-email"><i class="fas fa-envelope"></i> ${w.email}</div>` : ''}
                <div class="wr-winner-card-prize"><i class="fas fa-gift"></i> ${prizeDisplay}</div>
                ${w.agent ? `<div class="wr-winner-card-agent"><i class="fas fa-user-tie"></i> <a href="#profile/${w.agent.id}" style="color:inherit;text-decoration:underline;cursor:pointer;">${w.agent.name} (#${w.agent.agentId})</a></div>` : ''}
                <div class="wr-winner-warnings">
                  <label class="wr-toggle-label" style="display:flex;align-items:center;gap:6px;font-size:0.85rem;">
                    <input type="checkbox" data-warn="meet" data-id="${w.id}" ${w.includeWarnMeet ? 'checked' : ''}> âš ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ Ù…Ø¹ Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù†Ù‡ Ø£ÙˆÙ„Ø§Ù‹
                  </label>
                  <label class="wr-toggle-label" style="display:flex;align-items:center;gap:6px;font-size:0.85rem;">
                    <input type="checkbox" data-warn="prev" data-id="${w.id}" ${w.includeWarnPrev ? 'checked' : ''}> â€¼ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ø£ÙˆÙ„Ù‹Ø§ Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¹Ù…ÙŠÙ„ØŒ Ø­ÙŠØ« Ø³Ø¨Ù‚ Ø£Ù† ÙØ§Ø² Ø¨Ø¬Ø§Ø¦Ø²Ø© (Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ) Ø®Ù„Ø§Ù„ Ø§Ù„Ø£ÙŠØ§Ù… Ø§Ù„Ù…Ø§Ø¶ÙŠØ©
                  </label>
                </div>
    
              </div>
              <div class="wr-winner-card-actions">
                <button class="wr-icon-btn" data-send="${w.id}" title="Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„ÙˆÙƒÙŠÙ„"><i class="fas fa-paper-plane"></i></button>
                <button class="wr-icon-btn" data-copy="${w.name} â€” ${w.account} â€” ${w.email} â€” ${w.prizeValue}%" title="Ù†Ø³Ø®"><i class="fas fa-copy"></i></button>
                <button class="wr-icon-btn" data-edit="${w.id}" title="ØªØ¹Ø¯ÙŠÙ„" style="background: #3b82f6; color: white;"><i class="fas fa-edit"></i></button>
                <button class="wr-icon-btn" data-restore="${w.id}" title="Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ù„Ù„Ø±ÙˆÙ„ÙŠØª" style="width:auto; padding:0 10px; gap:6px;"><i class="fas fa-redo"></i> Ø§Ø³ØªØ±Ø¬Ø§Ø¹</button>
                <button class="wr-icon-btn" data-delete="${w.id}" title="Ø­Ø°Ù" style="background: #ef4444; color: white;"><i class="fas fa-trash"></i></button>
              </div>
            </div>`;
        });
        
        html += '</div></div>';
      }
      
      // Trading bonus section
      if (tradingWinners.length > 0) {
        html += `<div class="wr-prize-section">
          <h4 class="wr-prize-section-title"><i class="fas fa-chart-line"></i> Ø¨ÙˆÙ†Øµ Ø§Ù„ØªØ¯Ø§ÙˆÙ„ÙŠ (${tradingWinners.length})</h4>
          <div class="wr-winners-grid">`;
    
    
        tradingWinners.forEach((w, i) => {
          html += `
            <div class="wr-winner-card" data-id="${w.id}">
              <div class="wr-winner-card-badge">#${i+1}</div>
              <div class="wr-winner-card-body">
                <div class="wr-winner-card-name" style="color: #000000; font-weight: bold; font-size: 1.1rem;">Ø§Ù„Ø§Ø³Ù…: ${w.name}</div>
                <div class="wr-winner-card-account">Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: ${w.account}</div>
                ${w.email ? `<div class="wr-winner-card-email"><i class="fas fa-envelope"></i> ${w.email}</div>` : ''}
    
                <div class="wr-winner-card-prize"><i class="fas fa-gift"></i> $${w.prizeValue || 0} Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ</div>
                ${w.agent ? `<div class="wr-winner-card-agent"><i class="fas fa-user-tie"></i> <a href="#profile/${w.agent.id}" style="color:inherit;text-decoration:underline;cursor:pointer;">${w.agent.name} (#${w.agent.agentId})</a></div>` : ''}
                <div class="wr-winner-warnings">
                  <label class="wr-toggle-label" style="display:flex;align-items:center;gap:6px;font-size:0.85rem;">
                    <input type="checkbox" data-warn="meet" data-id="${w.id}" ${w.includeWarnMeet ? 'checked' : ''}> âš ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ Ù…Ø¹ Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù†Ù‡ Ø£ÙˆÙ„Ø§Ù‹
                  </label>
                  <label class="wr-toggle-label" style="display:flex;align-items:center;gap:6px;font-size:0.85rem;">
                    <input type="checkbox" data-warn="prev" data-id="${w.id}" ${w.includeWarnPrev ? 'checked' : ''}> â€¼ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ø£ÙˆÙ„Ù‹Ø§ Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¹Ù…ÙŠÙ„ØŒ Ø­ÙŠØ« Ø³Ø¨Ù‚ Ø£Ù† ÙØ§Ø² Ø¨Ø¬Ø§Ø¦Ø²Ø© (Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ) Ø®Ù„Ø§Ù„ Ø§Ù„Ø£ÙŠØ§Ù… Ø§Ù„Ù…Ø§Ø¶ÙŠØ©
                  </label>
                </div>
              </div>
              <div class="wr-winner-card-actions">
                <button class="wr-icon-btn" data-send="${w.id}" title="Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„ÙˆÙƒÙŠÙ„"><i class="fas fa-paper-plane"></i></button>
                <button class="wr-icon-btn" data-copy="${w.name} â€” ${w.account} â€” ${w.email} â€” $${w.prizeValue}" title="Ù†Ø³Ø®"><i class="fas fa-copy"></i></button>
                <button class="wr-icon-btn" data-edit="${w.id}" title="ØªØ¹Ø¯ÙŠÙ„" style="background: #3b82f6; color: white;"><i class="fas fa-edit"></i></button>
                <button class="wr-icon-btn" data-restore="${w.id}" title="Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ù„Ù„Ø±ÙˆÙ„ÙŠØª" style="width:auto; padding:0 10px; gap:6px;"><i class="fas fa-redo"></i> Ø§Ø³ØªØ±Ø¬Ø§Ø¹</button>
                <button class="wr-icon-btn" data-delete="${w.id}" title="Ø­Ø°Ù" style="background: #ef4444; color: white;"><i class="fas fa-trash"></i></button>
              </div>
            </div>`;
        });
        
        html += '</div></div>';
      }
      
        html += `
          <div id="approval-section" style="width:100%; margin-top: 20px; border-top: 1px solid #334155; padding-top: 20px;">
              <h4 class="wr-prize-section-title">Ø¥Ø¹ØªÙ…Ø§Ø¯ Ù†Ù‡Ø§Ø¦ÙŠ</h4>
              <div style="display: flex; gap: 10px;">
                  <button id="approve-winners-btn" class="wr-btn wr-btn-success" style="display: ${state.winners.length > 0 ? 'inline-flex' : 'none'}">
                      <i class="fas fa-check-double"></i> Ø§Ø¹ØªÙ…Ø§Ø¯ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† (${state.winners.length})
                  </button>
                  <button id="approve-no-winners-btn" class="wr-btn wr-btn-danger">
                      <i class="fas fa-times-circle"></i> Ø§Ø¹ØªÙ…Ø§Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¨Ø¯ÙˆÙ† ÙØ§Ø¦Ø²ÙŠÙ†
                  </button>
              </div>
              <p style="font-size: 0.8rem; color: #9ca3af; margin-top: 10px;">
                  Ø³ÙŠØ¤Ø¯ÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø¥Ù„Ù‰ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙˆÙ…Ù†Ø¹ Ø§Ø®ØªÙŠØ§Ø± ÙØ§Ø¦Ø²ÙŠÙ† Ø¬Ø¯Ø¯.
              </p>
          </div>
      `;

        bottomContainer.innerHTML = html;

        // Bind events for new buttons
        const approveBtn = document.getElementById('approve-winners-btn');
        approveBtn?.addEventListener('click', async () => {
            console.log('[Approve Winners] Button clicked. Winners count:', state.winners.length);
            if (!state.activeCompetition || !state.activeCompetition.id) {
                console.error('[Approve Winners] Active competition state missing:', state.activeCompetition);
                toast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù†Ø´Ø·Ø© Ù„Ø§Ø¹ØªÙ…Ø§Ø¯Ù‡Ø§ (Ù…Ø¹Ø±Ù Ù…ÙÙ‚ÙˆØ¯).', 'error');
                return;
            }
            
            // Direct approval without confirmation modal
            try {
                console.log('[Approve Winners] Sending approval request for competition:', state.activeCompetition.id);
                const authedFetch = window.authedFetch || fetch;
                const resp = await authedFetch(`/api/competitions/${state.activeCompetition.id}/complete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        winners: state.winners.map(w => w._id).filter(Boolean)
                    })
                });
                
                if (resp.ok) {
                    console.log('[Approve Winners] Approval successful.');
                    toast('ØªÙ… Ø§Ø¹ØªÙ…Ø§Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¨Ù†Ø¬Ø§Ø­', 'success');
                    clearStagedWinnersForCompetition(state.activeCompetition.id);
                    
                    // Redirect to agent competitions page
                    if (state.selectedAgent && state.selectedAgent.id) {
                        console.log('[Approve Winners] Redirecting to agent profile/competitions:', state.selectedAgent.id);
                        // Using the standard profile route which usually shows competitions
                        window.location.hash = `#profile/${state.selectedAgent.id}`;
                    } else {
                        console.warn('[Approve Winners] No selected agent found for redirect. Reloading page.');
                        setTimeout(() => window.location.reload(), 1500);
                    }

                    // Clear local state
                    state.winners = [];
                    state.entries = [];
                    state.activeCompetition = null;
                    saveSession();
                    renderParticipants();
                    renderWinners();
                    updateCounts();
                } else {
                    const err = await resp.json();
                    console.error('[Approve Winners] Approval failed:', err);
                    toast(`ÙØ´Ù„ Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯: ${err.message} ${err.error || ''}`, 'error');
                }
            } catch (e) {
                console.error('[Approve Winners] Exception during approval:', e);
                toast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯', 'error');
            }
        });

        const approveNoWinnersBtn = document.getElementById('approve-no-winners-btn');
        approveNoWinnersBtn?.addEventListener('click', async () => {
            console.log('[Approve No Winners] Button clicked.');
            
            // Check if there are winners
            if (state.winners.length > 0) {
                console.warn('[Approve No Winners] Blocked: There are existing winners.');
                toast('Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø¹ØªÙ…Ø§Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¨Ø¯ÙˆÙ† ÙØ§Ø¦Ø²ÙŠÙ† Ù„ÙˆØ¬ÙˆØ¯ ÙØ§Ø¦Ø²ÙŠÙ† ÙÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©. ÙŠØ±Ø¬Ù‰ Ø­Ø°ÙÙ‡Ù… Ø£ÙˆÙ„Ø§Ù‹.', 'error');
                return;
            }

            if (!state.activeCompetition || !state.activeCompetition.id) {
                console.error('[Approve No Winners] Active competition state missing:', state.activeCompetition);
                toast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù†Ø´Ø·Ø© Ù„Ø§Ø¹ØªÙ…Ø§Ø¯Ù‡Ø§ (Ù…Ø¹Ø±Ù Ù…ÙÙ‚ÙˆØ¯).', 'error');
                return;
            }
            
            // Direct approval without confirmation modal
            try {
                console.log('[Approve No Winners] Sending approval request (no winners) for competition:', state.activeCompetition.id);
                const authedFetch = window.authedFetch || fetch;
                const resp = await authedFetch(`/api/competitions/${state.activeCompetition.id}/complete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        noWinners: true
                    })
                });
                
                if (resp.ok) {
                    console.log('[Approve No Winners] Approval successful.');
                    toast('ØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¨Ù†Ø¬Ø§Ø­', 'success');
                    clearStagedWinnersForCompetition(state.activeCompetition.id);
                    state.winners = [];
                    state.entries = [];
                    state.activeCompetition = null;
                    saveSession();
                    renderParticipants();
                    renderWinners();
                    updateCounts();
                    setTimeout(() => window.location.reload(), 1500);
                } else {
                    const err = await resp.json();
                    console.error('[Approve No Winners] Approval failed:', err);
                    toast(`ÙØ´Ù„ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚: ${err.message} ${err.error || ''}`, 'error');
                }
            } catch (e) {
                console.error('[Approve No Winners] Exception during approval:', e);
                toast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚', 'error');
            }
        });

        // Bind events
        const sendAllBtn = document.getElementById('send-all-winners-btn');
        if (sendAllBtn) {
            sendAllBtn.addEventListener('click', sendWinnersReport);
        }

        const sendIDsBtn = document.getElementById('send-winners-ids-btn');
        if (sendIDsBtn) {
            sendIDsBtn.addEventListener('click', sendWinnersWithIDsToAgent);
        }

        bottomContainer.querySelectorAll('[data-copy]').forEach(btn => {
            btn.addEventListener('click', handleCopyClick);
        });
        bottomContainer.querySelectorAll('[data-edit]').forEach(btn => {
            btn.addEventListener('click', handleEditClick);
        });
        bottomContainer.querySelectorAll('input[data-warn]').forEach(input => {
            input.addEventListener('change', handleWinnerWarningToggle);
        });
        bottomContainer.querySelectorAll('[data-restore]').forEach(btn => {
            btn.addEventListener('click', handleRestoreClick);
        });
        bottomContainer.querySelectorAll('[data-send]').forEach(btn => {
            btn.addEventListener('click', handleSendClick);
        });
        bottomContainer.querySelectorAll('[data-delete]').forEach(btn => {
            btn.addEventListener('click', handleDeleteClick);
        });
    }function handleCopyClick(ev) {
      const text = ev.currentTarget.getAttribute('data-copy');
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(() => {
          toast('ØªÙ… Ø§Ù„Ù†Ø³Ø®');
        }).catch(() => {
          toast('ÙØ´Ù„ Ø§Ù„Ù†Ø³Ø®', 'error');
        });
      } else {
        toast('Ø§Ù„Ù†Ø³Ø® ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…', 'error');
      }
    }
    
    function handleReturnClick(ev) {
      const id = ev.currentTarget.getAttribute('data-return');
      
      // Find the winner to return
      const winnerIndex = state.winners.findIndex(w => w.id === id);
      if (winnerIndex === -1) return;
      
      const winner = state.winners[winnerIndex];
      
      // Remove from winners list
      state.winners.splice(winnerIndex, 1);
      
      // Check if already in entries
      let entry = state.entries.find(e => e.id === id);
      
      if (!entry) {
          // Re-create entry
          entry = {
              id: winner.id,
              name: winner.name,
              account: winner.account,
              label: winner.label || winner.name,
              selected: false,
              seq: winner.seq
          };
          state.entries.push(entry);
      } else {
          entry.selected = false;
      }
      
      // Update the textarea to reflect the returned participant
      const ta = document.getElementById('participants-input');
      if (ta) {
          ta.value = state.entries.map(e => `${e.name} â€” ${e.account}`).join('\n');
      }

      // Decrement current winners count in active competition
      if (state.activeCompetition && state.activeCompetition.currentWinners > 0) {
          state.activeCompetition.currentWinners--;
      }

      renderParticipants(); 
      renderWinners(); 
      updateCounts(); 
      drawWheel(); 
      saveSession();
      removeStagedWinner(id, state.activeCompetition?.id || null);
      toast('ØªÙ… Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„ÙØ§Ø¦Ø² Ù„Ù„Ø±ÙˆÙ„ÙŠØª', 'info');
    }

    function handleDeleteClick(ev) {
      const id = ev.currentTarget.getAttribute('data-delete');
      if (!id) return;
      
      if (!confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„ÙØ§Ø¦Ø²ØŸ')) return;
      
      // Remove from winners list
      state.winners = state.winners.filter(w => w.id !== id);
      
      // Delete video from DB
      deleteVideoFromDB(id).catch(e => console.error('Failed to delete video', e));
      
      saveSession();
      removeStagedWinner(id, state.activeCompetition?.id || null);
      renderWinners();
      updateCounts();
      toast('ØªÙ… Ø­Ø°Ù Ø§Ù„ÙØ§Ø¦Ø²', 'success');
    }
    
    function handleRestoreClick(ev) {
      const id = ev.currentTarget.getAttribute('data-restore');
      const winner = state.winners.find(w => w.id === id);
      
      if (!winner) {
        toast('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ÙØ§Ø¦Ø²', 'error');
        return;
      }
      
      console.log('[Restore] Request to restore winner:', winner);

      showConfirmModal(
        `Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ø³ØªØ±Ø¬Ø§Ø¹ <strong>${winner.name}</strong> Ø¥Ù„Ù‰ Ø§Ù„Ø±ÙˆÙ„ÙŠØªØŸ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ø®ØªÙŠØ§Ø±Ù‡ ÙƒÙØ§Ø¦Ø² ÙˆØ¥Ø¹Ø§Ø¯ØªÙ‡ Ù„Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†.`,
        async () => {
          console.log('[Restore] User confirmed restoration. Processing...');
          
          // Delete video from DB
          deleteVideoFromDB(id).catch(e => console.error('Failed to delete video', e));

          // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ÙØ§Ø¦Ø² Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†
          const initialWinnersCount = state.winners.length;
          state.winners = state.winners.filter(w => w.id !== id);
          console.log(`[Restore] Winners count: ${initialWinnersCount} -> ${state.winners.length}`);
          
          // Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø­Ø§Ù„Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ† Ù„Ø¶Ù…Ø§Ù† Ø£Ù† Ø§Ù„Ø¬Ù…ÙŠØ¹ Ù…ØªØ§Ø­ Ù„Ù„Ø±ÙˆÙ„ÙŠØª Ù…Ø§ Ø¹Ø¯Ø§ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø§Ù„Ø­Ø§Ù„ÙŠÙŠÙ†
          const currentWinnerIds = new Set(state.winners.map(w => w.id));
          
          // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„ÙØ§Ø¦Ø² Ø§Ù„Ù…Ø³ØªØ±Ø¬Ø¹ ÙÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©ØŒ ÙˆØ¥Ø¶Ø§ÙØªÙ‡ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
          // Check by ID OR by Name+Account to avoid duplicates
          const restoredEntryExists = state.entries.some(e => e.id === id || (e.name === winner.name && e.account === winner.account));
          if (!restoredEntryExists) {
            console.log('[Restore] Adding winner back to entries list');
            state.entries.push({
              id: winner.id,
              name: winner.name,
              account: winner.account,
              label: `${winner.name} â€” ${winner.account}`,
              selected: false,
              seq: state.entries.length + 1
            });
          } else {
             console.log('[Restore] Winner already exists in entries list');
          }

          // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø®ØªÙŠØ§Ø± Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†
          let updatedCount = 0;
          state.entries.forEach(entry => {
            // Ø§Ù„Ù…Ø´Ø§Ø±Ùƒ ÙŠØ¹ØªØ¨Ø± "Ù…Ø®ØªØ§Ø±Ø§Ù‹" (Ù…Ø³ØªØ¨Ø¹Ø¯Ø§Ù‹ Ù…Ù† Ø§Ù„Ø±ÙˆÙ„ÙŠØª) ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø§Ù„Ø­Ø§Ù„ÙŠØ©
            const wasSelected = entry.selected;
            entry.selected = currentWinnerIds.has(entry.id);
            if (wasSelected !== entry.selected) updatedCount++;
          });
          console.log(`[Restore] Updated selection status for ${updatedCount} entries`);
          
          // Ø­Ø°Ù Ø§Ù„ÙØ§Ø¦Ø² Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø­ÙÙˆØ¸Ø§Ù‹
          if (winner._id && state.selectedAgent && state.selectedAgent.id) {
            try {
              const authedFetch = window.authedFetch || fetch;
              await authedFetch(`/api/agents/${state.selectedAgent.id}/winners/${winner._id}`, {
                method: 'DELETE'
              });

              // NEW: If we delete a winner, we should ensure the competition is not "completed" anymore
              // This allows the user to spin again and select a replacement
              if (state.activeCompetition && state.activeCompetition.id) {
                  // We optimistically update local state
                  state.reportSent = false;
                  state.noWinnersApproved = false;

                  // And update backend status to 'active' (or 'awaiting_winners' if supported, but 'active' is safer)
                  await authedFetch(`/api/competitions/${state.activeCompetition.id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ status: 'active' })
                  });
              }
            } catch (e) {
              console.error('ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„ÙØ§Ø¦Ø² Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:', e);
            }
          } else {
             // Even if not saved in DB, we should unlock the UI locally
             state.reportSent = false;
             state.noWinnersApproved = false;
          }
          
          // IMPORTANT: Remove from staged storage BEFORE rendering, otherwise renderWinners might re-populate it!
          removeStagedWinner(id, state.activeCompetition?.id || null);

          // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
          console.log(`[Restore] Re-rendering UI. Entries: ${state.entries.length}, Winners: ${state.winners.length}`);
          renderParticipants();
          renderWinners();
          updateCounts();
          drawWheel();
          saveSession();

          // ØªØ­Ø¯ÙŠØ« Ø­Ù‚Ù„ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ù„ÙŠØ¹ÙƒØ³ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© (Ø¨Ù…Ø§ ÙÙŠ Ø°Ù„Ùƒ Ø§Ù„ÙØ§Ø¦Ø² Ø§Ù„Ù…Ø³ØªØ±Ø¬Ø¹)
          const ta = document.getElementById('participants-input');
          if (ta) {
              ta.value = state.entries.map(e => e.account ? `${e.name} â€” ${e.account}` : e.name).join('\n');
          }
          
          toast(`ØªÙ… Ø§Ø³ØªØ±Ø¬Ø§Ø¹ ${winner.name} Ø¥Ù„Ù‰ Ø§Ù„Ø±ÙˆÙ„ÙŠØª Ø¨Ù†Ø¬Ø§Ø­`, 'success');
        }
      );
    }
    
    function handleWinnerWarningToggle(ev) {
      const id = ev.currentTarget.getAttribute('data-id');
      const warnType = ev.currentTarget.getAttribute('data-warn');
      const winner = state.winners.find(w => w.id === id);
      if (!winner) return;
      if (warnType === 'meet') winner.includeWarnMeet = !!ev.currentTarget.checked;
      if (warnType === 'prev') winner.includeWarnPrev = !!ev.currentTarget.checked;
      saveSession();
      updateStagedWinner(id, state.activeCompetition?.id || null, {
        includeWarnMeet: winner.includeWarnMeet,
        includeWarnPrev: winner.includeWarnPrev
      });
    }
    
    function handleSendClick(ev) {
      const id = ev.currentTarget.getAttribute('data-send');
      const winner = state.winners.find(w => w.id === id);
      if (!winner) return;
      
      if (!state.selectedAgent) {
        toast('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ÙˆÙƒÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹', 'warning');
        return;
      }
    
      if (!winner._id) {
        toast('ÙŠØ¬Ø¨ Ø­ÙØ¸ Ø§Ù„ÙØ§Ø¦Ø² ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø£ÙˆÙ„Ø§Ù‹', 'warning');
        return;
      }
    
      showConfirmModal(
        `Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙØ§Ø¦Ø² <strong>${winner.name}</strong> Ø¥Ù„Ù‰ Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„ÙˆÙƒÙŠÙ„. Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ØŸ`,
        async () => {
            try {
                const authedFetch = window.authedFetch || fetch;
                const resp = await authedFetch(`/api/agents/${state.selectedAgent.id}/send-winners-report`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        winnerIds: [winner._id],
                        messageText: generateSingleWinnerMessage(winner)
                    })
                });
                
                if (resp.ok) {
                    toast('ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙØ§Ø¦Ø² Ø¨Ù†Ø¬Ø§Ø­', 'success');
                } else {
                    const err = await resp.json();
                    toast(`ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: ${err.message}`, 'error');
                }
            } catch (e) {
                console.error(e);
                toast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„', 'error');
            }
        }
      );
    }
    
    function generateSingleWinnerMessage(w) {
        let prizeText = '';
        if (w.prizeType === 'deposit_prev') {
            prizeText = `${w.prizeValue}% Ø¨ÙˆÙ†Øµ Ø§ÙŠØ¯Ø§Ø¹ ÙƒÙˆÙ†Ù‡ ÙØ§Ø¦Ø² Ù…Ø³Ø¨Ù‚Ø§ Ø¨Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ`;
        } else if (w.prizeType === 'deposit') {
            prizeText = `${w.prizeValue}% Ø¨ÙˆÙ†Øµ Ø§ÙŠØ¯Ø§Ø¹`;
        } else {
            prizeText = `${w.prizeValue}$ Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ`;
        }
    
        let msg = `â—ƒ Ø§Ù„ÙØ§Ø¦Ø²: ${w.name}\n`;
        msg += `           Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©: ${prizeText}\n`;

        if (w.includeWarnMeet) {
            msg += `\nâš ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ Ù…Ø¹ Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù†Ù‡ Ø£ÙˆÙ„Ø§Ù‹\n`;
        }
        if (w.includeWarnPrev) {
            msg += `\nâ€¼ï¸ ÙØ§Ø¦Ø² Ø³Ø§Ø¨Ù‚ Ø¨Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠØŒ ØªØ£ÙƒØ¯ Ù…Ù† Ù†Ø´Ø± Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ù‚Ø¨Ù„ Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯\n`;
        }

        msg += `\n********************************************************\n`;
        msg += `ÙŠØ±Ø¬Ù‰ Ø§Ø¨Ù„Ø§Øº Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø¨Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§ Ø¹Ø¨Ø± Ù…Ø¹Ø±Ù Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ùˆ Ø§Ù„Ø§Ø¹Ù„Ø§Ù† Ø¹Ù†Ù‡Ù… Ø¨Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙ‡Ù… Ùˆ ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø±ÙˆÙ„ÙŠØª Ø¨Ø§Ù„Ù‚Ù†Ø§Ø© \n`;
        msg += `https://t.me/Ibinzo`;
        return msg;
    }
    
    function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
      const words = text.split(' ');
      let line = '';
      let yy = y;
      for (let n=0;n<words.length;n++){
        const test = line + words[n] + ' ';
        const w = ctx.measureText(test).width;
        if (w > maxWidth && n>0) {
          ctx.fillText(line, x, yy);
          line = words[n] + ' ';
          yy += lineHeight;
        } else {
          line = test;
        }
      }
      ctx.fillText(line, x, yy);
    }
    
    function handleEditClick(ev) {
      const id = ev.currentTarget.getAttribute('data-edit');
      const winner = state.winners.find(w => w.id === id);
      if (winner) {
        showEditWinnerModal(winner);
      }
    }

    function showEditWinnerModal(winner) {
      const modal = document.getElementById('winner-modal');
      const winnerName = document.getElementById('celebration-winner-name');
      const winnerAccount = document.getElementById('celebration-winner-account');
      const emailInput = document.getElementById('winner-email');
      const prizeTypeInput = document.getElementById('winner-prize-type');
      const autoDisplay = document.getElementById('winner-prize-auto-display');
      const confirmBtn = document.getElementById('confirm-winner');
      const skipBtn = document.getElementById('skip-winner');
      const idInput = document.getElementById('winner-id-image');
      const idPreview = document.getElementById('winner-id-image-preview');

      if (!modal) return;

      // Populate fields
      winnerName.textContent = `Ø§Ù„Ø§Ø³Ù…: ${winner.name}`;
      winnerAccount.textContent = `Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: ${winner.account}`;

      // --- NEW: Click to Copy Account Number (Edit Mode) ---
      winnerAccount.style.cursor = 'pointer';
      winnerAccount.title = 'Ø§Ø¶ØºØ· Ù„Ù†Ø³Ø® Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨';
      winnerAccount.onclick = () => {
          if (winner.account) {
              navigator.clipboard.writeText(winner.account).then(() => {
                  toast('ØªÙ… Ù†Ø³Ø® Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨', 'success');
              }).catch(() => {
                  toast('ÙØ´Ù„ Ù†Ø³Ø® Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨', 'error');
              });
          }
      };
      // -----------------------------------------------------

      if (emailInput) emailInput.value = winner.email || '';
      
      // --- Sync Prize Preview Logic ---
      const syncPrizePreview = () => {
          const selectedType = prizeTypeInput?.value || 'trading';
          if (selectedType === 'deposit' || selectedType === 'deposit_prev') {
              const depositPct = state.activeCompetition?.depositBonusPercentage || 0;
              if (autoDisplay) {
                  autoDisplay.textContent = `${depositPct}% (Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹)`;
                  autoDisplay.style.borderColor = '#10b981';
                  autoDisplay.style.backgroundColor = 'rgba(16, 185, 129, 0.1)';
                  autoDisplay.style.color = '#10b981';
              }
          } else {
              const tradingValue = state.activeCompetition?.prizePerWinner || 0;
              if (autoDisplay) {
                  autoDisplay.textContent = `${tradingValue}$ (Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ)`;
                  autoDisplay.style.borderColor = '#3b82f6';
                  autoDisplay.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
                  autoDisplay.style.color = '#3b82f6';
              }
          }
      };

      // Prize Type
      if (prizeTypeInput) {
          prizeTypeInput.value = winner.prizeType || 'trading';
          prizeTypeInput.addEventListener('change', syncPrizePreview);
      }
      
      // Initial sync
      syncPrizePreview();

      // ID Image Preview
      if (idInput) idInput.value = '';
      if (idPreview) {
           let previewShown = false;
           
           // Try pending image first (if valid)
           if (winner.pendingIdImage) {
               try {
                   if (winner.pendingIdImage instanceof Blob || winner.pendingIdImage instanceof File) {
                       idPreview.src = URL.createObjectURL(winner.pendingIdImage);
                       idPreview.style.display = 'block';
                       previewShown = true;
                   }
               } catch (e) {
                   console.warn('Failed to create object URL for pending image', e);
               }
           }
           
           // Fallback to uploaded image URL
           if (!previewShown && winner.nationalIdImage) {
               idPreview.src = winner.nationalIdImage;
               idPreview.style.display = 'block';
               previewShown = true;
           }
           
           if (!previewShown) {
               idPreview.style.display = 'none';
               idPreview.src = '';
           }
      }

      // Helper to compress image (duplicated for safety)
      const compressImage = (file, maxWidth = 1200, quality = 0.8) => {
          return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = (e) => {
                  const img = new Image();
                  img.onload = () => {
                      const canvas = document.createElement('canvas');
                      let width = img.width;
                      let height = img.height;
                      if (width > maxWidth) {
                          height = (height * maxWidth) / width;
                          width = maxWidth;
                      }
                      canvas.width = width;
                      canvas.height = height;
                      const ctx = canvas.getContext('2d');
                      ctx.drawImage(img, 0, 0, width, height);
                      canvas.toBlob((blob) => {
                          if (blob) resolve(new File([blob], file.name, { type: 'image/jpeg' }));
                          else reject(new Error('Failed to compress'));
                      }, 'image/jpeg', quality);
                  };
                  img.onerror = reject;
                  img.src = e.target.result;
              };
              reader.onerror = reject;
              reader.readAsDataURL(file);
          });
      };

      let compressedFile = null;
      let isImageUploading = false;

      const updateIdPreview = async () => {
           if (!idInput || !idInput.files || idInput.files.length === 0) return;
           const file = idInput.files[0];
           try {
               isImageUploading = true;
               toast('Ø¬Ø§Ø±ÙŠ Ø¶ØºØ· Ø§Ù„ØµÙˆØ±Ø©...', 'info');
               compressedFile = await compressImage(file);
               idPreview.src = URL.createObjectURL(compressedFile);
               idPreview.style.display = 'block';
               isImageUploading = false;
               toast('ØªÙ… Ø¶ØºØ· Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­', 'success');
           } catch (e) {
               console.error(e);
               isImageUploading = false;
           }
      };
      
      const onIdImageChange = () => updateIdPreview();
      if (idInput) idInput.addEventListener('change', onIdImageChange);

      modal.style.display = 'flex';

      const onConfirm = async () => {
          if (isImageUploading) {
              toast('ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±...', 'warning');
              return;
          }

          const email = emailInput?.value?.trim();
          if (!email) {
              toast('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…Ø·Ù„ÙˆØ¨', 'error');
              return;
          }

          // Update winner object
          winner.email = email;
          winner.prizeType = prizeTypeInput?.value || winner.prizeType;
          
          // Recalculate prize value based on type
           if (winner.prizeType === 'deposit' || winner.prizeType === 'deposit_prev') {
               winner.prizeValue = state.activeCompetition?.depositBonusPercentage || 0;
           } else {
               winner.prizeValue = state.activeCompetition?.prizePerWinner || 0;
           }

          if (compressedFile) {
              winner.pendingIdImage = compressedFile;
              winner.idImageUploaded = true;
              winner.localIdImageName = compressedFile.name; // Store filename
          }

          // Update Staged Winner (Persist changes locally)
          saveStagedWinner({
              ...winner,
              localIdImageName: winner.localIdImageName // Ensure filename is saved
          }, state.activeCompetition?.id);

          toast('ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙØ§Ø¦Ø²', 'success');
          renderWinners();
          saveSession();
          cleanup();
          modal.style.display = 'none';
      };

      const onSkip = () => {
          cleanup();
          modal.style.display = 'none';
      };

      function cleanup() {
          confirmBtn?.removeEventListener('click', onConfirm);
          skipBtn?.removeEventListener('click', onSkip);
          idInput?.removeEventListener('change', onIdImageChange);
          prizeTypeInput?.removeEventListener('change', syncPrizePreview);
      }

      confirmBtn?.addEventListener('click', onConfirm);
      skipBtn?.addEventListener('click', onSkip);
    }

    function showWinnerModal(entry){
      /* console.log('ğŸ‰ [showWinnerModal] Called with entry:', entry);
      console.log('ğŸ‰ [showWinnerModal] Entry name:', entry?.name); */

      // --- NEW: Final check before showing modal ---
      const isAlreadyWinner = state.winners.some(w => {
          if (w.account && entry.account) {
              return w.account === entry.account;
          }
          return w.name === entry.name;
      });
      
      if (isAlreadyWinner) {
          toast(`Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ù…ØªØ³Ø§Ø¨Ù‚ ${entry.name} Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†!`, 'error');
          // Don't show modal
          return;
      }
      // ---------------------------------------------
      
      const modal = document.getElementById('winner-modal');
      const winnerName = document.getElementById('celebration-winner-name');
      const winnerAccount = document.getElementById('celebration-winner-account');
      const emailInput = document.getElementById('winner-email');
      const prizeTypeEl = document.getElementById('celebration-prize-type');
      const prizeValueEl = document.getElementById('celebration-prize-value');
      const confirmBtn = document.getElementById('confirm-winner');
      const skipBtn = document.getElementById('skip-winner'); // NEW: Skip button
      
      // Reset ID image input and preview to avoid leaking previous winner's image
      const idInput = document.getElementById('winner-id-image');
      const idPreview = document.getElementById('winner-id-image-preview');
      try { if (idInput) idInput.value = ''; } catch(e){}
      if (idPreview) { idPreview.style.display = 'none'; idPreview.src = ''; }
      
      // Initialize variables after using them for cleanup
      let idPreviewUrl = null;
      let compressedFile = null;
      let isImageUploading = false;
      
      /* console.log('ğŸ” [showWinnerModal] Elements check:');
      console.log('  - modal:', modal ? 'FOUND' : 'MISSING');
      console.log('  - winnerName:', winnerName ? 'FOUND' : 'MISSING');
      console.log('  - emailInput:', emailInput ? 'FOUND' : 'MISSING');
      console.log('  - confirmBtn:', confirmBtn ? 'FOUND' : 'MISSING'); */
      
      // Fallback if modal elements are missing: commit winner automatically to avoid crashes
      if (!modal || !winnerName || !winnerAccount || !confirmBtn) {
        console.warn('[winner-roulette] Winner modal elements missing; committing winner without UI.');
        const autoPrize = getAutoPrizeInfo(entry.account);
          const winnerData = {
            ...entry,
            email: '',
            prizeType: autoPrize.prizeType,
            prizeValue: autoPrize.prizeValue,
            includeWarnMeet: state.includeWarnMeet || false,
            includeWarnPrev: state.includeWarnPrev || false,
            agent: state.selectedAgent ? {
              id: state.selectedAgent.id,
              name: state.selectedAgent.name,
              agentId: state.selectedAgent.agentId
            } : null,
          timestamp: new Date().toISOString()
        };
        const idx = state.entries.findIndex(e => e.id === entry.id);
        if (idx !== -1) state.entries[idx].selected = true;
        if (!state.winners.find(w => w.id === entry.id)) state.winners.push(winnerData);
        state.entries = state.entries.filter(e => e.id !== entry.id);
        const ta = document.getElementById('participants-input');
        if (ta) ta.value = state.entries.map(e => `${e.name} â€” ${e.account}`).join('\n');
        renderParticipants(); renderWinners(); updateCounts(); drawWheel(); saveSession();
        updateBatchCount?.();
        if (state.activeCompetition && state.winners.length === state.activeCompetition.totalRequired) {
          const agentLabel = state.selectedAgent ? state.selectedAgent.name : 'Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„';
          checkCompletion();
        }
        state.spinQueue--; if(state.spinQueue>0){ setTimeout(()=> startSpin(), 350); } else { state.spinQueue = 0; }
        return;
      }
      
      // Populate winner info (include stable sequence prefix if available)
      const seqPrefix = (entry && (entry.seq || entry.seq === 0)) ? `${entry.seq}- ` : '';
      winnerName.textContent = `Ø§Ù„Ø§Ø³Ù…: ${seqPrefix + (entry.name || 'â€”')}`;
      winnerAccount.textContent = `Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: ${entry.account || 'â€”'}`;
      
      // --- NEW: Click to Copy Account Number ---
      winnerAccount.style.cursor = 'pointer';
      winnerAccount.title = 'Ø§Ø¶ØºØ· Ù„Ù†Ø³Ø® Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨';
      winnerAccount.onclick = () => {
          if (entry.account) {
              navigator.clipboard.writeText(entry.account).then(() => {
                  toast('ØªÙ… Ù†Ø³Ø® Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨', 'success');
              }).catch(() => {
                  toast('ÙØ´Ù„ Ù†Ø³Ø® Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨', 'error');
              });
          }
      };
      // -----------------------------------------
    
    
      // Auto-determine and display prize info
      const autoPrize = getAutoPrizeInfo(entry.account);
    
      // --- NEW: Update Input Fields + live preview ---
      const prizeTypeInput = document.getElementById('winner-prize-type');
      const prizeValueInput = document.getElementById('winner-prize-value');
      const autoDisplay = document.getElementById('winner-prize-auto-display');
      
      const syncPrizePreview = () => {
          const selectedType = prizeTypeInput?.value || autoPrize.prizeType;
          // Console insight for selection while modal blur is active
          // console.log('[PrizeTypeSelection] User selected:', selectedType, 'for account:', entry.account);
          if (selectedType === 'deposit_prev') {
            // console.log('[PrizeTypeSelection] deposit_prev chosen: treating as manual deposit bonus display.');
          }
          
          if (selectedType === 'deposit' || selectedType === 'deposit_prev') {
              const depositPct = state.activeCompetition?.depositBonusPercentage || 0;
              if (autoDisplay) {
                  autoDisplay.textContent = `${depositPct}% (Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹)`;
                  autoDisplay.style.borderColor = '#10b981';
                  autoDisplay.style.backgroundColor = 'rgba(16, 185, 129, 0.1)';
                  autoDisplay.style.color = '#10b981';
              }
              // console.log('[PrizeTypePreview] Displaying deposit bonus %:', depositPct);
          } else {
              const tradingValue = state.activeCompetition?.prizePerWinner || 0;
              if (autoDisplay) {
                  autoDisplay.textContent = `${tradingValue}$ (Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ)`;
                  autoDisplay.style.borderColor = '#3b82f6';
                  autoDisplay.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
                  autoDisplay.style.color = '#3b82f6';
              }
              // console.log('[PrizeTypePreview] Displaying trading bonus $:', tradingValue);
          }
      };
      
      if (prizeTypeInput) {
          prizeTypeInput.value = autoPrize.prizeType;
          prizeTypeInput.addEventListener('change', syncPrizePreview);
      }
      syncPrizePreview();
      // --------------------------------
      
      // Clear and focus email input
      if (emailInput) {
        emailInput.value = '';
        setTimeout(() => emailInput.focus(), 100);
      }

      // --- NEW: Clear ID Image Input and Preview ---
      // (Cleared at the top of the function)

      // ---------------------------------------------
      
      // Helper function to compress image
      const compressImage = (file, maxWidth = 1200, quality = 0.8) => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
              const canvas = document.createElement('canvas');
              let width = img.width;
              let height = img.height;
              
              // Calculate new dimensions maintaining aspect ratio
              if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
              }
              
              canvas.width = width;
              canvas.height = height;
              
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0, width, height);
              
              // Convert canvas to blob
              canvas.toBlob((blob) => {
                if (blob) {
                  // console.log(`ğŸ“¸ [Image Compression] Original: ${(file.size / 1024).toFixed(2)}KB â†’ Compressed: ${(blob.size / 1024).toFixed(2)}KB`);
                  resolve(new File([blob], file.name, { type: 'image/jpeg' }));
                } else {
                  reject(new Error('Failed to compress image'));
                }
              }, 'image/jpeg', quality);
            };
            img.onerror = reject;
            img.src = e.target.result;
          };
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      };
      
      // Add paste event handler for ID image
      const nationalIdImageInput = document.getElementById('winner-id-image');
      const idPreviewImg = document.getElementById('winner-id-image-preview');
    
      const openLightbox = () => {
        if (!idPreviewUrl) return;
        const overlay = document.createElement('div');
        overlay.style.cssText = 'position:fixed; inset:0; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center; z-index:10000; cursor: zoom-out;';
        const img = document.createElement('img');
        img.src = idPreviewUrl;
        img.alt = 'Ù…Ø¹Ø§ÙŠÙ†Ø© ØµÙˆØ±Ø© Ø§Ù„Ù‡ÙˆÙŠØ©';
        img.style.cssText = 'max-width:95vw; max-height:95vh; border-radius:10px; box-shadow: 0 10px 30px rgba(0,0,0,0.5)';
        overlay.appendChild(img);
        const cleanupOverlay = () => { document.body.removeChild(overlay); document.removeEventListener('keydown', onEsc); };
        const onEsc = (e) => { if (e.key === 'Escape') cleanupOverlay(); };
        overlay.addEventListener('click', cleanupOverlay);
        document.addEventListener('keydown', onEsc);
        document.body.appendChild(overlay);
      };
    
      const updateIdPreview = async () => {
        if (!nationalIdImageInput || !nationalIdImageInput.files || nationalIdImageInput.files.length === 0) {
          if (idPreviewImg) { idPreviewImg.style.display = 'none'; idPreviewImg.src = ''; }
          if (idPreviewUrl) { try { URL.revokeObjectURL(idPreviewUrl); } catch(e){} }
          idPreviewUrl = null;
          compressedFile = null;
          return;
        }
        const file = nationalIdImageInput.files[0];
        if (!file || !file.type || !file.type.startsWith('image/')) {
          if (idPreviewImg) { idPreviewImg.style.display = 'none'; idPreviewImg.src = ''; }
          if (idPreviewUrl) { try { URL.revokeObjectURL(idPreviewUrl); } catch(e){} idPreviewUrl = null; }
          compressedFile = null;
          return;
        }
        
        try {
          // Compress the image
          isImageUploading = true;
          toast('Ø¬Ø§Ø±ÙŠ Ø¶ØºØ· Ø§Ù„ØµÙˆØ±Ø©...', 'info');
          compressedFile = await compressImage(file);
          
          if (idPreviewUrl) { try { URL.revokeObjectURL(idPreviewUrl); } catch(e){} }
          idPreviewUrl = URL.createObjectURL(compressedFile);
          if (idPreviewImg) { idPreviewImg.src = idPreviewUrl; idPreviewImg.style.display = 'block'; }
          isImageUploading = false;
          toast('ØªÙ… Ø¶ØºØ· Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­', 'success');
        } catch (error) {
          console.error('Failed to compress image:', error);
          // Fallback to original file
          if (idPreviewUrl) { try { URL.revokeObjectURL(idPreviewUrl); } catch(e){} }
          idPreviewUrl = URL.createObjectURL(file);
          if (idPreviewImg) { idPreviewImg.src = idPreviewUrl; idPreviewImg.style.display = 'block'; }
          compressedFile = file;
          isImageUploading = false;
          toast('ØªÙ… Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©', 'warning');
        }
      };
    
      const onIdImageChange = () => updateIdPreview();
      nationalIdImageInput?.addEventListener('change', onIdImageChange);
      idPreviewImg?.addEventListener('click', openLightbox);
      const handlePaste = async (e) => {
        const items = e.clipboardData?.items;
        if (!items) return;
        
        for (let i = 0; i < items.length; i++) {
          if (items[i].type.indexOf('image') !== -1) {
            const blob = items[i].getAsFile();
            
            try {
              // Compress the pasted image
              toast('Ø¬Ø§Ø±ÙŠ Ø¶ØºØ· Ø§Ù„ØµÙˆØ±Ø©...', 'info');
              const compressed = await compressImage(blob);
              
              const dataTransfer = new DataTransfer();
              dataTransfer.items.add(compressed);
              if (nationalIdImageInput) {
                nationalIdImageInput.files = dataTransfer.files;
                await updateIdPreview();
                toast('ØªÙ… Ù„ØµÙ‚ Ø§Ù„ØµÙˆØ±Ø© ÙˆØ¶ØºØ·Ù‡Ø§ Ø¨Ù†Ø¬Ø§Ø­', 'success');
              }
            } catch (error) {
              console.error('Failed to compress pasted image:', error);
              // Fallback to original blob
              const dataTransfer = new DataTransfer();
              dataTransfer.items.add(blob);
              if (nationalIdImageInput) {
                nationalIdImageInput.files = dataTransfer.files;
                await updateIdPreview();
                toast('ØªÙ… Ù„ØµÙ‚ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©', 'warning');
              }
            }
            
            e.preventDefault();
            break;
          }
        }
      };
      
      document.addEventListener('paste', handlePaste);
      
      modal.style.display = 'flex';
      
      /* console.log('ğŸ“º [showWinnerModal] Modal displayed');
      console.log('ğŸ” [showWinnerModal] Final modal check:');
      const contentBox = modal.querySelector('.wr-celebration-content');
      if (contentBox) {
        console.log('  - Content box max-height:', contentBox.style.maxHeight || 'NOT SET');
        console.log('  - Content box overflow-y:', contentBox.style.overflowY || 'NOT SET');
        console.log('  - Content box overflow-x:', contentBox.style.overflowX || 'NOT SET');
        console.log('  - Content box scrollbarGutter:', contentBox.style.scrollbarGutter || 'NOT SET');
      } else {
        console.error('âŒ [showWinnerModal] Content box NOT FOUND!');
      } */
      
      // launchConfetti() removed - no animations
      
      const onClose = () => { 
        modal.style.display = 'none';
        document.removeEventListener('paste', handlePaste);
        idPreviewImg?.removeEventListener('click', openLightbox);
        nationalIdImageInput?.removeEventListener('change', onIdImageChange);
        if (idPreviewUrl) { try { URL.revokeObjectURL(idPreviewUrl); } catch(e){} idPreviewUrl = null; }
        if (idPreviewImg) { idPreviewImg.style.display = 'none'; idPreviewImg.src = ''; }
        cleanup(); 
      };
      
      const onConfirm = async () => {
        const email = emailInput?.value?.trim() || '';
        const nationalIdImageInput = document.getElementById('winner-id-image');
        const autoDisplay = document.getElementById('winner-prize-auto-display');
        let selectedPrizeType = prizeTypeInput?.value || autoPrize.prizeType;
        // console.log('[PrizeTypeConfirm] Selected type:', selectedPrizeType);
        
        // REMOVED: Mapping deposit_prev to deposit. Now we keep it as is.
        // if (selectedPrizeType === 'deposit_prev') { ... }
        
        // Get prize value from active competition based on type
        // Treat deposit_prev same as deposit for value calculation
        const selectedPrizeValue = (selectedPrizeType === 'deposit' || selectedPrizeType === 'deposit_prev')
            ? (state.activeCompetition?.depositBonusPercentage ?? 0)
            : (state.activeCompetition?.prizePerWinner ?? 0);
        // console.log('[PrizeValueConfirm] Final prize:', { type: selectedPrizeType, value: selectedPrizeValue });
        
        // Email is REQUIRED: validate existence and format
        const emailErrorEl = document.getElementById('winner-email-error');
        if (!email) {
          emailInput?.classList.add('wr-input-error');
          toast('ÙŠØ¬Ø¨ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ','error');
          setTimeout(()=> emailInput?.classList.remove('wr-input-error'), 2000);
          return;
        }
        if (!/.+@.+\..+/.test(email)) {
          if (emailErrorEl) emailErrorEl.style.display = 'block';
          emailInput?.classList.add('wr-input-error');
          toast('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ§Ù„Ø­','error');
          setTimeout(()=>{ emailErrorEl && (emailErrorEl.style.display='none'); emailInput?.classList.remove('wr-input-error'); }, 2500);
          return; // Do not close modal
        }
        
        // Check if image is still uploading
        if (isImageUploading) {
          toast('ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø­ØªÙ‰ ÙŠØªÙ… Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ù‡ÙˆÙŠØ© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„', 'warning');
          return;
        }
        
        // Require ID image before confirming
        if (!(nationalIdImageInput?.files?.length > 0)) {
          const idInput = document.getElementById('winner-id-image');
          idInput?.classList.add('wr-input-error');
          toast('ÙŠØ¬Ø¨ Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ù‡ÙˆÙŠØ© Ù‚Ø¨Ù„ Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯','error');
          setTimeout(()=> idInput?.classList.remove('wr-input-error'), 2000);
          return;
        }

        // Require Video before confirming
        if (!state.pendingVideoBlob) {
          toast('ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆ Ø§Ù„ÙÙˆØ² Ù‚Ø¨Ù„ Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯', 'error');
          return;
        }
        
        // Create winner object with collected data
        const winnerData = {
          ...entry,
          email: email,
          prizeType: selectedPrizeType,
          prizeValue: selectedPrizeValue,
          includeWarnMeet: state.includeWarnMeet || false,
          includeWarnPrev: state.includeWarnPrev || false,
          agent: state.selectedAgent ? {
            id: state.selectedAgent.id,
            name: state.selectedAgent.name,
            agentId: state.selectedAgent.agentId
          } : null,
          timestamp: new Date().toISOString()
        };
        // --- Ø§Ù„Ø­ÙØ¸ Ø§Ù„Ù…Ø­Ù„ÙŠ ÙÙ‚Ø· (Ù„Ù† ÙŠØªÙ… Ø§Ù„Ø­ÙØ¸ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø­ØªÙ‰ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ "Ø§Ø¹ØªÙ…Ø§Ø¯ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†") ---
        // Ø­ÙØ¸ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ÙˆØ§Ù„ØµÙˆØ±Ø© Ù…Ø¤Ù‚ØªØ§Ù‹ ÙÙŠ Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ù…Ø­Ù„ÙŠ
        if (state.pendingVideoBlob) {
          winnerData.pendingVideoBlob = state.pendingVideoBlob;
          winnerData.recordingMimeType = state.recordingMimeType;
          
          // --- NEW: Save Video to IndexedDB for Persistence ---
          saveVideoToDB(winnerData.id, state.pendingVideoBlob).catch(e => console.warn('Failed to persist video', e));
          // ----------------------------------------------------

          state.pendingVideoBlob = null; // Clear from state
        }
        
        if (compressedFile) {
          winnerData.pendingIdImage = compressedFile;
          winnerData.idImageUploaded = true; // Mark as having image
          // Store filename for reference as requested
          winnerData.localIdImageName = compressedFile.name;
        }

        const stagedWinner = {
          id: winnerData.id,
          name: winnerData.name,
          account: winnerData.account,
          email: winnerData.email,
          prizeType: winnerData.prizeType,
          prizeValue: winnerData.prizeValue,
          includeWarnMeet: winnerData.includeWarnMeet,
          includeWarnPrev: winnerData.includeWarnPrev,
          idImageUploaded: !!winnerData.idImageUploaded,
          localIdImageName: winnerData.localIdImageName, // Save filename in staged
          agent: winnerData.agent,
          competitionId: state.activeCompetition?.id || null,
          competitionName: state.activeCompetition?.name || null,
          timestamp: winnerData.timestamp
        };
        addStagedWinner(stagedWinner);

        
        toast('ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙØ§Ø¦Ø² Ù…Ø­Ù„ÙŠØ§Ù‹. Ø§Ø¶ØºØ· "Ø§Ø¹ØªÙ…Ø§Ø¯ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†" Ù„Ù„Ø­ÙØ¸ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ', 'success');
        // ------------------------------------
    
        const idx = state.entries.findIndex(e => e.id === entry.id);
        if (idx !== -1) state.entries[idx].selected = true;
        if (!state.winners.find(w => w.id === entry.id)) {
          state.winners.push(winnerData);
        }
        
        // Ù…Ø³Ø­ Ø§Ù„ÙØ§Ø¦Ø² Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†
        state.entries = state.entries.filter(e => e.id !== entry.id);
        
        // ØªØ­Ø¯ÙŠØ« Ø­Ù‚Ù„ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
        const ta = document.getElementById('participants-input');
        if (ta) {
          ta.value = state.entries.map(e => `${e.name} â€” ${e.account}`).join('\n');
        }
        
        renderParticipants(); renderWinners(); updateCounts(); drawWheel(); onClose();
        saveSession();
        updateBatchCount?.();
        
        // ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© ÙÙŠ Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø¹Ù„ÙˆÙŠ
        if (state.selectedAgent && state.selectedAgent.id) {
          updateCompetitionStats();
        }
        
        // Ø¥Ø¸Ù‡Ø§Ø± Ø´Ø§Ø´Ø© Ù…Ù†Ø¨Ø«Ù‚Ø© Ø¹Ù†Ø¯ Ø§ÙƒØªÙ…Ø§Ù„ Ø¹Ø¯Ø¯ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†
        const currentTotal = state.winners.length;
        if (state.activeCompetition && currentTotal >= state.activeCompetition.totalRequired) {
          const agentLabel = state.selectedAgent ? state.selectedAgent.name : 'Ù‡Ø°Ø§ Ø§Ù„ÙˆÙƒÙŠÙ„';
          checkCompletion();
        }
        
        state.spinQueue--;
        if(state.spinQueue>0){ setTimeout(()=> startSpin(), 350); }
        else { state.spinQueue = 0; }
      };

      // --- NEW: Skip Logic ---
      const onSkip = () => {
        onClose();
        // User requested to stop automatic re-spin on skip
      };
      
      function cleanup(){
        confirmBtn?.removeEventListener('click', onConfirm);
        skipBtn?.removeEventListener('click', onSkip);
      }
      
      confirmBtn?.addEventListener('click', onConfirm);
      skipBtn?.addEventListener('click', onSkip);
    }
    
    function showAutoWinnerModal(entry){
      let isImageUploadingAuto = false;
      // --- NEW: Final check before showing modal ---
      const isAlreadyWinner = state.winners.some(w => {
          if (w.account && entry.account) {
              return w.account === entry.account;
          }
          return w.name === entry.name;
      });
      
      if (isAlreadyWinner) {
          toast(`Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ù…ØªØ³Ø§Ø¨Ù‚ ${entry.name} Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†!`, 'error');
          return;
      }
      // ---------------------------------------------

      const modal = document.getElementById('winner-modal');
      const winnerName = document.getElementById('celebration-winner-name');
      const winnerAccount = document.getElementById('celebration-winner-account');
      const emailInput = document.getElementById('winner-email');
      const prizeTypeEl = document.getElementById('celebration-prize-type');
      const prizeValueEl = document.getElementById('celebration-prize-value');
      const confirmBtn = document.getElementById('confirm-winner');
      
      // Fallback if modal elements are missing in auto mode
      if (!modal || !winnerName || !winnerAccount || !confirmBtn) {
        console.warn('[winner-roulette] Auto mode: Winner modal elements missing; committing winner without UI.');
        const autoPrize = getAutoPrizeInfo(entry.account);
        const winnerData = {
          ...entry,
          email: '',
          prizeType: autoPrize.prizeType,
          prizeValue: autoPrize.prizeValue,
          includeWarnMeet: state.includeWarnMeet || false,
          includeWarnPrev: state.includeWarnPrev || false,
          agent: state.selectedAgent ? {
            id: state.selectedAgent.id,
            name: state.selectedAgent.name,
            agentId: state.selectedAgent.agentId
          } : null,
          timestamp: new Date().toISOString()
        };
        const idx = state.entries.findIndex(e => e.id === entry.id);
        if (idx !== -1) state.entries[idx].selected = true;
        if (!state.winners.find(w => w.id === entry.id)) state.winners.push(winnerData);
        state.entries = state.entries.filter(e => e.id !== entry.id);
        const ta = document.getElementById('participants-input');
        if (ta) ta.value = state.entries.map(e => `${e.name} â€” ${e.account}`).join('\n');
        renderParticipants(); renderWinners(); updateCounts(); drawWheel(); saveSession();
        state.autoRemaining--; updateBatchCount?.();
        if(state.autoRemaining>0){ setTimeout(()=> startSpin(), 400); } else {
          state.autoMode=false; state.spinQueue=0; toast('Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ø¥Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…ØªØªØ§Ù„ÙŠ','success');
          checkCompletion();
        }
        return;
      }
      
      // Populate winner info (include stable sequence prefix if available)
      const seqPrefix = (entry && (entry.seq || entry.seq === 0)) ? `${entry.seq}- ` : '';
      winnerName.textContent = `Ø§Ù„Ø§Ø³Ù…: ${seqPrefix + (entry.name || 'â€”')}`;
      winnerAccount.textContent = `Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: ${entry.account || 'â€”'}`;
      
      // Auto-determine and display prize info
      const autoPrize = getAutoPrizeInfo(entry.account);
    
      // --- NEW: Update Input Fields ---
      const prizeTypeInput = document.getElementById('winner-prize-type');
      const prizeValueInput = document.getElementById('winner-prize-value');
      
        if (prizeTypeInput) {
          prizeTypeInput.value = autoPrize.prizeType;
          // If previous winner special option desired, it should still act like deposit
          if (prizeTypeInput.value === 'deposit_prev') prizeTypeInput.value = 'deposit';
          prizeTypeInput.dispatchEvent(new Event('change'));
        }
      if (prizeValueInput) {
          prizeValueInput.value = autoPrize.prizeValue;
      }
      // --------------------------------
    
      if (prizeTypeEl && prizeValueEl) {
        if (autoPrize.prizeType === 'deposit') {
            prizeTypeEl.textContent = 'Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹';
            prizeValueEl.textContent = `${autoPrize.prizeValue}%`;
            prizeValueEl.style.display = 'block';
        } else {
            prizeTypeEl.textContent = 'Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ';
            prizeValueEl.textContent = `${autoPrize.prizeValue}$`;
            prizeValueEl.style.display = 'block';
        }
      }
      if (prizeTypeEl && !prizeValueEl) {
         const typeLabel = autoPrize.prizeType === 'deposit' ? 'Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹' : 'Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ';
         prizeTypeEl.textContent = typeLabel;
      }
      
      // Clear and focus email input
      if (emailInput) {
        emailInput.value = '';
        setTimeout(() => emailInput.focus(), 100);
      }
      
      // Helper function to compress image
      const compressImage = (file, maxWidth = 1200, quality = 0.8) => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
              const canvas = document.createElement('canvas');
              let width = img.width;
              let height = img.height;
              
              // Calculate new dimensions maintaining aspect ratio
              if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
              }
              
              canvas.width = width;
              canvas.height = height;
              
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0, width, height);
              
              // Convert canvas to blob
              canvas.toBlob((blob) => {
                if (blob) {
                  // console.log(`ğŸ“¸ [Image Compression] Original: ${(file.size / 1024).toFixed(2)}KB â†’ Compressed: ${(blob.size / 1024).toFixed(2)}KB`);
                  resolve(new File([blob], file.name, { type: 'image/jpeg' }));
                } else {
                  reject(new Error('Failed to compress image'));
                }
              }, 'image/jpeg', quality);
            };
            img.onerror = reject;
            img.src = e.target.result;
          };
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      };

      // Add paste/change event handler for ID image (auto mode)
      const nationalIdImageInputAuto = document.getElementById('winner-id-image');
      const idPreviewImgAuto = document.getElementById('winner-id-image-preview');
      let idPreviewUrlAuto = null;
      let compressedFile = null; // Store compressed file
    
      const openLightboxAuto = () => {
        if (!idPreviewUrlAuto) return;
        const overlay = document.createElement('div');
        overlay.style.cssText = 'position:fixed; inset:0; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center; z-index:10000; cursor: zoom-out;';
        const img = document.createElement('img');
        img.src = idPreviewUrlAuto;
        img.alt = 'Ù…Ø¹Ø§ÙŠÙ†Ø© ØµÙˆØ±Ø© Ø§Ù„Ù‡ÙˆÙŠØ©';
        img.style.cssText = 'max-width:95vw; max-height:95vh; border-radius:10px; box-shadow: 0 10px 30px rgba(0,0,0,0.5)';
        overlay.appendChild(img);
        const cleanupOverlay = () => { document.body.removeChild(overlay); document.removeEventListener('keydown', onEsc); };
        const onEsc = (e) => { if (e.key === 'Escape') cleanupOverlay(); };
        overlay.addEventListener('click', cleanupOverlay);
        document.addEventListener('keydown', onEsc);
        document.body.appendChild(overlay);
      };
    
      const updateIdPreviewAuto = async () => {
        if (!nationalIdImageInputAuto || !nationalIdImageInputAuto.files || nationalIdImageInputAuto.files.length === 0) {
          if (idPreviewImgAuto) { idPreviewImgAuto.style.display = 'none'; idPreviewImgAuto.src = ''; }
          if (idPreviewUrlAuto) { try { URL.revokeObjectURL(idPreviewUrlAuto); } catch(e){} idPreviewUrlAuto = null; }
          compressedFile = null;
          return;
        }
        const file = nationalIdImageInputAuto.files[0];
        if (!file || !file.type || !file.type.startsWith('image/')) {
          if (idPreviewImgAuto) { idPreviewImgAuto.style.display = 'none'; idPreviewImgAuto.src = ''; }
          if (idPreviewUrlAuto) { try { URL.revokeObjectURL(idPreviewUrlAuto); } catch(e){} idPreviewUrlAuto = null; }
          compressedFile = null;
          return;
        }
        
        try {
          // Compress the image
          isImageUploadingAuto = true;
          toast('Ø¬Ø§Ø±ÙŠ Ø¶ØºØ· Ø§Ù„ØµÙˆØ±Ø©...', 'info');
          compressedFile = await compressImage(file);
          
          if (idPreviewUrlAuto) { try { URL.revokeObjectURL(idPreviewUrlAuto); } catch(e){} }
          idPreviewUrlAuto = URL.createObjectURL(compressedFile);
          if (idPreviewImgAuto) { idPreviewImgAuto.src = idPreviewUrlAuto; idPreviewImgAuto.style.display = 'block'; }
          isImageUploadingAuto = false;
          toast('ØªÙ… Ø¶ØºØ· Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­', 'success');
        } catch (error) {
          console.error('Failed to compress image:', error);
          // Fallback to original file
          if (idPreviewUrlAuto) { try { URL.revokeObjectURL(idPreviewUrlAuto); } catch(e){} }
          idPreviewUrlAuto = URL.createObjectURL(file);
          if (idPreviewImgAuto) { idPreviewImgAuto.src = idPreviewUrlAuto; idPreviewImgAuto.style.display = 'block'; }
          compressedFile = file;
          isImageUploadingAuto = false;
          toast('ØªÙ… Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©', 'warning');
        }
      };
    
      const onIdImageChangeAuto = () => updateIdPreviewAuto();
      nationalIdImageInputAuto?.addEventListener('change', onIdImageChangeAuto);
      idPreviewImgAuto?.addEventListener('click', openLightboxAuto);
      const handlePasteAuto = async (e) => {
        const items = e.clipboardData?.items;
        if (!items) return;
        
        for (let i = 0; i < items.length; i++) {
          if (items[i].type.indexOf('image') !== -1) {
            const blob = items[i].getAsFile();
            
            try {
              // Compress the pasted image
              toast('Ø¬Ø§Ø±ÙŠ Ø¶ØºØ· Ø§Ù„ØµÙˆØ±Ø©...', 'info');
              const compressed = await compressImage(blob);
              
              const dataTransfer = new DataTransfer();
              dataTransfer.items.add(compressed);
              if (nationalIdImageInputAuto) {
                nationalIdImageInputAuto.files = dataTransfer.files;
                await updateIdPreviewAuto();
                toast('ØªÙ… Ù„ØµÙ‚ Ø§Ù„ØµÙˆØ±Ø© ÙˆØ¶ØºØ·Ù‡Ø§ Ø¨Ù†Ø¬Ø§Ø­', 'success');
              }
            } catch (error) {
              console.error('Failed to compress pasted image:', error);
              // Fallback to original blob
              const dataTransfer = new DataTransfer();
              dataTransfer.items.add(blob);
              if (nationalIdImageInputAuto) {
                nationalIdImageInputAuto.files = dataTransfer.files;
                await updateIdPreviewAuto();
                toast('ØªÙ… Ù„ØµÙ‚ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©', 'warning');
              }
            }
            
            e.preventDefault();
            break;
          }
        }
      };
      
      document.addEventListener('paste', handlePasteAuto);
      
      modal.style.display = 'flex';
      // Improve scroll behavior for auto mode as well
      try {
        const contentBox = modal.querySelector('.wr-celebration-content');
        if (contentBox) {
          // contentBox.style.overflowY = 'auto'; // REMOVED
          // contentBox.style.overflowX = 'hidden'; // REMOVED
          // contentBox.style.scrollbarGutter = 'stable'; // REMOVED
        }
      } catch(e) { /* ignore */ }
      // launchConfetti() removed - no animations
      
      const onClose = () => { 
        modal.style.display = 'none';
        document.removeEventListener('paste', handlePasteAuto);
        idPreviewImgAuto?.removeEventListener('click', openLightboxAuto);
        nationalIdImageInputAuto?.removeEventListener('change', onIdImageChangeAuto);
        if (idPreviewUrlAuto) { try { URL.revokeObjectURL(idPreviewUrlAuto); } catch(e){} idPreviewUrlAuto = null; }
        if (idPreviewImgAuto) { idPreviewImgAuto.style.display = 'none'; idPreviewImgAuto.src = ''; }
        cleanup(); 
      };
      
      const onConfirm = async () => {
        const email = emailInput?.value?.trim() || '';
        const nationalIdImageInput = document.getElementById('winner-id-image');
        
        const emailErrorEl = document.getElementById('winner-email-error');
        if (email && !/.+@.+\..+/.test(email)) {
          if (emailErrorEl) emailErrorEl.style.display = 'block';
          emailInput?.classList.add('wr-input-error');
          toast('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ§Ù„Ø­','error');
          setTimeout(()=>{ emailErrorEl && (emailErrorEl.style.display='none'); emailInput?.classList.remove('wr-input-error'); }, 2500);
          return;
        }
        
        // Check if image is still uploading (auto mode)
        if (isImageUploadingAuto) {
          toast('ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø­ØªÙ‰ ÙŠØªÙ… Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ù‡ÙˆÙŠØ© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„', 'warning');
          return;
        }
        
        // Require ID image before confirming
        if (!(nationalIdImageInput?.files?.length > 0)) {
          const idInput = document.getElementById('winner-id-image');
          idInput?.classList.add('wr-input-error');
          toast('ÙŠØ¬Ø¨ Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ù‡ÙˆÙŠØ© Ù‚Ø¨Ù„ Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯','error');
          setTimeout(()=> idInput?.classList.remove('wr-input-error'), 2000);
          return;
        }

        // Require Video before confirming (Auto Mode)
        if (!state.pendingVideoBlob) {
          toast('ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆ Ø§Ù„ÙÙˆØ² Ù‚Ø¨Ù„ Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯', 'error');
          return;
        }
        
        // Create winner object with collected data
        const winnerData = {
          ...entry,
          email: email,
          prizeType: autoPrize.prizeType,
          prizeValue: autoPrize.prizeValue,
          agent: state.selectedAgent ? {
            id: state.selectedAgent.id,
            name: state.selectedAgent.name,
            agentId: state.selectedAgent.agentId
          } : null,
          timestamp: new Date().toISOString()
        };
        
        // --- SAVE TO DATABASE IMMEDIATELY (Auto Mode) ---
        if (state.selectedAgent && state.selectedAgent.id) {
          const payload = {
            winners: [{
              id: `import_${winnerData.id}`,
              name: winnerData.name,
              account_number: winnerData.account || '',
              email: winnerData.email || '',
              national_id: winnerData.nationalId || '',
              prize_type: winnerData.prizeType || '',
              prize_value: winnerData.prizeValue || 0,
              selected_at: winnerData.timestamp,
              meta: {
                email: winnerData.email || '',
                national_id: winnerData.nationalId || '',
                prize_type: winnerData.prizeType || '',
                prize_value: winnerData.prizeValue || 0,
                original_import_id: `import_${winnerData.id}`
              }
            }]
          };
          
          const authedFetch = window.authedFetch || fetch;
          authedFetch(`/api/agents/${encodeURIComponent(state.selectedAgent.id)}/winners/import`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          }).then(async resp => {
            if(resp.ok) {
                toast('ØªÙ… Ø­ÙØ¸ Ø§Ù„ÙØ§Ø¦Ø² ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 'success');
                const data = await resp.json();
                const createdWinner = data.winners && data.winners[0];
                
                // If we have a pending video, upload it now (Added for Auto Mode)
                if (state.pendingVideoBlob && createdWinner && createdWinner._id) {
                    const formData = new FormData();
                    // Determine extension based on recorded mimeType
                    const extension = (state.recordingMimeType && state.recordingMimeType.includes('mp4')) ? 'mp4' : 'webm';
                    formData.append('video', state.pendingVideoBlob, `winner_${createdWinner._id}.${extension}`);
                    
                    const uploadResp = await authedFetch(`/api/winners/${createdWinner._id}/video`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!uploadResp.ok) console.warn('Failed to upload video for winner', createdWinner._id);
                    else toast('ØªÙ… Ø­ÙØ¸ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¨Ù†Ø¬Ø§Ø­', 'success');
                    
                    // Clear pending blob
                    state.pendingVideoBlob = null;
                }

                // Upload national ID image if provided
                if (compressedFile && createdWinner && createdWinner._id) {
                    const idImageFormData = new FormData();
                    idImageFormData.append('id_image', compressedFile);
                    
                    const idImageResp = await authedFetch(`/api/winners/${createdWinner._id}/id-image`, {
                        method: 'POST',
                        body: idImageFormData
                    });
                    
                    if (!idImageResp.ok) console.warn('Failed to upload ID image for winner', createdWinner._id);
                    else toast('ØªÙ… Ø­ÙØ¸ ØµÙˆØ±Ø© Ø§Ù„Ù‡ÙˆÙŠØ© Ø¨Ù†Ø¬Ø§Ø­', 'success');
                }
                
                // UPDATE LOCAL WINNER WITH DB ID
                if (createdWinner && createdWinner._id) {
                    const localWinner = state.winners.find(w => w.id === winnerData.id);
                    if (localWinner) {
                        localWinner._id = createdWinner._id;
                        saveSession();
                    }
                }
            }
            else console.warn('Failed to save winner to DB', resp.status);
          }).catch(err => console.error('Error saving winner to DB', err));
        }
        // ------------------------------------
    
        const idx = state.entries.findIndex(e => e.id === entry.id);
        if (idx !== -1) state.entries[idx].selected = true;
        if (!state.winners.find(w => w.id === entry.id)) {
          state.winners.push(winnerData);
        }
        
        // Ù…Ø³Ø­ Ø§Ù„ÙØ§Ø¦Ø² Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†
        state.entries = state.entries.filter(e => e.id !== entry.id);
        
        // ØªØ­Ø¯ÙŠØ« Ø­Ù‚Ù„ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
        const ta = document.getElementById('participants-input');
        if (ta) {
          ta.value = state.entries.map(e => `${e.name} â€” ${e.account}`).join('\n');
        }
        
        renderParticipants(); renderWinners(); updateCounts(); drawWheel(); saveSession();
        state.autoRemaining--; onClose();
        updateBatchCount?.();
        
        // ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© ÙÙŠ Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø¹Ù„ÙˆÙŠ
        if (state.selectedAgent && state.selectedAgent.id) {
          updateCompetitionStats();
        }
        
        if(state.autoRemaining>0){ 
          setTimeout(()=> startSpin(), 400); 
        } else { 
          state.autoMode=false; 
          state.spinQueue=0; 
          toast('Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ø¥Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…ØªØªØ§Ù„ÙŠ','success');
          // Use gated completion check
          checkCompletion();
        }
      };
      
      function cleanup(){
        confirmBtn?.removeEventListener('click', onConfirm);
      }
      
      confirmBtn?.addEventListener('click', onConfirm);
    }
    
    function showCompletionModal(agentName, totalWinners) {
        const overlay = document.createElement('div');
        overlay.className = 'wr-confirm-overlay';
        overlay.innerHTML = `
          <div class="wr-confirm-modal" style="text-align: center;">
            <div class="wr-confirm-icon" style="color: #10b981;"><i class="fas fa-check-circle"></i></div>
            <h3 class="wr-confirm-title">Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©!</h3>
            <p class="wr-confirm-message">
                ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ÙŠÙ† (${totalWinners}) Ù„Ù„ÙˆÙƒÙŠÙ„ <strong>${agentName}</strong>.
            </p>
            <div class="wr-confirm-actions" style="justify-content: center;">
              <button class="wr-btn wr-btn-primary" id="wr-complete-ok">Ø­Ø³Ù†Ø§Ù‹</button>
            </div>
          </div>
        `;
        document.body.appendChild(overlay);
        
        const okBtn = overlay.querySelector('#wr-complete-ok');
        const cleanup = () => overlay.remove();
        
        okBtn?.addEventListener('click', cleanup);
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) cleanup();
        });
    }
    
    // Ø¯Ø§Ù„Ø© Ù„Ø­ÙØ¸ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    async function saveAllWinnersToDatabase() {
      if (!state.selectedAgent || !state.selectedAgent.id) {
        throw new Error('Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆÙƒÙŠÙ„ Ù…Ø­Ø¯Ø¯');
      }
      
      const authedFetch = window.authedFetch || fetch;
      
      // Filter only unsaved winners (those without a valid MongoDB _id)
      // Assuming MongoDB _id is 24 hex characters. Local IDs are usually shorter or different format.
      // Also check if w._id exists (which we set after saving)
      const unsavedWinners = state.winners.filter(w => !w._id && (!w.id || w.id.length !== 24));
      
      if (unsavedWinners.length === 0) {
          console.log('[saveAllWinnersToDatabase] All winners are already saved.');
          return;
      }

      // ØªØ­Ø¶ÙŠØ± Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø§Ù„Ø¬Ø¯Ø¯ ÙÙ‚Ø·
      const winnersPayload = unsavedWinners.map(winner => ({
        id: `import_${winner.id}`,
        name: winner.name,
        account_number: winner.account || '',
        email: winner.email || '',
        national_id: winner.nationalId || '',
        prize_type: winner.prizeType || '',
        prize_value: Number(winner.prizeValue) || 0,
        selected_at: winner.timestamp,
        meta: {
          email: winner.email || '',
          national_id: winner.nationalId || '',
          prize_type: winner.prizeType || '',
          prize_value: Number(winner.prizeValue) || 0,
          original_import_id: `import_${winner.id}`
        }
      }));
      
      // Ø­ÙØ¸ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø§Ù„Ø¬Ø¯Ø¯
      const resp = await authedFetch(`/api/agents/${encodeURIComponent(state.selectedAgent.id)}/winners/import`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ winners: winnersPayload })
      });
      
      if (!resp.ok) {
        throw new Error('ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
      }
      
      const data = await resp.json();
      const savedWinners = data.winners || [];
      
      // ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø§Ù„Ù…Ø­Ù„ÙŠØ©
      for (let i = 0; i < savedWinners.length; i++) {
        const savedWinner = savedWinners[i];
        // Find by original_import_id in meta
        const localWinner = state.winners.find(w => `import_${w.id}` === savedWinner.meta?.original_import_id);
        
        if (localWinner && savedWinner._id) {
          const oldId = localWinner.id;
          localWinner._id = savedWinner._id;
          // Also update the main id to match _id for consistency
          localWinner.id = savedWinner._id;
          
          // --- NEW: Update Staged Winner ID ---
          // We must update the ID in the staged storage so future updates (like toggles) work
          const staged = getStagedWinners();
          const stagedIdx = staged.findIndex(s => s.id === oldId);
          if (stagedIdx !== -1) {
              staged[stagedIdx].id = savedWinner._id;
              try { localStorage.setItem(STAGED_WINNERS_KEY, JSON.stringify(staged)); } catch {}
          }
          // ------------------------------------
          
          // Ø±ÙØ¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¥Ù† ÙˆØ¬Ø¯
          if (localWinner.pendingVideoBlob) {
            try {
              const formData = new FormData();
              const extension = (localWinner.recordingMimeType && localWinner.recordingMimeType.includes('mp4')) ? 'mp4' : 'webm';
              formData.append('video', localWinner.pendingVideoBlob, `winner_${savedWinner._id}.${extension}`);
              
              await authedFetch(`/api/winners/${savedWinner._id}/video`, {
                method: 'POST',
                body: formData
              });
              
              delete localWinner.pendingVideoBlob;
              delete localWinner.recordingMimeType;
              
              // --- NEW: Clean up from IndexedDB ---
              deleteVideoFromDB(oldId).catch(e => console.warn('Failed to delete video from DB', e));
              // ------------------------------------
            } catch (e) {
              console.warn('Failed to upload video for winner', savedWinner._id, e);
            }
          }

          // Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ù‡ÙˆÙŠØ© Ø¥Ù† ÙˆØ¬Ø¯Øª (pendingIdImageFile)
          if (localWinner.pendingIdImageFile && (localWinner.pendingIdImageFile instanceof Blob || localWinner.pendingIdImageFile instanceof File)) {
            try {
              const formData = new FormData();
              formData.append('id_image', localWinner.pendingIdImageFile);
              
              const uploadResp = await authedFetch(`/api/winners/${savedWinner._id}/id-image`, {
                method: 'POST',
                body: formData
              });
              
              if (uploadResp.ok) {
                  const uploadResult = await uploadResp.json();
                  localWinner.national_id_image = uploadResult.imageUrl;
                  localWinner.idImageUploaded = true; // Mark as uploaded
              }
              
              delete localWinner.pendingIdImageFile;
            } catch (e) {
              console.warn('Failed to upload ID image for winner', savedWinner._id, e);
            }
          }
          
          // Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ù‡ÙˆÙŠØ© Ø¥Ù† ÙˆØ¬Ø¯Øª
          if (localWinner.pendingIdImage && (localWinner.pendingIdImage instanceof Blob || localWinner.pendingIdImage instanceof File)) {
            try {
              const idFormData = new FormData();
              idFormData.append('id_image', localWinner.pendingIdImage);
              
              await authedFetch(`/api/winners/${savedWinner._id}/id-image`, {
                method: 'POST',
                body: idFormData
              });
              
              delete localWinner.pendingIdImage;
            } catch (e) {
              console.warn('Failed to upload ID image for winner', savedWinner._id, e);
            }
          }
        }
      }
      
      saveSession();
      // --- NEW: Re-render winners to update data-id attributes in DOM ---
      renderWinners();
      // ------------------------------------------------------------------
      return savedWinners;
    }

    async function sendWinnersReport() {
      // console.log('[sendWinnersReport] Button clicked');
      if (!state.selectedAgent) {
        console.warn('[sendWinnersReport] No agent selected');
        toast('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ÙˆÙƒÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹', 'warning');
        return;
      }
      if (state.winners.length === 0) {
        console.warn('[sendWinnersReport] No winners in list');
        toast('Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙØ§Ø¦Ø²ÙŠÙ† Ù„Ø¥Ø±Ø³Ø§Ù„Ù‡Ù…', 'warning');
        return;
      }
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ ÙØ§Ø¦Ø²ÙŠÙ† ØºÙŠØ± Ù…Ø­ÙÙˆØ¸ÙŠÙ† ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ Ù…Ø¹ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„
      let unsavedWinners = state.winners.filter(w => !w._id);
      /* console.log('[sendWinnersReport] clicked:', {
        total: state.winners.length,
        unsaved: unsavedWinners.length,
        agentId: state.selectedAgent && state.selectedAgent.id
      }); */

      if (unsavedWinners.length > 0) {
        try {
          // console.log('[sendWinnersReport] auto-saving unsaved winners before send...', unsavedWinners);
          toast('Ø¬Ø§Ø±ÙŠ Ø­ÙØ¸ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...', 'info');
          await saveAllWinnersToDatabase();
          // console.log('[sendWinnersReport] auto-save completed successfully');
        } catch (error) {
          console.error('[sendWinnersReport] auto-save failed:', error);
          toast('ÙØ´Ù„ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„ÙØ§Ø¦Ø²ÙŠÙ†. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.', 'error');
          return;
        }
      }

      // Filter winners that have _id (saved to DB) Ø¨Ø¹Ø¯ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
      const validWinners = state.winners.filter(w => w._id);
      // console.log('[sendWinnersReport] Valid winners count:', validWinners.length);
      
      if (validWinners.length === 0) {
          console.error('[sendWinnersReport] No valid winners with DB IDs');
          toast('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. ØªØ£ÙƒØ¯ Ù…Ù† Ø­ÙØ¸ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†.', 'error');
          console.error('[sendWinnersReport] no winners with _id after filtering');
          return;
      }
    
      const messageText = generateWinnersMessage();
      
        // Directly send without confirmation modal
          // Confirm before sending all winners to agent
          showConfirmModal(
          `Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† (${validWinners.length}) Ø¥Ù„Ù‰ Ø§Ù„ÙˆÙƒÙŠÙ„. Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŸ`,
          async () => {
              // console.log('[sendWinnersReport] User confirmed send');
              try {
                  const authedFetch = window.authedFetch || fetch;
                  const resp = await authedFetch(`/api/agents/${state.selectedAgent.id}/send-winners-report`, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({
                          winnerIds: validWinners.map(w => w._id),
                          messageText
                      })
                  });
                  
                  // console.log('[sendWinnersReport] Response status:', resp.status);

                    if (resp.ok) {
                      const result = await resp.json();
                      // console.log('[sendWinnersReport] Success response:', result);
                      toast('ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø¨Ù†Ø¬Ø§Ø­', 'success');
                      // Mark report as sent to allow completion status
                      state.reportSent = true;
                      
                      // Do NOT clear winners or redirect, as per user request
                      // state.winners = [];
                      // renderWinners();
                      // updateCounts();
                      
                      saveSession();
                      
                      // Redirect removed
                      // setTimeout(() => {
                      //    window.location.href = `/pages/agent-competitions.html?agent_id=${state.selectedAgent.id}`;
                      // }, 1500);
                  } else {
                      const err = await resp.json();
                      console.error('[sendWinnersReport] Error response:', err);
                      toast(`ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: ${err.message}`, 'error');
                  }
              } catch (e) {
                  console.error('[sendWinnersReport] Exception:', e);
                  toast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„', 'error');
              }
          }
          );
    }
    
    async function sendWinnersDetails() {
      if (!state.selectedAgent) {
        toast('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ÙˆÙƒÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹', 'warning');
        return;
      }
      if (state.winners.length === 0) {
        toast('Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙØ§Ø¦Ø²ÙŠÙ† Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§ØªÙ‡Ù…', 'warning');
        return;
      }
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ ÙØ§Ø¦Ø²ÙŠÙ† ØºÙŠØ± Ù…Ø­ÙÙˆØ¸ÙŠÙ†
      const unsavedWinners = state.winners.filter(w => !w._id);
      /* console.log('[sendWinnersDetails] clicked: current winners:', {
        total: state.winners.length,
        unsaved: unsavedWinners.length,
        agentId: state.selectedAgent && state.selectedAgent.id
      }); */
      if (unsavedWinners.length > 0) {
        try {
            // console.log('[sendWinnersDetails] auto-saving unsaved winners before send...', unsavedWinners);
            toast('Ø¬Ø§Ø±ÙŠ Ø­ÙØ¸ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...', 'info');
            await saveAllWinnersToDatabase();
            // console.log('[sendWinnersDetails] auto-save completed successfully');
        } catch (error) {
            console.error('[sendWinnersDetails] auto-save failed:', error);
            toast('ÙØ´Ù„ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„ÙØ§Ø¦Ø²ÙŠÙ†. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.', 'error');
            return;
        }
      }
      
      const validWinners = state.winners.filter(w => w._id);
      // console.log('[sendWinnersDetails] valid winners after save:', validWinners.map(w => w._id));
      if (validWinners.length === 0) {
        toast('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. ØªØ£ÙƒØ¯ Ù…Ù† Ø­ÙØ¸ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†.', 'error');
        return;
      }
    
      showConfirmModal(
        `Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† (${validWinners.length}) Ù…Ø¹ ØµÙˆØ± Ø§Ù„Ù‡ÙˆÙŠØ© Ø¥Ù„Ù‰ Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„ÙˆÙƒÙŠÙ„. Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ØŸ`,
        async () => {
          try {
            const authedFetch = window.authedFetch || fetch;
            const warnings = state.winners
              .filter(w => w._id)
              .map(w => ({
                winnerId: w._id,
                // Merge global state with winner state: if global is ON, it applies to all.
                // If global is OFF, individual winner setting is preserved.
                include_warn_meet: !!(w.includeWarnMeet || state.includeWarnMeet),
                include_warn_prev: !!(w.includeWarnPrev || state.includeWarnPrev)
              }));
            const resp = await authedFetch(`/api/agents/${state.selectedAgent.id}/send-winners-details`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                winnerIds: validWinners.map(w => w._id),
                include_warn_meet: !!state.includeWarnMeet,
                include_warn_prev: !!state.includeWarnPrev,
                warnings
              })
            });
            if (resp.ok) {
              toast('ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø¨Ù†Ø¬Ø§Ø­', 'success');
              // state.reportSent = true; // Removed to allow manual approval
              // Ù„Ø§ Ù†Ù…Ø³Ø­ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ù‡Ù†Ø§ Ø¨Ø§Ù„Ø¶Ø±ÙˆØ±Ø©Ø› Ø§ØªØ±Ùƒ Ø§Ù„ØªØ­ÙƒÙ… Ù„Ø²Ø± Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„ÙƒØ§Ù…Ù„
            } else {
              const err = await resp.json();
              toast(`ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: ${err.message}`, 'error');
            }
          } catch (e) {
            console.error(e);
            toast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„', 'error');
          }
        }
      );
    }
    
    async function sendWinnersWithIDsToAgent() {
      if (!state.selectedAgent) {
        toast('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ÙˆÙƒÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹', 'warning');
        return;
      }
      if (state.winners.length === 0) {
        toast('Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙØ§Ø¦Ø²ÙŠÙ† Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§ØªÙ‡Ù…', 'warning');
        return;
      }
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ ÙØ§Ø¦Ø²ÙŠÙ† ØºÙŠØ± Ù…Ø­ÙÙˆØ¸ÙŠÙ†
      const unsavedWinners = state.winners.filter(w => !w._id);
      /* console.log('[sendWinnersWithIDsToAgent] clicked: current winners:', {
        total: state.winners.length,
        unsaved: unsavedWinners.length,
        agentId: state.selectedAgent && state.selectedAgent.id
      }); */
      if (unsavedWinners.length > 0) {
        try {
            // console.log('[sendWinnersWithIDsToAgent] auto-saving unsaved winners before send...', unsavedWinners);
            toast('Ø¬Ø§Ø±ÙŠ Ø­ÙØ¸ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...', 'info');
            await saveAllWinnersToDatabase();
            // console.log('[sendWinnersWithIDsToAgent] auto-save completed successfully');
        } catch (error) {
            console.error('[sendWinnersWithIDsToAgent] auto-save failed:', error);
            toast('ÙØ´Ù„ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„ÙØ§Ø¦Ø²ÙŠÙ†. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.', 'error');
            return;
        }
      }
      
      const validWinners = state.winners.filter(w => w._id);
      // console.log('[sendWinnersWithIDsToAgent] valid winners after save:', validWinners.map(w => w._id));
      if (validWinners.length === 0) {
        toast('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. ØªØ£ÙƒØ¯ Ù…Ù† Ø­ÙØ¸ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†.', 'error');
        return;
      }

      // Precheck: ensure each winner has ID image uploaded
      const missingIdImages = validWinners.filter(w => !w.idImageUploaded);
      // console.log('[sendWinnersWithIDsToAgent] winners missing ID image:', missingIdImages.map(w => w._id));
      if (missingIdImages.length > 0) {
        toast(`ÙŠÙˆØ¬Ø¯ ${missingIdImages.length} ÙØ§Ø¦Ø² Ø¨Ø¯ÙˆÙ† ØµÙˆØ±Ø© Ù‡ÙˆÙŠØ© Ù…Ø±ÙÙˆØ¹Ø©. ÙŠØ±Ø¬Ù‰ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ù…Ù† Ù†Ø§ÙØ°Ø© Ø§Ø¹ØªÙ…Ø§Ø¯ Ø§Ù„ÙØ§Ø¦Ø² Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„.`, 'warning');
        return;
      }
    
      showConfirmModal(
        `Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† (${validWinners.length}) Ù…Ø¹ ØµÙˆØ± Ø§Ù„Ù‡ÙˆÙŠØ© ÙˆØ§Ù„ÙƒÙ„ÙŠØ´Ø© Ø¥Ù„Ù‰ Ø¬Ø±ÙˆØ¨ Ø§Ù„Ø´Ø±ÙƒØ© (Agent competitions). Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ØŸ`,
        async () => {
          try {
            const authedFetch = window.authedFetch || fetch;
            const warnings = state.winners
              .filter(w => w._id)
              .map(w => ({
                winnerId: w._id,
                include_warn_meet: !!w.includeWarnMeet,
                include_warn_prev: !!w.includeWarnPrev
              }));
            const resp = await authedFetch(`/api/agents/${state.selectedAgent.id}/send-winners-details`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                winnerIds: validWinners.map(w => w._id),
                include_warn_meet: !!state.includeWarnMeet,
                include_warn_prev: !!state.includeWarnPrev,
                warnings,
                override_chat_id: 'COMPANY_GROUP'
              })
            });
            if (resp.ok) {
              toast('ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø¥Ù„Ù‰ Ø¬Ø±ÙˆØ¨ Ø§Ù„Ø´Ø±ÙƒØ© Ø¨Ù†Ø¬Ø§Ø­', 'success');
              // state.reportSent = true; // Removed to allow manual approval
            } else {
              const err = await resp.json();
              toast(`ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: ${err.message}`, 'error');
            }
          } catch (e) {
            console.error(e);
            toast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„', 'error');
          }
        }
      );
    }
    
    function generateWinnersMessage() {
        const ordinals = ['Ø§Ù„Ø§ÙˆÙ„', 'Ø§Ù„Ø«Ø§Ù†ÙŠ', 'Ø§Ù„Ø«Ø§Ù„Ø«', 'Ø§Ù„Ø±Ø§Ø¨Ø¹', 'Ø§Ù„Ø®Ø§Ù…Ø³', 'Ø§Ù„Ø³Ø§Ø¯Ø³', 'Ø§Ù„Ø³Ø§Ø¨Ø¹', 'Ø§Ù„Ø«Ø§Ù…Ù†', 'Ø§Ù„ØªØ§Ø³Ø¹', 'Ø§Ù„Ø¹Ø§Ø´Ø±'];
        
        let msg = '';
        state.winners.forEach((w, i) => {
            const rank = ordinals[i] || (i + 1);
            let prizeText = '';
            
            if (w.prizeType === 'deposit_prev') {
                prizeText = `${w.prizeValue}% Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹ ÙƒÙˆÙ†Ù‡ ÙØ§Ø¦Ø² Ù…Ø³Ø¨Ù‚Ø§Ù‹ Ø¨Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ`;
            } else if (w.prizeType === 'deposit') {
                prizeText = `${w.prizeValue}% Ø¨ÙˆÙ†Øµ Ø¥ÙŠØ¯Ø§Ø¹`;
            } else {
                prizeText = `${w.prizeValue}$ Ø¨ÙˆÙ†Øµ ØªØ¯Ø§ÙˆÙ„ÙŠ`;
            }
    
            msg += `â—ƒ Ø§Ù„ÙØ§Ø¦Ø² ${rank}: ${w.name}\n`;
            msg += `           Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©: ${prizeText}\n\n`;
            msg += `********************************************************\n`;
        });
        
        msg += `ÙŠØ±Ø¬Ù‰ Ø§Ø¨Ù„Ø§Øº Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ø¨Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§ Ø¹Ø¨Ø± Ù…Ø¹Ø±Ù Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ùˆ Ø§Ù„Ø§Ø¹Ù„Ø§Ù† Ø¹Ù†Ù‡Ù… Ø¨Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙ‡Ù… Ùˆ ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø±ÙˆÙ„ÙŠØª Ø¨Ø§Ù„Ù‚Ù†Ø§Ø© \n`;
        msg += `https://t.me/Ibinzo`;
        return msg;
    }

// Make init available globally for both module and non-module environments
if (typeof window !== 'undefined') {
    window.winnerRouletteInit = init;
}

})(); // End of IIFE
    













// == question-suggestions.js ==
// ==========================
// Ù†Ø¸Ø§Ù… Ø§Ù‚ØªØ±Ø§Ø­ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© - Ù„Ù„Ù…ÙˆØ¸ÙÙŠÙ†
// ==========================

let currentUser = null;
let myStats = null;

// ==========================
// Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
// ==========================
function initQuestionSuggestions() {
    // Check if we're on the correct page
    if (!document.getElementById('suggestionForm')) {
        return; // Not on question-suggestions.html, skip initialization
    }
    
    getCurrentUser();
    loadMyStats();
    loadMySuggestions();
    setupFormSubmission();
    setupFilters();
    // checkForNotifications(); // Removed old notification check
    setupCustomCategoryToggle();
    setupScrollObserver(); // NEW: Mark updates as seen on scroll
    setupDelegation();
}

// ==========================
// Ø¥Ø¹Ø¯Ø§Ø¯ ØªÙÙˆÙŠØ¶ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« (Event Delegation)
// ==========================
function setupDelegation() {
    const container = document.getElementById('suggestionsContainer');
    if (!container) return;

    container.addEventListener('click', function(e) {
        const editBtn = e.target.closest('.btn-edit-suggestion');
        if (editBtn) {
            const id = editBtn.dataset.id;
            console.log('ğŸ”˜ Edit button clicked (Delegated) for ID:', id);
            if (window.openEditModal) {
                window.openEditModal(id);
            } else {
                console.error('âŒ openEditModal function is not defined');
            }
        }
    });
}

// ==========================
// Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„ØªÙ…Ø±ÙŠØ± Ù„ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©
// ==========================
function setupScrollObserver() {
    const suggestionsList = document.getElementById('suggestionsContainer');
    if (!suggestionsList) return;

    // Create an intersection observer to detect when the list is viewed
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                markUpdatesAsSeen();
                // Disconnect after marking as seen to avoid repeated calls
                observer.disconnect();
            }
        });
    }, { threshold: 0.1 }); // Trigger when 10% of the list is visible

    observer.observe(suggestionsList);
}

// ==========================
// ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø¥Ù„Ù‰ "Ù…Ù‚Ø±ÙˆØ¡Ø©"
// ==========================
async function markUpdatesAsSeen() {
    try {
        console.log('ğŸ‘€ [Suggestions] Marking updates as seen...');
        const response = await utils.authedFetch('/api/question-suggestions/mark-seen', {
            method: 'POST'
        });
        
        if (response.ok) {
            console.log('âœ… [Suggestions] Updates marked as seen');
            // Update the global counter immediately
            if (typeof loadGlobalUnreadCount === 'function') {
                loadGlobalUnreadCount();
            }
        }
    } catch (error) {
        console.error('âŒ [Suggestions] Error marking updates as seen:', error);
    }
}

// ==========================
// Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ
// ==========================
async function getCurrentUser() {
    try {
        const response = await utils.authedFetch('/api/users/me');
        const data = await response.json();
        
        if (data.success && data.user) {
            currentUser = data.user;
            document.getElementById('employeeName').textContent = currentUser.full_name;
        }
    } catch (error) {
        console.error('Error fetching current user:', error);
        utils.showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…', 'error');
    }
}

// ==========================
// ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
// ==========================
async function loadMyStats() {
    try {
        const response = await utils.authedFetch('/api/question-suggestions/my-stats');
        const data = await response.json();
        
        if (data.success) {
            myStats = data.data;
            displayStats(myStats);
        }
    } catch (error) {
        console.error('Error loading stats:', error);
    }
}

function displayStats(stats) {
    const statPending = document.getElementById('statPending');
    const statApproved = document.getElementById('statApproved');
    const statRejected = document.getElementById('statRejected');
    const statRevision = document.getElementById('statRevision');
    
    if (statPending) statPending.textContent = stats.pending || 0;
    if (statApproved) statApproved.textContent = stats.approved || 0;
    if (statRejected) statRejected.textContent = stats.rejected || 0;
    if (statRevision) statRevision.textContent = stats.needs_revision || 0;
}

// Removed unused displayStars function

// ==========================
// ØªØ­Ù…ÙŠÙ„ Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ø§Ù„Ù…ÙˆØ¸Ù
// ==========================
async function loadMySuggestions(status = '') {
    try {
        let url = '/api/question-suggestions/my-suggestions';
        if (status) {
            url += `?status=${status}`;
        }
        
        const response = await utils.authedFetch(url);
        const data = await response.json();
        
        if (data.success) {
            allMySuggestions = data.data;
            displayMySuggestions(allMySuggestions);
        }
    } catch (error) {
        console.error('Error loading suggestions:', error);
        utils.showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª', 'error');
    }
}

function displayMySuggestions(suggestions) {
    const container = document.getElementById('suggestionsContainer');
    
    if (!suggestions || suggestions.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <i class="fas fa-inbox fa-3x text-muted mb-3"></i>
                <p class="text-muted">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ø¨Ø¹Ø¯</p>
                <p class="text-muted small">Ù‚Ù… Ø¨Ø¥Ø¶Ø§ÙØ© Ø§Ù‚ØªØ±Ø§Ø­ Ø³Ø¤Ø§Ù„ Ø¬Ø¯ÙŠØ¯ Ù…Ù† Ø§Ù„Ø£Ø¹Ù„Ù‰</p>
            </div>
        `;
        return;
    }
    // ØªØ¬Ù…ÙŠØ¹ Ø­Ø³Ø¨ Ø§Ù„Ø­Ø§Ù„Ø©
    const groups = {
        pending: [],
        approved: [],
        rejected: [],
        needs_revision: []
    };
    for (const s of suggestions) {
        if (groups[s.status]) {
            groups[s.status].push(s);
        } else {
            // Ø­Ø§Ù„Ø§Øª ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø©
            if (!groups['pending']) groups['pending'] = [];
            groups['pending'].push(s);
        }
    }
    const titles = {
        pending: 'Ù‚ÙŠØ¯ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©',
        needs_revision: 'ØªØ­ØªØ§Ø¬ ØªØ¹Ø¯ÙŠÙ„',
        approved: 'Ù…Ù‚Ø¨ÙˆÙ„Ø©',
        rejected: 'Ù…Ø±ÙÙˆØ¶Ø©'
    };
    
    // ØªØ±ØªÙŠØ¨ Ù…Ø®ØµØµ Ù„Ù„Ø¹Ø±Ø¶
    const statusOrder = ['pending', 'needs_revision', 'approved', 'rejected'];
    
    let html = '';
    statusOrder.forEach(status => {
        const list = groups[status];
        if (!list || list.length === 0) return; // Ù„Ø§ ØªØ¸Ù‡Ø± Ø§Ù„Ù‚Ø³Ù… Ø§Ù„ÙØ§Ø±Øº
        html += `
            <div class="status-group ${status}" data-status="${status}">
                <div class="status-group-header" role="button" tabindex="0" aria-expanded="true">
                    <span class="toggle-icon"><i class="fas fa-chevron-down"></i></span>
                    <i class="fas fa-layer-group"></i>
                    <span class="group-title">${titles[status]}</span>
                    <span class="count">(${list.length})</span>
                </div>
                <div class="status-group-body">
                    ${list.map(item => createSuggestionCard(item)).join('')}
                </div>
            </div>
        `;
    });
    container.innerHTML = html;

    // Ø¥Ø¶Ø§ÙØ© event listeners Ù„Ù„Ø·ÙŠ ÙˆØ§Ù„ÙØªØ­
    document.querySelectorAll('.status-group-header').forEach(header => {
        header.addEventListener('click', function() {
            const body = this.nextElementSibling;
            const icon = this.querySelector('.toggle-icon i');
            const isExpanded = this.getAttribute('aria-expanded') === 'true';
            
            if (isExpanded) {
                body.style.display = 'none';
                icon.classList.remove('fa-chevron-down');
                icon.classList.add('fa-chevron-left');
                this.setAttribute('aria-expanded', 'false');
            } else {
                body.style.display = 'grid';
                icon.classList.remove('fa-chevron-left');
                icon.classList.add('fa-chevron-down');
                this.setAttribute('aria-expanded', 'true');
            }
        });
    });
}

function createSuggestionCard(suggestion) {
    const statusBadge = getStatusBadge(suggestion.status);
    const hasEvaluation = suggestion.evaluation && suggestion.evaluation.feedback;
    const date = new Date(suggestion.createdAt).toLocaleDateString('ar-EG');
        const isNewEvaluation = !suggestion.employee_notified && hasEvaluation && suggestion.status !== 'pending';
        const newBadge = isNewEvaluation ? '<span class="badge bg-danger">Ø¬Ø¯ÙŠØ¯!</span>' : '';
    const categoryDisplay = suggestion.category === 'other' && suggestion.custom_category
        ? `<span class="category-badge">${suggestion.custom_category}</span>`
        : `<span class="category-badge">${getCategoryLabel(suggestion.category)}</span>`;
    
    return `
        <div class="suggestion-card ${suggestion.status} ${isNewEvaluation ? 'new-evaluation' : ''}">
            <div class="card-header">
                <div>
                                        ${newBadge}
                    ${statusBadge}
                    ${categoryDisplay}
                    <span class="difficulty-badge ${suggestion.difficulty}">${getDifficultyLabel(suggestion.difficulty)}</span>
                </div>
                <div class="date">${date}</div>
            </div>
            
            <div class="card-body">
                <div class="question-text">
                    <strong>Ø§Ù„Ø³Ø¤Ø§Ù„:</strong>
                    <p>${suggestion.question}</p>
                </div>
                
                <div class="answer-text">
                    <strong>Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©:</strong>
                    <p class="text-success">${suggestion.correct_answer}</p>
                </div>
                
                ${hasEvaluation ? `
                    <div class="evaluation-section">
                        <div class="evaluation-header">
                            <i class="fas fa-clipboard-check"></i>
                            <strong>Ø§Ù„ØªÙ‚ÙŠÙŠÙ…:</strong>
                        </div>
                        ${suggestion.evaluation.rating ? `
                            <div class="rating-display">
                                ${getRatingStars(suggestion.evaluation.rating)}
                                <span>${suggestion.evaluation.rating}/5</span>
                            </div>
                        ` : ''}
                        ${suggestion.evaluation.feedback ? `
                            <div class="feedback-text">
                                <i class="fas fa-comment-dots"></i>
                                ${suggestion.evaluation.feedback}
                            </div>
                        ` : ''}
                        <div class="reviewer-info">
                            <i class="fas fa-user-tie"></i>
                            ØªÙ… Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø¨ÙˆØ§Ø³Ø·Ø©: ${suggestion.evaluation.reviewed_by_name}
                        </div>
                    </div>
                ` : ''}
            </div>
            
            ${suggestion.status === 'needs_revision' ? `
                <div class="card-footer text-end mt-3 pt-3 border-top border-secondary">
                    <button class="btn btn-warning btn-sm btn-edit-suggestion" data-id="${suggestion._id}">
                        <i class="fas fa-edit"></i> ØªØ¹Ø¯ÙŠÙ„ ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø¥Ø±Ø³Ø§Ù„
                    </button>
                </div>
            ` : ''}
        </div>
    `;
}

function getStatusBadge(status) {
    const badges = {
        pending: '<span class="status-badge pending"><i class="fas fa-clock"></i> Ù‚ÙŠØ¯ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©</span>',
        approved: '<span class="status-badge approved"><i class="fas fa-check-circle"></i> Ù…Ù‚Ø¨ÙˆÙ„</span>',
        rejected: '<span class="status-badge rejected"><i class="fas fa-times-circle"></i> Ù…Ø±ÙÙˆØ¶</span>',
        needs_revision: '<span class="status-badge needs-revision"><i class="fas fa-edit"></i> ÙŠØ­ØªØ§Ø¬ ØªØ¹Ø¯ÙŠÙ„</span>'
    };
    return badges[status] || '';
}

function getCategoryLabel(category) {
    const labels = {
        trading: 'ØªØ¯Ø§ÙˆÙ„ÙŠØ©',
        interactive: 'ØªÙØ§Ø¹Ù„ÙŠØ©',
        company_features: 'Ù…Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø´Ø±ÙƒØ©',
        educational: 'ØªØ¹Ù„ÙŠÙ…ÙŠØ©',
        highlight_site: 'ØªØ¨Ø±Ø² Ø§Ù„Ù…ÙˆÙ‚Ø¹',
        other: 'Ø§Ø®Ø±ÙŠ'
    };
    return labels[category] || category;
}

function getDifficultyLabel(difficulty) {
    const labels = {
        easy: 'Ø³Ù‡Ù„',
        medium: 'Ù…ØªÙˆØ³Ø·',
        hard: 'ØµØ¹Ø¨'
    };
    return labels[difficulty] || difficulty;
}

function getRatingStars(rating) {
    let html = '';
    for (let i = 1; i <= 5; i++) {
        if (i <= rating) {
            html += '<i class="fas fa-star text-warning"></i>';
        } else {
            html += '<i class="far fa-star text-muted"></i>';
        }
    }
    return html;
}

// ==========================
// Ø¥Ø±Ø³Ø§Ù„ Ø§Ù‚ØªØ±Ø§Ø­ Ø¬Ø¯ÙŠØ¯
// ==========================
function setupFormSubmission() {
    const form = document.getElementById('suggestionForm');
    if (!form) return; // Form not found, skip
    
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const question = document.getElementById('question').value.trim();
        const answer = document.getElementById('correct_answer').value.trim();
        const category = document.getElementById('category').value;
        const difficulty = document.getElementById('difficulty').value;
        const custom_category = document.getElementById('custom_category')?.value.trim() || '';
        const additional_notes = document.getElementById('additional_notes')?.value.trim() || '';
        
        if (!question || !answer) {
            utils.showToast('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø³Ø¤Ø§Ù„ ÙˆØ§Ù„Ø¥Ø¬Ø§Ø¨Ø©', 'warning');
            return;
        }
        
        const submitBtn = form.querySelector('button[type="submit"]');
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...';
        
        try {
            const payload = { 
                question, 
                correct_answer: answer, 
                category, 
                difficulty,
                additional_notes
            };
            if (category === 'other') {
                payload.custom_category = custom_category;
            }
            
            console.log('ğŸš€ [Employee Suggestion] Sending suggestion:', payload);
            
            const response = await utils.authedFetch('/api/question-suggestions/submit', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            const data = await response.json();
            
            console.log('âœ… [Employee Suggestion] Server response:', data);
            
            if (data.success) {
                console.log('âœ… [Employee Suggestion] Suggestion saved successfully with ID:', data.data?._id);
                utils.showToast('ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­ Ø¨Ù†Ø¬Ø§Ø­! Ø³ÙŠØªÙ… Ù…Ø±Ø§Ø¬Ø¹ØªÙ‡ Ù‚Ø±ÙŠØ¨Ø§Ù‹', 'success');
                form.reset();
                loadMyStats();
                loadMySuggestions();
            } else {
                console.error('âŒ [Employee Suggestion] Failed to save:', data.message);
                utils.showToast(data.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£', 'error');
            }
        } catch (error) {
            console.error('âŒ [Employee Suggestion] Error submitting suggestion:', error);
            utils.showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­', 'error');
        } finally {
            submitBtn.disabled = false;
            submitBtn.innerHTML = '<i class="fas fa-paper-plane"></i> Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­';
        }
    });
}

// ==========================
// Ø¥Ø¸Ù‡Ø§Ø±/Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ØªØµÙ†ÙŠÙ Ø§Ù„Ù…Ø®ØµØµ
// ==========================
function setupCustomCategoryToggle() {
    const categorySelect = document.getElementById('category');
    const customGroup = document.getElementById('customCategoryGroup');
    if (!categorySelect || !customGroup) return;
    categorySelect.addEventListener('change', function() {
        if (this.value === 'other') {
            customGroup.style.display = 'block';
        } else {
            customGroup.style.display = 'none';
            const customInput = document.getElementById('custom_category');
            if (customInput) customInput.value = '';
        }
    });
}

// ==========================
// Ø§Ù„ÙÙ„Ø§ØªØ±
// ==========================
let allMySuggestions = [];
let currentStatusFilter = '';

function setupFilters() {
    const filterButtons = document.querySelectorAll('.filter-btn');
    filterButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            filterButtons.forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            
            currentStatusFilter = this.dataset.status;
            loadMySuggestions(currentStatusFilter);
        });
    });
    
    // Advanced search setup
    const applySearchBtn = document.getElementById('applySearchBtn');
    const resetSearchBtn = document.getElementById('resetSearchBtn');
    const searchText = document.getElementById('searchText');
    
    if (applySearchBtn) {
        applySearchBtn.addEventListener('click', () => {
            applyAdvancedSearch();
        });
    }
    
    if (resetSearchBtn) {
        resetSearchBtn.addEventListener('click', () => {
            document.getElementById('searchText').value = '';
            document.getElementById('filterDateFrom').value = '';
            document.getElementById('filterDateTo').value = '';
            document.getElementById('filterCategory').value = '';
            displayMySuggestions(allMySuggestions);
        });
    }
    
    // Real-time search on typing
    if (searchText) {
        searchText.addEventListener('input', debounce(() => {
            applyAdvancedSearch();
        }, 500));
    }
}

// Apply advanced search
function applyAdvancedSearch() {
    const searchText = document.getElementById('searchText')?.value.toLowerCase().trim();
    const dateFrom = document.getElementById('filterDateFrom')?.value;
    const dateTo = document.getElementById('filterDateTo')?.value;
    const category = document.getElementById('filterCategory')?.value;
    
    let filtered = [...allMySuggestions];
    
    // Filter by search text
    if (searchText) {
        filtered = filtered.filter(s => 
            s.question?.toLowerCase().includes(searchText) ||
            s.correct_answer?.toLowerCase().includes(searchText)
        );
    }
    
    // Filter by date range
    if (dateFrom) {
        const fromDate = new Date(dateFrom);
        fromDate.setHours(0, 0, 0, 0);
        filtered = filtered.filter(s => {
            const suggestionDate = new Date(s.createdAt);
            suggestionDate.setHours(0, 0, 0, 0);
            return suggestionDate >= fromDate;
        });
    }
    
    if (dateTo) {
        const toDate = new Date(dateTo);
        toDate.setHours(23, 59, 59, 999);
        filtered = filtered.filter(s => {
            const suggestionDate = new Date(s.createdAt);
            return suggestionDate <= toDate;
        });
    }
    
    // Filter by category
    if (category) {
        filtered = filtered.filter(s => s.category === category);
    }
    
    console.log('[EmployeeSuggest] Advanced search applied. Results:', filtered.length);
    displayMySuggestions(filtered);
}

// Debounce helper function
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// ==========================
// Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
// ==========================
document.addEventListener('DOMContentLoaded', initQuestionSuggestions);

// Ø¥Ø¶Ø§ÙØ© Ù†Ù…Ø· Ù…Ø¨Ø³Ø· Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø¥Ù† Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹ Ø¹Ø¨Ø± CSS Ø§Ù„Ø¹Ø§Ù…
const styleGrouping = document.createElement('style');
styleGrouping.textContent = `
    .status-group { margin-bottom: 35px; }
    .status-group-header { 
        background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
        color:#fff; padding:10px 16px; border-radius:10px; font-weight:600; display:flex; align-items:center; gap:8px; box-shadow:0 2px 8px rgba(0,0,0,0.25);
        cursor:pointer;
    }
    .status-group-header .count { font-weight:400; font-size:0.85rem; opacity:.9; margin-right:auto; }
    .status-group-header .toggle-icon { transition: transform .25s ease; display:inline-flex; }
    .status-group.collapsed .status-group-header .toggle-icon { transform: rotate(-90deg); }
    .status-group-body { margin-top:15px; display:grid; gap:18px; }
    @media (min-width:992px){ .status-group-body { grid-template-columns:repeat(auto-fill,minmax(420px,1fr)); } }
    @media (max-width:991px){ .status-group-body { grid-template-columns:1fr; } }
    .status-group.collapsed .status-group-body { display:none; }
    .status-group-header:focus { outline:2px solid #fff; outline-offset:2px; }
`;
document.head.appendChild(styleGrouping);

// ØªÙÙˆÙŠØ¶ Ø­Ø¯Ø« Ø§Ù„Ø·ÙŠ/Ø§Ù„ÙØªØ­ Ø¨Ø§Ù„Ù…Ø§ÙˆØ³
document.addEventListener('click', function(e){
    const header = e.target.closest('.status-group-header');
    if (!header) return;
    const group = header.parentElement;
    const isCollapsed = group.classList.toggle('collapsed');
    header.setAttribute('aria-expanded', (!isCollapsed).toString());
});

// ==========================
// ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­
// ==========================
window.openEditModal = function(id) {
    console.log('ğŸ“ [Edit] Opening modal for ID:', id);
    
    if (!allMySuggestions || allMySuggestions.length === 0) {
        console.error('âŒ [Edit] No suggestions loaded');
        utils.showToast('Ø­Ø¯Ø« Ø®Ø·Ø£: Ù„Ù… ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 'error');
        return;
    }

    const suggestion = allMySuggestions.find(s => s._id === id);
    if (!suggestion) {
        console.error('âŒ [Edit] Suggestion not found in local list:', id);
        utils.showToast('Ø­Ø¯Ø« Ø®Ø·Ø£: Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', 'error');
        return;
    }

    document.getElementById('editSuggestionId').value = suggestion._id;
    document.getElementById('editQuestion').value = suggestion.question;
    document.getElementById('editAnswer').value = suggestion.correct_answer;
    document.getElementById('editCategory').value = suggestion.category;
    document.getElementById('editDifficulty').value = suggestion.difficulty;
    document.getElementById('editNotes').value = suggestion.additional_notes || '';
    
    const customGroup = document.getElementById('editCustomCategoryGroup');
    const customInput = document.getElementById('editCustomCategory');
    
    if (suggestion.category === 'other') {
        customGroup.style.display = 'block';
        customInput.value = suggestion.custom_category || '';
    } else {
        customGroup.style.display = 'none';
        customInput.value = '';
    }

    // Setup category change listener for edit modal
    const categorySelect = document.getElementById('editCategory');
    if (categorySelect) {
        categorySelect.onchange = function() {
            if (this.value === 'other') {
                customGroup.style.display = 'block';
            } else {
                customGroup.style.display = 'none';
            }
        };
    }

    try {
        const modalEl = document.getElementById('editSuggestionModal');
        const modal = new bootstrap.Modal(modalEl);
        modal.show();
    } catch (e) {
        console.error('âŒ [Edit] Error showing modal:', e);
        utils.showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ÙØªØ­ Ø§Ù„Ù†Ø§ÙØ°Ø©', 'error');
    }
};

// Setup Edit Form Submission
document.addEventListener('DOMContentLoaded', () => {
    const editForm = document.getElementById('editSuggestionForm');
    if (editForm) {
        editForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const id = document.getElementById('editSuggestionId').value;
            const submitBtn = editForm.querySelector('button[type="submit"]');
            const originalBtnText = submitBtn.innerHTML;
            
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...';
            
            try {
                const formData = {
                    question: document.getElementById('editQuestion').value,
                    correct_answer: document.getElementById('editAnswer').value,
                    category: document.getElementById('editCategory').value,
                    difficulty: document.getElementById('editDifficulty').value,
                    additional_notes: document.getElementById('editNotes').value,
                    custom_category: document.getElementById('editCustomCategory').value
                };

                const response = await utils.authedFetch(`/api/question-suggestions/${id}/update`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(formData)
                });

                const data = await response.json();

                if (data.success) {
                    utils.showToast('ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­ ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø¥Ø±Ø³Ø§Ù„Ù‡ Ø¨Ù†Ø¬Ø§Ø­', 'success');
                    bootstrap.Modal.getInstance(document.getElementById('editSuggestionModal')).hide();
                    loadMySuggestions();
                    loadMyStats();
                } else {
                    utils.showToast(data.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£', 'error');
                }
            } catch (error) {
                console.error('Error updating suggestion:', error);
                utils.showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­', 'error');
            } finally {
                submitBtn.disabled = false;
                submitBtn.innerHTML = originalBtnText;
            }
        });
    }
});

// Ø¯Ø¹Ù… Enter Ùˆ Space Ù„Ù„ÙˆÙ„ÙˆØ¬ Ø¹Ø¨Ø± Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
document.addEventListener('keydown', function(e){
    if ((e.key === 'Enter' || e.key === ' ') && e.target.classList.contains('status-group-header')) {
        e.preventDefault();
        e.target.click();
    }
});


// == admin-question-suggestions.js ==
// ==========================
// Ù†Ø¸Ø§Ù… Ø§Ù‚ØªØ±Ø§Ø­ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© - Ù„Ù„Ø¥Ø¯Ø§Ø±Ø©
// ==========================

let allSuggestions = [];
let stats = null;
let adminSuggestionsCurrentFilter = 'pending';
let currentUserRole = null; // Track user role
let isSuperAdmin = false; // Track if user is super admin
let currentEvaluatedSuggestion = null;
let suggestionTemplateModalInstance = null;
let suggestionTemplateData = null;
let templateQuestionCheckTimeout = null;

// ==========================
// Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
// ==========================
async function initAdminQuestionSuggestions() {
    // Check if we're on the correct page
    if (!document.getElementById('adminSuggestionsContainer')) {
        return; // Not on admin-question-suggestions.html, skip initialization
    }
    
    // Check user permissions and get role
    const userInfo = await checkUserAccess();
    if (!userInfo) {
        const appContent = document.getElementById('app-content');
        if (appContent) {
            appContent.innerHTML = `
                <div style="text-align: center; padding: 50px;">
                    <i class="fas fa-exclamation-triangle fa-3x text-warning mb-3"></i>
                    <h3>Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª</h3>
                    <p>Ù„Ù… Ù†ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ§ØªÙƒ</p>
                    <a href="#home" class="btn btn-primary mt-3">
                        <i class="fas fa-home"></i> Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
                    </a>
                </div>
            `;
        }
        return;
    }
    
    currentUserRole = userInfo.role;
    isSuperAdmin = userInfo.role === 'super_admin'; // ÙÙ‚Ø· Ø§Ù„Ø³ÙˆØ¨Ø± Ø£Ø¯Ù…Ù† Ù„Ù‡ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ØªÙ‚ÙŠÙŠÙ… ÙˆØ§Ù„Ø­Ø°Ù
    
    // Ø¹Ø±Ø¶ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (Ù…ÙˆØ¸ÙØŒ Ø£Ø¯Ù…Ù†ØŒ Ø³ÙˆØ¨Ø± Ø£Ø¯Ù…Ù†)
    // ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ØªÙ‚ÙŠÙŠÙ… ÙˆØ§Ù„Ø­Ø°Ù: Ø§Ù„Ø³ÙˆØ¨Ø± Ø£Ø¯Ù…Ù† ÙÙ‚Ø·
    
    loadStats();
    loadUnreadCount(); // Load unread suggestions count for super admin
    loadAllSuggestions();
    setupFilters();
    setupEvaluationModal();
    setupCardDelegation();
    setupSuggestionTemplateModalHandlers();
}

// ==========================
// Ù…Ù„Ø§Ø­Ø¸Ø©: ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø¯Ø§Ù„Ø© hideAdminElements
// Ù„Ø£Ù† Ø§Ù„ØµÙØ­Ø© Ø£ØµØ¨Ø­Øª Ù…ØªØ§Ø­Ø© Ù„Ø¹Ø±Ø¶ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ù„Ù„Ø¬Ù…ÙŠØ¹
// ==========================
// ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„ØªÙ‚ÙŠÙŠÙ… ÙˆØ§Ù„Ø­Ø°Ù: Ø§Ù„Ø³ÙˆØ¨Ø± Ø£Ø¯Ù…Ù† ÙÙ‚Ø·
// Ø§Ù„Ù…ÙˆØ¸ÙÙˆÙ† ÙˆØ§Ù„Ø£Ø¯Ù…Ù†: ÙŠÙ…ÙƒÙ†Ù‡Ù… Ø§Ù„Ø¹Ø±Ø¶ ÙÙ‚Ø·

// ==========================
// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
// ==========================
async function checkUserAccess() {
    try {
        const response = await utils.authedFetch('/api/auth/me');
        
        if (!response.ok) {
            return null;
        }
        
        const data = await response.json();
        
        // API returns user object directly, not wrapped in success/user
        if (data && data.role) {
            return {
                role: data.role,
                name: data.full_name
            };
        }
        
        return null;
    } catch (error) {
        return null;
    }
}

// ==========================
// ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
// ==========================
async function loadStats() {
    try {
        const response = await utils.authedFetch('/api/question-suggestions/all?page=1&limit=1');
        
        if (!response.ok) {
            return;
        }
        
        const data = await response.json();
        
        if (data.success && data.stats) {
            stats = data.stats;
            displayStats(stats);
        }
    } catch (error) {
        // Silent fail
    }
}

function displayStats(stats) {
    document.getElementById('totalCount').textContent = stats.total || 0;
    document.getElementById('pendingCount').textContent = stats.pending || 0;
    document.getElementById('approvedCount').textContent = stats.approved || 0;
    document.getElementById('rejectedCount').textContent = stats.rejected || 0;
    document.getElementById('revisionCount').textContent = stats.needs_revision || 0;

    // Update header badge with pending count (show only if > 0)
    const pendingBadge = document.getElementById('pendingHeaderCountBadge');
    const pendingHeaderCount = document.getElementById('pendingHeaderCount');
    if (pendingBadge && pendingHeaderCount) {
        const pending = stats.pending || 0;
        pendingHeaderCount.textContent = pending;
        pendingBadge.style.display = pending > 0 ? 'inline-flex' : 'none';
    }
}

// ==========================
// ØªØ­Ù…ÙŠÙ„ Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª ØºÙŠØ± Ø§Ù„Ù…Ù‚Ø±ÙˆØ¡Ø©
// ==========================
async function loadUnreadCount() {

    try {
        
        // Determine endpoint based on role
        const endpoint = isSuperAdmin 
            ? '/api/question-suggestions/unread-count' 
            : '/api/question-suggestions/employee-unread-count';
            
        const response = await utils.authedFetch(endpoint);


        if (!response.ok) {
            return;
        }

        const data = await response.json();

        if (data.success) {
            const unreadCount = data.data.unreadCount || 0;
            displayUnreadCount(unreadCount);
        }
    } catch (error) {
        console.error('âŒ [Unread Count] Error loading unread count:', error);
    }
}

function displayUnreadCount(count) {
    const unreadCounter = document.getElementById('pendingHeaderCountBadge');
    const unreadCountElement = document.getElementById('pendingHeaderCount');

    if (unreadCounter && unreadCountElement) {
        if (count > 0) {
            unreadCountElement.textContent = count;
            unreadCounter.style.display = 'inline-flex'; // Use inline-flex to match HTML style
        } else {
            unreadCounter.style.display = 'none';
        }
    }
}

// ==========================
// ØªØ­Ù…ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª
// ==========================
async function loadAllSuggestions(status = 'pending') {
    try {
        // Ø¹Ø±Ø¶ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
        const url = status && status !== 'all'
            ? `/api/question-suggestions/all?status=${status}&limit=100`
            : `/api/question-suggestions/all?limit=100`;
        
        const response = await utils.authedFetch(url);
        
        const data = await response.json();
        
        if (data.success) {
            allSuggestions = data.data;
            
            displayAllSuggestions(allSuggestions);
            loadEmployeeList(); // Load employee dropdown after data is loaded
        } else {
            console.error('âŒ [Admin Suggestions] Failed to load:', data.message);
        }
    } catch (error) {
        console.error('âŒ [Admin Suggestions] Error loading suggestions:', error);
        utils.showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª', 'error');
    }
}

function displayAllSuggestions(suggestions) {
    const container = document.getElementById('adminSuggestionsContainer');
    
    if (!suggestions || suggestions.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <i class="fas fa-inbox fa-3x text-muted mb-3"></i>
                <p class="text-muted">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„ÙØ¦Ø©</p>
            </div>
        `;
        return;
    }
    
    let html = '';
    suggestions.forEach(suggestion => {
        html += createAdminSuggestionCard(suggestion);
    });
    
    container.innerHTML = html; // Ù…Ø­ØªÙˆÙ‰ Ø¬Ø¯ÙŠØ¯ Ø¬Ø§Ù‡Ø² Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„ØªÙÙˆÙŠØ¶
}

function createAdminSuggestionCard(suggestion) {
    const statusBadge = getStatusBadge(suggestion.status);
    const date = new Date(suggestion.createdAt).toLocaleDateString('ar-EG', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    });
    
    const hasEvaluation = suggestion.evaluation && suggestion.evaluation.feedback;
    const canEvaluate = suggestion.status === 'pending' || suggestion.status === 'needs_revision';
    
    const categoryDisplay = suggestion.category === 'other' && suggestion.custom_category
        ? `<span class="category-badge">${suggestion.custom_category}</span>`
        : `<span class="category-badge">${getCategoryLabel(suggestion.category)}</span>`;

    return `
        <div class="admin-suggestion-card ${suggestion.status}" data-id="${suggestion._id}">
            <div class="card-header">
                <div class="employee-info">
                    <i class="fas fa-user"></i>
                    <strong>${suggestion.suggested_by_name}</strong>
                    <span class="date">${date}</span>
                </div>
                <div class="badges">
                    ${statusBadge}
                    ${categoryDisplay}
                    <span class="difficulty-badge ${suggestion.difficulty}">${getDifficultyLabel(suggestion.difficulty)}</span>
                </div>
            </div>
            
            <div class="card-body">
                <div class="question-section">
                    <div class="section-title">
                        <i class="fas fa-question-circle"></i>
                        Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„Ù…Ù‚ØªØ±Ø­:
                    </div>
                    <p class="question-text">${suggestion.question}</p>
                </div>
                
                <div class="answer-section">
                    <div class="section-title">
                        <i class="fas fa-check-circle"></i>
                        Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©:
                    </div>
                    <p class="answer-text">${suggestion.correct_answer}</p>
                </div>
                
                ${hasEvaluation ? `
                    <div class="previous-evaluation">
                        <div class="section-title">
                            <i class="fas fa-clipboard-check"></i>
                            Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø³Ø§Ø¨Ù‚:
                        </div>
                        ${suggestion.evaluation.rating ? `
                            <div class="rating-display">
                                ${getRatingStars(suggestion.evaluation.rating)}
                                <span>${suggestion.evaluation.rating}/5</span>
                            </div>
                        ` : ''}
                        <p class="feedback-text">${suggestion.evaluation.feedback}</p>
                        <p class="reviewer-info">
                            <i class="fas fa-user-tie"></i>
                            ${suggestion.evaluation.reviewed_by_name} - 
                            ${new Date(suggestion.evaluation.reviewed_at).toLocaleDateString('ar-EG')}
                        </p>
                    </div>
                ` : ''}
            </div>
            
            ${isSuperAdmin ? `
                <div class="card-footer">
                    ${canEvaluate ? `
                        <button class="btn btn-success" data-action="evaluate" data-status="approved" data-id="${suggestion._id}">
                            <i class="fas fa-check"></i> Ù‚Ø¨ÙˆÙ„
                        </button>
                        <button class="btn btn-warning" data-action="evaluate" data-status="needs_revision" data-id="${suggestion._id}">
                            <i class="fas fa-edit"></i> ÙŠØ­ØªØ§Ø¬ ØªØ¹Ø¯ÙŠÙ„
                        </button>
                        <button class="btn btn-danger" data-action="evaluate" data-status="rejected" data-id="${suggestion._id}">
                            <i class="fas fa-times"></i> Ø±ÙØ¶
                        </button>
                    ` : `
                        <button class="btn btn-secondary" data-action="evaluate" data-status="${suggestion.status}" data-id="${suggestion._id}">
                            <i class="fas fa-eye"></i> Ø¹Ø±Ø¶ Ø§Ù„ØªÙØ§ØµÙŠÙ„
                        </button>
                    `}
                    
                    ${(suggestion.status === 'approved' || suggestion.status === 'needs_revision') ? `
                        <button class="btn btn-secondary" data-action="archive" data-id="${suggestion._id}">
                            <i class="fas fa-archive"></i> Ø£Ø±Ø´ÙØ©
                        </button>
                    ` : ''}

                    <button class="btn btn-outline-danger" data-action="delete" data-id="${suggestion._id}">
                        <i class="fas fa-trash"></i> Ø­Ø°Ù
                    </button>
                </div>
            ` : ''}
        </div>
    `;
}

// ==========================
// ÙØªØ­ Ù†Ø§ÙØ°Ø© Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
// ==========================
function openEvaluationModal(suggestionId, status) {
    
    // ÙØ­Øµ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø³ÙˆØ¨Ø± Ø£Ø¯Ù…Ù†
    if (!isSuperAdmin) {
        utils.showToast('Ù‡Ø°Ù‡ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ù…ØªØ§Ø­Ø© Ù„Ù„Ù…Ø¯ÙŠØ± Ø§Ù„Ø¹Ø§Ù… ÙÙ‚Ø·', 'error');
        return;
    }
    
    const suggestion = allSuggestions.find(s => s._id === suggestionId);
    if (!suggestion) {
        return;
    }
    currentEvaluatedSuggestion = {
        ...suggestion,
        evaluation: suggestion.evaluation ? { ...suggestion.evaluation } : null
    };
    
    // ØªØ¹Ø¨Ø¦Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    document.getElementById('evalSuggestionId').value = suggestionId;
    document.getElementById('evalEmployeeName').textContent = suggestion.suggested_by_name;
    document.getElementById('evalQuestion').textContent = suggestion.question;
    document.getElementById('evalAnswer').textContent = suggestion.correct_answer;
    document.getElementById('evalStatus').value = status;
    
    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ ØªÙ‚ÙŠÙŠÙ… Ø³Ø§Ø¨Ù‚
    if (suggestion.evaluation) {
        document.getElementById('evalRating').value = suggestion.evaluation.rating || '';
        document.getElementById('evalFeedback').value = suggestion.evaluation.feedback || '';
        document.getElementById('evalNotes').value = suggestion.evaluation.admin_notes || '';
    } else {
        document.getElementById('evalRating').value = '';
        document.getElementById('evalFeedback').value = '';
        document.getElementById('evalNotes').value = '';
    }
    
    // ÙØªØ­ Ø§Ù„Ù†Ø§ÙØ°Ø©
    const modal = new bootstrap.Modal(document.getElementById('evaluationModal'));
    modal.show();
}

// ==========================
// Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
// ==========================
function setupEvaluationModal() {
    const form = document.getElementById('evaluationForm');
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        // ÙØ­Øµ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø³ÙˆØ¨Ø± Ø£Ø¯Ù…Ù†
        if (!isSuperAdmin) {
            utils.showToast('Ù‡Ø°Ù‡ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ù…ØªØ§Ø­Ø© Ù„Ù„Ù…Ø¯ÙŠØ± Ø§Ù„Ø¹Ø§Ù… ÙÙ‚Ø·', 'error');
            return;
        }
        
        const suggestionId = document.getElementById('evalSuggestionId').value;
        const status = document.getElementById('evalStatus').value;
        const rating = parseInt(document.getElementById('evalRating').value) || null;
        const feedback = document.getElementById('evalFeedback').value.trim();
        const admin_notes = document.getElementById('evalNotes').value.trim();
        
        if (!feedback && status !== 'approved') {
            utils.showToast('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„ØªÙ‚ÙŠÙŠÙ…', 'warning');
            return;
        }
        
        const submitBtn = form.querySelector('button[type="submit"]');
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...';
        
        const payload = { status, rating, feedback, admin_notes };
        
        try {
            const response = await utils.authedFetch(`/api/question-suggestions/evaluate/${suggestionId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const data = await response.json();
            if (data.success) {
                utils.showToast('ØªÙ… ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­ Ø¨Ù†Ø¬Ø§Ø­', 'success');
                bootstrap.Modal.getInstance(document.getElementById('evaluationModal')).hide();
                if (currentEvaluatedSuggestion && currentEvaluatedSuggestion._id === suggestionId) {
                    currentEvaluatedSuggestion.status = status;
                    currentEvaluatedSuggestion.evaluation = currentEvaluatedSuggestion.evaluation || {};
                    currentEvaluatedSuggestion.evaluation.rating = rating || null;
                    currentEvaluatedSuggestion.evaluation.feedback = feedback || '';
                }
                if (status === 'approved' && currentEvaluatedSuggestion && currentEvaluatedSuggestion._id === suggestionId) {
                    try {
                        showSuggestionTemplateModal(currentEvaluatedSuggestion);
                    } catch (modalError) {
                        console.error('Error opening template modal:', modalError);
                    }
                }
                loadStats();
                loadUnreadCount(); // Update unread count after evaluation
                loadAllSuggestions(adminSuggestionsCurrentFilter);
            } else {
                utils.showToast(data.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£', 'error');
            }
        } catch (error) {
            console.error('Error evaluating suggestion:', error);
            utils.showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­', 'error');
        } finally {
            submitBtn.disabled = false;
            submitBtn.innerHTML = '<i class="fas fa-save"></i> Ø­ÙØ¸ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…';
        }
    });
}

// ==========================
// Ø­ÙØ¸ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­ ÙƒÙ‚Ø§Ù„Ø¨ Ù…Ø³Ø§Ø¨Ù‚Ø©
// ==========================
function setupSuggestionTemplateModalHandlers() {
    const modalEl = document.getElementById('suggestionTemplateModal');
    if (!modalEl) {
        return;
    }

    suggestionTemplateModalInstance = new bootstrap.Modal(modalEl);
    modalEl.addEventListener('hidden.bs.modal', () => {
        suggestionTemplateData = null;
        resetSuggestionTemplateModal();
    });

    const saveBtn = document.getElementById('saveSuggestionTemplateBtn');
    if (saveBtn) {
        saveBtn.addEventListener('click', saveSuggestionAsTemplate);
    }

    const skipBtn = document.getElementById('skipSuggestionTemplateBtn');
    if (skipBtn) {
        skipBtn.addEventListener('click', () => {
            suggestionTemplateData = null;
        });
    }

    const questionInput = document.getElementById('templateSuggestionQuestionInput');
    if (questionInput) {
        questionInput.addEventListener('input', () => {
            if (templateQuestionCheckTimeout) {
                clearTimeout(templateQuestionCheckTimeout);
            }
            templateQuestionCheckTimeout = setTimeout(() => {
                checkTemplateAvailability(questionInput.value.trim());
            }, 500);
        });
    }
}

function showSuggestionTemplateModal(suggestion) {
    if (!isSuperAdmin || !suggestionTemplateModalInstance || !suggestion) {
        return;
    }

    suggestionTemplateData = { ...suggestion };
    const questionInput = document.getElementById('templateSuggestionQuestionInput');
    const answerInput = document.getElementById('templateSuggestionAnswerInput');
    const classificationSelect = document.getElementById('templateClassificationSelect');
    const typeSelect = document.getElementById('templateTypeSelect');
    const usageLimitInput = document.getElementById('templateUsageLimitInput');
    const contentInput = document.getElementById('templateContentInput');
    const employeeEl = document.getElementById('templateSuggestionEmployee');
    const categoryEl = document.getElementById('templateSuggestionCategory');

    if (questionInput) {
        questionInput.value = suggestion.question || '';
    }
    if (answerInput) {
        answerInput.value = suggestion.correct_answer || '';
    }
    if (classificationSelect) {
        classificationSelect.value = 'All';
    }
    if (typeSelect) {
        typeSelect.value = suggestion.category === 'interactive' ? 'ØªÙØ§Ø¹Ù„ÙŠØ©' : 'Ù…Ù…ÙŠØ²Ø§Øª';
    }
    if (usageLimitInput) {
        usageLimitInput.value = '';
    }
    if (contentInput) {
        contentInput.value = generateTemplateContentFromSuggestion(
            suggestion.question,
            suggestion.correct_answer
        );
        contentInput.setAttribute('readonly', 'true');
        contentInput.setAttribute('disabled', 'true');
    }
    if (employeeEl) {
        employeeEl.textContent = suggestion.suggested_by_name || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ';
    }
    if (categoryEl) {
        categoryEl.textContent = getCategoryLabel(suggestion.category) || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
    }

    const questionText = questionInput ? questionInput.value.trim() : '';
    checkTemplateAvailability(questionText);
    suggestionTemplateModalInstance.show();
}

function resetSuggestionTemplateModal() {
    const form = document.getElementById('suggestionTemplateForm');
    if (form) {
        form.reset();
    }
    const alertEl = document.getElementById('templateSuggestionExistsAlert');
    if (alertEl) {
        alertEl.classList.add('d-none');
        alertEl.textContent = '';
    }
    if (templateQuestionCheckTimeout) {
        clearTimeout(templateQuestionCheckTimeout);
        templateQuestionCheckTimeout = null;
    }
    const contentInput = document.getElementById('templateContentInput');
    if (contentInput) {
        contentInput.value = '';
    }
    const saveBtn = document.getElementById('saveSuggestionTemplateBtn');
    if (saveBtn) {
        saveBtn.disabled = true;
        delete saveBtn.dataset.saving;
        saveBtn.removeAttribute('data-saving');
        saveBtn.innerHTML = '<i class="fas fa-save"></i> Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨';
    }
}

function generateTemplateContentFromSuggestion() {
    return `Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† Ø´Ø±ÙƒØ© Ø¥Ù†Ø²Ùˆ Ù„Ù„ØªØ¯Ø§ÙˆÙ„ ğŸ†

âœ¨ Ù‡Ù„ ØªÙ…Ù„Ùƒ Ø¹ÙŠÙ†Ù‹Ø§ Ø®Ø¨ÙŠØ±Ø© ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø´Ø§Ø±ØªØ§ØªØŸ Ø§Ø®ØªØ¨Ø± Ù†ÙØ³Ùƒ ÙˆØ§Ø±Ø¨Ø­!

ğŸ’° Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©: {{prize_details}}
                 {{deposit_bonus_prize_details}}

â“ Ø³Ø¤Ø§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©:
{{question}}

ğŸ“ ÙƒÙŠÙÙŠØ© Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©:
Ø¶Ø¹ ØªØ¹Ù„ÙŠÙ‚Ùƒ Ø¹Ù„Ù‰ Ù…Ù†Ø´ÙˆØ± Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¨Ø§Ù„Ù‚Ù†Ø§Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø­Ø³Ø§Ø¨Ùƒ Ø§Ù„Ø´Ø®ØµÙŠ Ø¹Ù„Ù‰ ØªÙ„ÙŠØ¬Ø±Ø§Ù….

ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªØ¶Ù…Ù† ØªØ¹Ù„ÙŠÙ‚Ùƒ:
â€¢ Ø¥Ø¬Ø§Ø¨ØªÙƒ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¤Ø§Ù„.
â€¢ Ø§Ø³Ù…Ùƒ Ø§Ù„Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ù…Ø³Ø¬Ù„ Ø¨Ø§Ù„ÙˆØ«Ø§Ø¦Ù‚.
â€¢ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ¯Ø§ÙˆÙ„ÙŠ.

ÙŠÙÙ…Ù†Ø¹ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚ Ø¨Ø¹Ø¯ Ù†Ø´Ø±Ù‡ØŒ ÙˆØ£ÙŠ ØªØ¹Ù„ÙŠÙ‚ Ù…ÙØ¹Ø¯Ù„ Ø³ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¹Ø§Ø¯Ù‡ Ù…Ø¨Ø§Ø´Ø±Ø©.

â³ Ù…Ø¯Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©: {{competition_duration}}

ğŸ“š ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ø¹Ø±ÙØ© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ÙˆØªØ¹Ù„Ù‘Ù… Ø§Ù„Ù…Ø²ÙŠØ¯ Ø¹Ù† Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„ÙÙ†ÙŠØ© ÙˆØ£Ø³Ø§Ù„ÙŠØ¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ±Ø³ Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠ Ø§Ù„Ù…Ù‚Ø¯Ù… Ù…Ù† Ø§Ù„Ø®Ø¨ÙŠØ± Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠ Ø£. Ø´Ø±ÙŠÙ Ø®ÙˆØ±Ø´ÙŠØ¯ Ø¹Ù„Ù‰ Ù…ÙˆÙ‚Ø¹ Ø¥Ù†Ø²Ùˆ. ğŸ†“

âœ¨ Ù„Ø§ ØªÙÙˆØª Ø§Ù„ÙØ±ØµØ©!
Ø¬Ø§ÙˆØ¨ ØµØ­ØŒ Ø§Ø®ØªØ¨Ø± Ù…Ø¹Ø±ÙØªÙƒØŒ ÙˆÙƒÙ† Ø§Ù„ÙØ§Ø¦Ø² Ù…Ø¹ Ø¥Ù†Ø²Ùˆ ğŸ`;
}

async function checkTemplateAvailability(questionText) {
    const alertEl = document.getElementById('templateSuggestionExistsAlert');
    const saveBtn = document.getElementById('saveSuggestionTemplateBtn');

    if (alertEl) {
        alertEl.classList.add('d-none');
        alertEl.textContent = '';
    }

    if (!questionText) {
        if (saveBtn && !saveBtn.dataset.saving) {
            saveBtn.disabled = true;
        }
        return;
    }

    if (saveBtn && !saveBtn.dataset.saving) {
        saveBtn.disabled = false;
        delete saveBtn.dataset.disabledReason;
    }

    try {
        const response = await utils.authedFetch(`/api/templates/check-existence?question=${encodeURIComponent(questionText)}`);
        if (!response.ok) {
            return;
        }
        const data = await response.json();
        if (data.exists) {
            if (alertEl) {
                alertEl.textContent = data.archived
                    ? 'Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø®Ù„ Ù‚Ø§Ù„Ø¨ Ù…Ø¤Ø±Ø´Ù. ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ¹Ø§Ø¯ØªÙ‡ Ù…Ù† Ø´Ø§Ø´Ø© Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨.'
                    : 'ÙŠÙˆØ¬Ø¯ Ù‚Ø§Ù„Ø¨ Ù†Ø´Ø· Ø¨Ù†ÙØ³ Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¨Ø§Ù„ÙØ¹Ù„.';
                alertEl.classList.remove('d-none');
            }
            if (saveBtn && !data.archived) {
                saveBtn.disabled = true;
                saveBtn.dataset.disabledReason = 'exists';
            } else if (saveBtn && data.archived) {
                saveBtn.disabled = false;
                delete saveBtn.dataset.disabledReason;
            }
        } else if (saveBtn && !saveBtn.dataset.saving) {
            saveBtn.disabled = false;
            delete saveBtn.dataset.disabledReason;
        }
    } catch (error) {
        console.error('Error checking template availability:', error);
    }
}

async function saveSuggestionAsTemplate() {
    if (!suggestionTemplateData) {
        utils.showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù‚ØªØ±Ø§Ø­ Ù„Ø­ÙØ¸Ù‡Ø§ ÙƒÙ‚Ø§Ù„Ø¨.', 'error');
        return;
    }

    const questionInput = document.getElementById('templateSuggestionQuestionInput');
    const answerInput = document.getElementById('templateSuggestionAnswerInput');
    const classificationSelect = document.getElementById('templateClassificationSelect');
    const typeSelect = document.getElementById('templateTypeSelect');
    const usageLimitInput = document.getElementById('templateUsageLimitInput');
    const contentInput = document.getElementById('templateContentInput');
    const saveBtn = document.getElementById('saveSuggestionTemplateBtn');

    const question = questionInput?.value.trim();
    const answer = answerInput?.value.trim();
    const classification = classificationSelect?.value || 'All';
    const type = typeSelect?.value || 'Ù…Ù…ÙŠØ²Ø§Øª';
    const content = contentInput?.value.trim();
    const usageLimitValue = usageLimitInput?.value.trim();

    if (!question || !answer || !content) {
        utils.showToast('ÙŠØ±Ø¬Ù‰ ØªØ¹Ø¨Ø¦Ø© Ø§Ù„Ø³Ø¤Ø§Ù„ ÙˆØ§Ù„Ø¥Ø¬Ø§Ø¨Ø© ÙˆØ§Ù„Ù…Ø­ØªÙˆÙ‰ Ù‚Ø¨Ù„ Ø§Ù„Ø­ÙØ¸.', 'warning');
        return;
    }

    if (saveBtn) {
        saveBtn.disabled = true;
        saveBtn.dataset.saving = 'true';
        saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...';
    }

    let usageLimit = null;
    if (usageLimitValue) {
        const parsed = parseInt(usageLimitValue, 10);
        if (Number.isNaN(parsed) || parsed <= 0) {
            utils.showToast('Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø±Ù‚Ù…Ø§Ù‹ Ø£ÙƒØ¨Ø± Ù…Ù† ØµÙØ±.', 'warning');
            if (saveBtn) {
                saveBtn.disabled = false;
                delete saveBtn.dataset.saving;
                saveBtn.removeAttribute('data-saving');
                saveBtn.innerHTML = '<i class="fas fa-save"></i> Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨';
            }
            return;
        }
        usageLimit = parsed;
    }

    const payload = {
        question,
        content,
        correct_answer: answer,
        classification,
        type,
        competition_type: type === 'ØªÙØ§Ø¹Ù„ÙŠØ©' ? 'special' : 'standard',
        status: 'active',
        description: `ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ù…Ù† Ø§Ù‚ØªØ±Ø§Ø­ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù„Ù„Ù…ÙˆØ¸Ù ${suggestionTemplateData.suggested_by_name || ''}`.trim()
    };

    if (usageLimit !== null) {
        payload.usage_limit = usageLimit;
    }

    try {
        const response = await utils.authedFetch('/api/templates', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        const result = await response.json();

        if (!response.ok || result.success === false) {
            utils.showToast(result.message || 'ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù‚Ø§Ù„Ø¨. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.', 'error');
            return;
        }

        utils.showToast('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù‚Ø§Ù„Ø¨ ÙˆØ¥Ø¶Ø§ÙØªÙ‡ Ø¨Ù†Ø¬Ø§Ø­ ğŸ‰', 'success');
        suggestionTemplateModalInstance.hide();
    } catch (error) {
        console.error('Error saving template from suggestion:', error);
        utils.showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨.', 'error');
    } finally {
        if (saveBtn) {
            saveBtn.disabled = false;
            delete saveBtn.dataset.saving;
            saveBtn.removeAttribute('data-saving');
            saveBtn.innerHTML = '<i class="fas fa-save"></i> Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨';
        }
    }
}

// ==========================
// Ø­Ø°Ù Ø§Ù‚ØªØ±Ø§Ø­
// ==========================
let pendingDeleteId = null; // Store the ID to delete

async function deleteSuggestion(suggestionId) {
    
    // ÙØ­Øµ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø³ÙˆØ¨Ø± Ø£Ø¯Ù…Ù†
    if (!isSuperAdmin) {
        utils.showToast('Ù‡Ø°Ù‡ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ù…ØªØ§Ø­Ø© Ù„Ù„Ù…Ø¯ÙŠØ± Ø§Ù„Ø¹Ø§Ù… ÙÙ‚Ø·', 'error');
        return;
    }
    
    // Store ID and show modal
    pendingDeleteId = suggestionId;
    const deleteModal = new bootstrap.Modal(document.getElementById('deleteConfirmModal'));
    deleteModal.show();
}

// Handle confirm delete button
document.addEventListener('DOMContentLoaded', () => {
    const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
    if (confirmDeleteBtn) {
        confirmDeleteBtn.addEventListener('click', async () => {
            if (!pendingDeleteId) return;
            
            const deleteModal = bootstrap.Modal.getInstance(document.getElementById('deleteConfirmModal'));
            deleteModal.hide();
            
            try {
                const response = await utils.authedFetch(`/api/question-suggestions/${pendingDeleteId}`, {
                    method: 'DELETE'
                });
                const data = await response.json();
                
                if (data.success) {
                    utils.showToast('ØªÙ… Ø­Ø°Ù Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­ Ø¨Ù†Ø¬Ø§Ø­', 'success');
                    loadStats();
                    loadUnreadCount(); // Update unread count after deletion
                    loadAllSuggestions(adminSuggestionsCurrentFilter);
                } else {
                    utils.showToast(data.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£', 'error');
                }
            } catch (error) {
                console.error('Error deleting suggestion:', error);
                utils.showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­', 'error');
            } finally {
                pendingDeleteId = null;
            }
        });
    }
});

// ==========================
// Ø£Ø±Ø´ÙØ© Ø§Ù‚ØªØ±Ø§Ø­
// ==========================
let suggestionToArchiveId = null;

function archiveSuggestion(suggestionId) {
    suggestionToArchiveId = suggestionId;
    const modal = new bootstrap.Modal(document.getElementById('archiveModal'));
    modal.show();
}

// Setup Archive Confirmation
document.addEventListener('DOMContentLoaded', () => {
    const confirmBtn = document.getElementById('confirmArchiveBtn');
    if (confirmBtn) {
        confirmBtn.addEventListener('click', async () => {
            if (!suggestionToArchiveId) return;
            
            const btn = document.getElementById('confirmArchiveBtn');
            const originalText = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ...';

            try {
                const response = await utils.authedFetch(`/api/question-suggestions/${suggestionToArchiveId}/archive`, {
                    method: 'PUT'
                });
                const data = await response.json();
                
                if (data.success) {
                    utils.showToast('ØªÙ… Ø£Ø±Ø´ÙØ© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­ Ø¨Ù†Ø¬Ø§Ø­', 'success');
                    bootstrap.Modal.getInstance(document.getElementById('archiveModal')).hide();
                    loadStats();
                    loadAllSuggestions(adminSuggestionsCurrentFilter);
                } else {
                    utils.showToast(data.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£', 'error');
                }
            } catch (error) {
                console.error('Error archiving suggestion:', error);
                utils.showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø£Ø±Ø´ÙØ© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­', 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalText;
                suggestionToArchiveId = null;
            }
        });
    }
});

// ==========================
// Ø§Ù„ÙÙ„Ø§ØªØ±
// ==========================
function setupFilters() {
    const filterButtons = document.querySelectorAll('.admin-filter-btn');
    filterButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            filterButtons.forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            
            adminSuggestionsCurrentFilter = this.dataset.status;
            loadAllSuggestions(adminSuggestionsCurrentFilter);
        });
    });
    
    // Advanced filters setup
    const applyFiltersBtn = document.getElementById('applyFiltersBtn');
    const resetFiltersBtn = document.getElementById('resetFiltersBtn');
    const employeeFilter = document.getElementById('employeeFilter');
    const dateFromFilter = document.getElementById('dateFromFilter');
    const dateToFilter = document.getElementById('dateToFilter');
    const categoryFilter = document.getElementById('categoryFilter');
    
    // Apply filters button
    if (applyFiltersBtn) {
        applyFiltersBtn.addEventListener('click', () => {
            applyAdvancedFilters();
        });
    }
    
    // Reset filters button
    if (resetFiltersBtn) {
        resetFiltersBtn.addEventListener('click', () => {
            if (employeeFilter) employeeFilter.value = '';
            if (dateFromFilter) dateFromFilter.value = '';
            if (dateToFilter) dateToFilter.value = '';
            if (categoryFilter) categoryFilter.value = '';
            loadAllSuggestions(adminSuggestionsCurrentFilter);
            // Reload original stats
            loadStats();
        });
    }
    
    // Copy approved questions button
    const copyApprovedQuestionsBtn = document.getElementById('copyApprovedQuestionsBtn');
    if (copyApprovedQuestionsBtn) {
        copyApprovedQuestionsBtn.addEventListener('click', () => {
            copyApprovedQuestions();
        });
    }
    
    // Export to Excel button
    const exportToExcelBtn = document.getElementById('exportToExcelBtn');
    if (exportToExcelBtn) {
        exportToExcelBtn.addEventListener('click', () => {
            exportToExcel();
        });
    }
}

// Load employee list from suggestions
async function loadEmployeeList() {
    try {
        const employeeFilter = document.getElementById('employeeFilter');
        if (!employeeFilter) return;

        // Clear existing options except the first one (all employees)
        while (employeeFilter.options.length > 1) {
            employeeFilter.remove(1);
        }

        // Load ALL employees regardless of current filter status
        const response = await utils.authedFetch('/api/question-suggestions/all?limit=1000');
        if (response.ok) {
            const data = await response.json();
            if (data.success) {
                // Get unique employee names from ALL suggestions
                const uniqueEmployees = [...new Set(data.data.map(s => s.suggested_by_name))]
                    .filter(name => name)
                    .sort();

                // Add options to select
                uniqueEmployees.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    employeeFilter.appendChild(option);
                });
            }
        }
    } catch (error) {
        console.error('Error loading employee list:', error);
    }
}

// Apply advanced filters
async function applyAdvancedFilters() {
    const employeeName = document.getElementById('employeeFilter')?.value.trim();
    const dateFrom = document.getElementById('dateFromFilter')?.value;
    const dateTo = document.getElementById('dateToFilter')?.value;
    const category = document.getElementById('categoryFilter')?.value;

    try {
        // Load ALL suggestions regardless of current status filter
        const response = await utils.authedFetch('/api/question-suggestions/all?limit=1000');
        if (!response.ok) {
            console.error('Failed to load all suggestions for filtering');
            return;
        }

        const data = await response.json();
        if (!data.success) {
            console.error('Failed to get suggestions data');
            return;
        }

        // Update global allSuggestions so modal lookups work
        allSuggestions = data.data;
        let filtered = [...allSuggestions];

        // Filter by employee name
        if (employeeName) {
            filtered = filtered.filter(s =>
                s.suggested_by_name === employeeName
            );
        }

        // Filter by date range
        if (dateFrom) {
            const fromDate = new Date(dateFrom);
            fromDate.setHours(0, 0, 0, 0);
            filtered = filtered.filter(s => {
                const suggestionDate = new Date(s.createdAt);
                suggestionDate.setHours(0, 0, 0, 0);
                return suggestionDate >= fromDate;
            });
        }

        if (dateTo) {
            const toDate = new Date(dateTo);
            toDate.setHours(23, 59, 59, 999);
            filtered = filtered.filter(s => {
                const suggestionDate = new Date(s.createdAt);
                return suggestionDate <= toDate;
            });
        }

        // Filter by category
        if (category) {
            filtered = filtered.filter(s => s.category === category);
        }

        // Update statistics cards based on filtered results
        updateStatsCards(filtered);

        displayAllSuggestions(filtered);
    } catch (error) {
        console.error('Error applying advanced filters:', error);
        utils.showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„Ø§ØªØ±', 'error');
    }
}

// Update statistics cards
function updateStatsCards(suggestions) {
    const totalCount = suggestions.length;
    const pendingCount = suggestions.filter(s => s.status === 'pending').length;
    const approvedCount = suggestions.filter(s => s.status === 'approved').length;
    const rejectedCount = suggestions.filter(s => s.status === 'rejected').length;
    const revisionCount = suggestions.filter(s => s.status === 'needs_revision').length;

    // Update the UI
    const totalEl = document.getElementById('totalCount');
    const pendingEl = document.getElementById('pendingCount');
    const approvedEl = document.getElementById('approvedCount');
    const rejectedEl = document.getElementById('rejectedCount');
    const revisionEl = document.getElementById('revisionCount');

    if (totalEl) totalEl.textContent = totalCount;
    if (pendingEl) pendingEl.textContent = pendingCount;
    if (approvedEl) approvedEl.textContent = approvedCount;
    if (rejectedEl) rejectedEl.textContent = rejectedCount;
    if (revisionEl) revisionEl.textContent = revisionCount;

    // Update pending header badge
    const pendingHeaderBadge = document.getElementById('pendingHeaderCountBadge');
    const pendingHeaderCount = document.getElementById('pendingHeaderCount');
    if (pendingHeaderBadge && pendingHeaderCount) {
        if (pendingCount > 0) {
            pendingHeaderBadge.style.display = 'inline-flex';
            pendingHeaderCount.textContent = pendingCount;
        } else {
            pendingHeaderBadge.style.display = 'none';
        }
    }
}// Debounce helper function
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// ==========================
// ØªÙÙˆÙŠØ¶ Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª (ØªÙ‚ÙŠÙŠÙ… / Ø­Ø°Ù)
// ==========================
function setupCardDelegation() {
    const container = document.getElementById('adminSuggestionsContainer');
    if (!container) return;
    container.addEventListener('click', function(e) {
        const btn = e.target.closest('button');
        if (!btn) return;
        const action = btn.dataset.action;
        if (!action) return;
        const id = btn.dataset.id;
        if (!id) return;
        
        // Block actions for non-super admin users
        if (!isSuperAdmin) {
            utils.showToast('Ù‡Ø°Ù‡ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ù…ØªØ§Ø­Ø© Ù„Ù„Ù…Ø¯ÙŠØ± Ø§Ù„Ø¹Ø§Ù… ÙÙ‚Ø·', 'error');
            return;
        }
        
        if (action === 'evaluate') {
            const targetStatus = btn.dataset.status || 'pending';
            openEvaluationModal(id, targetStatus);
        } else if (action === 'delete') {
            deleteSuggestion(id);
        } else if (action === 'archive') {
            archiveSuggestion(id);
        }
    });
}

// ==========================
// Helper Functions
// ==========================
function getStatusBadge(status) {
    const badges = {
        pending: '<span class="status-badge pending"><i class="fas fa-clock"></i> Ù‚ÙŠØ¯ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©</span>',
        approved: '<span class="status-badge approved"><i class="fas fa-check-circle"></i> Ù…Ù‚Ø¨ÙˆÙ„</span>',
        rejected: '<span class="status-badge rejected"><i class="fas fa-times-circle"></i> Ù…Ø±ÙÙˆØ¶</span>',
        needs_revision: '<span class="status-badge needs-revision"><i class="fas fa-edit"></i> ÙŠØ­ØªØ§Ø¬ ØªØ¹Ø¯ÙŠÙ„</span>'
    };
    return badges[status] || '';
}

function getCategoryLabel(category) {
    const labels = {
        trading: 'ØªØ¯Ø§ÙˆÙ„ÙŠØ©',
        interactive: 'ØªÙØ§Ø¹Ù„ÙŠØ©',
        company_features: 'Ù…Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø´Ø±ÙƒØ©',
        educational: 'ØªØ¹Ù„ÙŠÙ…ÙŠØ©',
        highlight_site: 'ØªØ¨Ø±Ø² Ø§Ù„Ù…ÙˆÙ‚Ø¹',
        other: 'Ø§Ø®Ø±ÙŠ'
    };
    return labels[category] || category;
}

function getDifficultyLabel(difficulty) {
    const labels = {
        easy: 'Ø³Ù‡Ù„',
        medium: 'Ù…ØªÙˆØ³Ø·',
        hard: 'ØµØ¹Ø¨'
    };
    return labels[difficulty] || difficulty;
}

function getRatingStars(rating) {
    let html = '';
    for (let i = 1; i <= 5; i++) {
        if (i <= rating) {
            html += '<i class="fas fa-star text-warning"></i>';
        } else {
            html += '<i class="far fa-star text-muted"></i>';
        }
    }
    return html;
}

// ==========================
// Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
// ==========================
document.addEventListener('DOMContentLoaded', () => {
    const container = document.getElementById('adminSuggestionsContainer');
    
    initAdminQuestionSuggestions();
});

// ==========================
// Ù†Ø³Ø® Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…Ù‚Ø¨ÙˆÙ„Ø©
// ==========================
async function copyApprovedQuestions() {
    try {
        const employeeName = document.getElementById('employeeFilter')?.value.trim();
        const dateFrom = document.getElementById('dateFromFilter')?.value;
        const dateTo = document.getElementById('dateToFilter')?.value;
        const category = document.getElementById('categoryFilter')?.value;

        // Load all suggestions
        const response = await utils.authedFetch('/api/question-suggestions/all?limit=1000');
        if (!response.ok) {
            showToast('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª', 'error');
            return;
        }

        const data = await response.json();
        if (!data.success || !data.data) {
            showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ§Ø­Ø©', 'error');
            return;
        }

        // Filter approved suggestions only
        let filteredSuggestions = data.data.filter(s => s.status === 'approved');

        // Apply employee filter
        if (employeeName) {
            filteredSuggestions = filteredSuggestions.filter(s => 
                s.suggested_by_name && s.suggested_by_name.trim() === employeeName
            );
        }

        // Apply date filters
        if (dateFrom) {
            const fromDate = new Date(dateFrom);
            fromDate.setHours(0, 0, 0, 0);
            filteredSuggestions = filteredSuggestions.filter(s => {
                const suggestionDate = new Date(s.createdAt);
                suggestionDate.setHours(0, 0, 0, 0);
                return suggestionDate >= fromDate;
            });
        }

        if (dateTo) {
            const toDate = new Date(dateTo);
            toDate.setHours(23, 59, 59, 999);
            filteredSuggestions = filteredSuggestions.filter(s => {
                const suggestionDate = new Date(s.createdAt);
                return suggestionDate <= toDate;
            });
        }

        // Apply category filter
        if (category) {
            filteredSuggestions = filteredSuggestions.filter(s => s.category === category);
        }

        // Check if there are any approved questions
        if (filteredSuggestions.length === 0) {
            showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø³Ø¦Ù„Ø© Ù…Ù‚Ø¨ÙˆÙ„Ø© Ø­Ø³Ø¨ Ø§Ù„ÙÙ„ØªØ± Ø§Ù„Ù…Ø­Ø¯Ø¯', 'warning');
            return;
        }

        // Format questions for copying
        let copiedText = 'ğŸ“‹ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…Ù‚Ø¨ÙˆÙ„Ø©\n';
        copiedText += 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n';

        filteredSuggestions.forEach((suggestion, index) => {
            copiedText += `${index + 1}. ${suggestion.question}\n\n`;
        });

        copiedText += `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`;
        copiedText += `Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©: ${filteredSuggestions.length}\n`;

        // Copy to clipboard
        await navigator.clipboard.writeText(copiedText);
        
        showToast(`ØªÙ… Ù†Ø³Ø® ${filteredSuggestions.length} Ø³Ø¤Ø§Ù„ Ù…Ù‚Ø¨ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­! âœ…`, 'success');

    } catch (error) {
        console.error('Error copying approved questions:', error);
        showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù†Ø³Ø® Ø§Ù„Ø£Ø³Ø¦Ù„Ø©', 'error');
    }
}

// ==========================
// ØªØµØ¯ÙŠØ± Ø¥Ù„Ù‰ Excel
// ==========================
async function exportToExcel() {
    try {
        const employeeName = document.getElementById('employeeFilter')?.value.trim();
        const dateFrom = document.getElementById('dateFromFilter')?.value;
        const dateTo = document.getElementById('dateToFilter')?.value;
        const category = document.getElementById('categoryFilter')?.value;

        // Load all suggestions
        const response = await utils.authedFetch('/api/question-suggestions/all?limit=1000');
        if (!response.ok) {
            showToast('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª', 'error');
            return;
        }

        const data = await response.json();
        if (!data.success || !data.data) {
            showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ§Ø­Ø©', 'error');
            return;
        }

        let filteredSuggestions = [...data.data];

        // Apply employee filter
        if (employeeName) {
            filteredSuggestions = filteredSuggestions.filter(s => 
                s.suggested_by_name && s.suggested_by_name.trim() === employeeName
            );
        }

        // Apply date filters
        if (dateFrom) {
            const fromDate = new Date(dateFrom);
            fromDate.setHours(0, 0, 0, 0);
            filteredSuggestions = filteredSuggestions.filter(s => {
                const suggestionDate = new Date(s.createdAt);
                suggestionDate.setHours(0, 0, 0, 0);
                return suggestionDate >= fromDate;
            });
        }

        if (dateTo) {
            const toDate = new Date(dateTo);
            toDate.setHours(23, 59, 59, 999);
            filteredSuggestions = filteredSuggestions.filter(s => {
                const suggestionDate = new Date(s.createdAt);
                return suggestionDate <= toDate;
            });
        }

        // Apply category filter
        if (category) {
            filteredSuggestions = filteredSuggestions.filter(s => s.category === category);
        }

        // Check if there are any suggestions
        if (filteredSuggestions.length === 0) {
            showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ù„Ù„ØªØµØ¯ÙŠØ± Ø­Ø³Ø¨ Ø§Ù„ÙÙ„ØªØ± Ø§Ù„Ù…Ø­Ø¯Ø¯', 'warning');
            return;
        }

        // Format maps
        const statusMap = {
            'pending': 'Ù‚ÙŠØ¯ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©',
            'approved': 'Ù…Ù‚Ø¨ÙˆÙ„Ø©',
            'rejected': 'Ù…Ø±ÙÙˆØ¶Ø©',
            'needs_revision': 'ØªØ­ØªØ§Ø¬ ØªØ¹Ø¯ÙŠÙ„'
        };

        const categoryMap = {
            'trading': 'ØªØ¯Ø§ÙˆÙ„ÙŠØ©',
            'interactive': 'ØªÙØ§Ø¹Ù„ÙŠØ©',
            'company_features': 'Ù…Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø´Ø±ÙƒØ©',
            'educational': 'ØªØ¹Ù„ÙŠÙ…ÙŠØ©',
            'highlight_site': 'ØªØ¨Ø±Ø² Ø§Ù„Ù…ÙˆÙ‚Ø¹',
            'other': 'Ø§Ø®Ø±ÙŠ'
        };

        const difficultyMap = {
            'easy': 'Ø³Ù‡Ù„',
            'medium': 'Ù…ØªÙˆØ³Ø·',
            'hard': 'ØµØ¹Ø¨'
        };

        const formatDate = (dateStr) => {
            if (!dateStr) return '-';
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) return '-';
                const day = date.getDate().toString().padStart(2, '0');
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const year = date.getFullYear();
                let hours = date.getHours();
                const minutes = date.getMinutes().toString().padStart(2, '0');
                const ampm = hours >= 12 ? 'Ù…' : 'Øµ';
                hours = hours % 12;
                hours = hours ? hours : 12; // 0 => 12
                hours = hours.toString().padStart(2, '0');
                return `${day}/${month}/${year} - ${hours}:${minutes} ${ampm}`;
            } catch (error) {
                console.error('Error formatting date:', error);
                return '-';
            }
        };

        // Prepare header
        const headers = [
            '#', 
            'Ø§Ù„Ø³Ø¤Ø§Ù„', 
            'Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©', 
            'Ø§Ù„ØªØµÙ†ÙŠÙ', 
            'Ø§Ù„Ù…Ø³ØªÙˆÙ‰', 
            'Ø§Ù„Ø­Ø§Ù„Ø©', 
            'Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ¸Ù', 
            'ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù‚ØªØ±Ø§Ø­', 
            'Ø§Ù„ØªÙ‚ÙŠÙŠÙ…', 
            'Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª', 
            'Ù…Ø±Ø§Ø¬Ø¹ Ø¨ÙˆØ§Ø³Ø·Ø©', 
            'ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©', 
            'Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©'
        ];

        // Prepare data rows
        const dataRows = filteredSuggestions.map((suggestion, index) => [
            index + 1,
            suggestion.question || '-',
            suggestion.correct_answer || '-',
            categoryMap[suggestion.category] || suggestion.category || '-',
            difficultyMap[suggestion.difficulty] || suggestion.difficulty || '-',
            statusMap[suggestion.status] || suggestion.status || '-',
            suggestion.suggested_by_name || '-',
            formatDate(suggestion.createdAt),
            suggestion.evaluation?.rating ? `${suggestion.evaluation.rating} / 5` : '-',
            suggestion.evaluation?.feedback || '-',
            suggestion.evaluation?.reviewed_by_name || '-',
            formatDate(suggestion.evaluation?.reviewed_at),
            suggestion.evaluation?.admin_notes || '-'
        ]);

        // Combine headers and data
        const allData = [headers, ...dataRows];

        // Create workbook and worksheet with graceful fallbacks for older XLSX builds
        let ws;
        const xlsxUtils = (XLSX && XLSX.utils) ? XLSX.utils : {};
        const wb = (xlsxUtils && typeof xlsxUtils.book_new === 'function')
            ? xlsxUtils.book_new()
            : { SheetNames: [], Sheets: {} }; // fallback shape used by xlsx-style

        // Helper to build sheet from AOA
        const buildSheetFromAOA = (aoa) => {
            if (xlsxUtils.aoa_to_sheet) return xlsxUtils.aoa_to_sheet(aoa);
            let sheet = {};
            if (xlsxUtils.sheet_add_aoa) {
                xlsxUtils.sheet_add_aoa(sheet, aoa);
            } else if (xlsxUtils.encode_cell && xlsxUtils.encode_range) {
                // Manual cell assignment
                aoa.forEach((row, rIdx) => {
                    row.forEach((val, cIdx) => {
                        const cellRef = xlsxUtils.encode_cell({ r: rIdx, c: cIdx });
                        sheet[cellRef] = { v: val };
                    });
                });
                const range = {
                    s: { r: 0, c: 0 },
                    e: { r: aoa.length - 1, c: headers.length - 1 }
                };
                sheet['!ref'] = xlsxUtils.encode_range(range);
            }
            return sheet;
        };

        // Build worksheet with layered fallbacks
        try {
            if (xlsxUtils && typeof xlsxUtils.aoa_to_sheet === 'function') {
                ws = xlsxUtils.aoa_to_sheet(allData);
            } else if (xlsxUtils && typeof xlsxUtils.json_to_sheet === 'function') {
                const jsonArray = dataRows.map(row => {
                    const obj = {};
                    headers.forEach((h, i) => obj[h] = row[i]);
                    return obj;
                });
                ws = xlsxUtils.json_to_sheet(jsonArray, { header: headers });
            } else {
                ws = buildSheetFromAOA(allData);
            }
        } catch (err) {
            // As a last resort convert via cell-by-cell - create empty sheet to continue gracefully
            ws = buildSheetFromAOA([headers]);
        }

        // Ensure worksheet exists before proceeding
        if (!ws || !ws['!ref']) {
            // If we have no ref yet, initialize with headers to build a valid sheet
            ws = buildSheetFromAOA([headers]);
        }

        // Set column widths
        ws['!cols'] = [
            { wch: 5 },      // #
            { wch: 60 },     // Ø§Ù„Ø³Ø¤Ø§Ù„
            { wch: 30 },     // Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©
            { wch: 15 },     // Ø§Ù„ØªØµÙ†ÙŠÙ
            { wch: 12 },     // Ø§Ù„Ù…Ø³ØªÙˆÙ‰
            { wch: 15 },     // Ø§Ù„Ø­Ø§Ù„Ø©
            { wch: 25 },     // Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ¸Ù
            { wch: 20 },     // ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù‚ØªØ±Ø§Ø­
            { wch: 10 },     // Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
            { wch: 40 },     // Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª
            { wch: 25 },     // Ù…Ø±Ø§Ø¬Ø¹ Ø¨ÙˆØ§Ø³Ø·Ø©
            { wch: 20 },     // ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©
            { wch: 40 }      // Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©
        ];

        // Header style - Dark blue background with white text
        const headerStyle = {
            font: { bold: true, color: { rgb: 'FFFFFFFF' }, sz: 12 },
            fill: { fgColor: { rgb: 'FF2C3E50' }, patternType: 'solid' },
            alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
            border: {
                top: { style: 'thin', color: { rgb: 'FF000000' } },
                bottom: { style: 'thin', color: { rgb: 'FF000000' } },
                left: { style: 'thin', color: { rgb: 'FF000000' } },
                right: { style: 'thin', color: { rgb: 'FF000000' } }
            }
        };

        // Alternate row styles
        const whiteRowStyle = {
            fill: { fgColor: { rgb: 'FFFFFFFF' }, patternType: 'solid' },
            alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
            border: {
                top: { style: 'thin', color: { rgb: 'FFD0D0D0' } },
                bottom: { style: 'thin', color: { rgb: 'FFD0D0D0' } },
                left: { style: 'thin', color: { rgb: 'FFD0D0D0' } },
                right: { style: 'thin', color: { rgb: 'FFD0D0D0' } }
            }
        };

        const grayRowStyle = {
            fill: { fgColor: { rgb: 'FFF0F0F0' }, patternType: 'solid' },
            alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
            border: {
                top: { style: 'thin', color: { rgb: 'FFD0D0D0' } },
                bottom: { style: 'thin', color: { rgb: 'FFD0D0D0' } },
                left: { style: 'thin', color: { rgb: 'FFD0D0D0' } },
                right: { style: 'thin', color: { rgb: 'FFD0D0D0' } }
            }
        };

        const encodeCell = xlsxUtils.encode_cell || ((ref) => {
            // Minimal fallback for encode_cell
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const colPart = letters[ref.c] || ('C' + ref.c); // crude fallback
            return `${colPart}${ref.r + 1}`;
        });

        // Status-specific styles with colors
        const statusStyles = {
            'Ù…Ù‚Ø¨ÙˆÙ„Ø©': {
                fill: { fgColor: { rgb: 'FFC6EFCE' }, patternType: 'solid' }, // Light green
                font: { bold: true, color: { rgb: 'FF006100' } }, // Dark green
                alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
                border: {
                    top: { style: 'thin', color: { rgb: 'FF00B050' } },
                    bottom: { style: 'thin', color: { rgb: 'FF00B050' } },
                    left: { style: 'thin', color: { rgb: 'FF00B050' } },
                    right: { style: 'thin', color: { rgb: 'FF00B050' } }
                }
            },
            'Ù…Ø±ÙÙˆØ¶Ø©': {
                fill: { fgColor: { rgb: 'FFFFC7CE' }, patternType: 'solid' }, // Light red
                font: { bold: true, color: { rgb: 'FF9C0006' } }, // Dark red
                alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
                border: {
                    top: { style: 'thin', color: { rgb: 'FFFF0000' } },
                    bottom: { style: 'thin', color: { rgb: 'FFFF0000' } },
                    left: { style: 'thin', color: { rgb: 'FFFF0000' } },
                    right: { style: 'thin', color: { rgb: 'FFFF0000' } }
                }
            },
            'Ù‚ÙŠØ¯ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©': {
                fill: { fgColor: { rgb: 'FFFFEB9C' }, patternType: 'solid' }, // Light yellow
                font: { bold: true, color: { rgb: 'FF9C6500' } }, // Dark orange
                alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
                border: {
                    top: { style: 'thin', color: { rgb: 'FFFFC000' } },
                    bottom: { style: 'thin', color: { rgb: 'FFFFC000' } },
                    left: { style: 'thin', color: { rgb: 'FFFFC000' } },
                    right: { style: 'thin', color: { rgb: 'FFFFC000' } }
                }
            },
            'ØªØ­ØªØ§Ø¬ ØªØ¹Ø¯ÙŠÙ„': {
                fill: { fgColor: { rgb: 'FFE4DFEC' }, patternType: 'solid' }, // Light purple
                font: { bold: true, color: { rgb: 'FF5B2C6F' } }, // Dark purple
                alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
                border: {
                    top: { style: 'thin', color: { rgb: 'FF9B59B6' } },
                    bottom: { style: 'thin', color: { rgb: 'FF9B59B6' } },
                    left: { style: 'thin', color: { rgb: 'FF9B59B6' } },
                    right: { style: 'thin', color: { rgb: 'FF9B59B6' } }
                }
            }
        };

        // Difficulty-specific styles with colors
        const difficultyStyles = {
            'Ø³Ù‡Ù„': {
                fill: { fgColor: { rgb: 'FFD4EDDA' }, patternType: 'solid' }, // Light green
                font: { bold: true, color: { rgb: 'FF155724' } }, // Dark green
                alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
                border: {
                    top: { style: 'thin', color: { rgb: 'FF28A745' } },
                    bottom: { style: 'thin', color: { rgb: 'FF28A745' } },
                    left: { style: 'thin', color: { rgb: 'FF28A745' } },
                    right: { style: 'thin', color: { rgb: 'FF28A745' } }
                }
            },
            'Ù…ØªÙˆØ³Ø·': {
                fill: { fgColor: { rgb: 'FFFFF3CD' }, patternType: 'solid' }, // Light yellow
                font: { bold: true, color: { rgb: 'FF856404' } }, // Dark yellow
                alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
                border: {
                    top: { style: 'thin', color: { rgb: 'FFFFC107' } },
                    bottom: { style: 'thin', color: { rgb: 'FFFFC107' } },
                    left: { style: 'thin', color: { rgb: 'FFFFC107' } },
                    right: { style: 'thin', color: { rgb: 'FFFFC107' } }
                }
            },
            'ØµØ¹Ø¨': {
                fill: { fgColor: { rgb: 'FFF8D7DA' }, patternType: 'solid' }, // Light red
                font: { bold: true, color: { rgb: 'FF721C24' } }, // Dark red
                alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
                border: {
                    top: { style: 'thin', color: { rgb: 'FFDC3545' } },
                    bottom: { style: 'thin', color: { rgb: 'FFDC3545' } },
                    left: { style: 'thin', color: { rgb: 'FFDC3545' } },
                    right: { style: 'thin', color: { rgb: 'FFDC3545' } }
                }
            }
        };

        // Status column index (column F = 5)
        const statusColIndex = 5;
        // Difficulty column index (column E = 4)
        const difficultyColIndex = 4;

        // Apply styles to all cells
        for (let row = 0; row <= dataRows.length; row++) {
            for (let col = 0; col < headers.length; col++) {
                const cellRef = encodeCell({ r: row, c: col });
                
                // Ensure cell exists with proper structure
                if (!ws[cellRef]) {
                    ws[cellRef] = { t: 's', v: '' };
                }
                
                // Make sure cell has required properties
                if (!ws[cellRef].t) ws[cellRef].t = 's';
                if (ws[cellRef].v === undefined) ws[cellRef].v = '';

                if (row === 0) {
                    // Header row
                    ws[cellRef].s = headerStyle;
                } else {
                    // Check if this is the status column
                    if (col === statusColIndex) {
                        const statusValue = ws[cellRef].v;
                        if (statusStyles[statusValue]) {
                            ws[cellRef].s = statusStyles[statusValue];
                        } else {
                            // Default style for unknown status
                            ws[cellRef].s = row % 2 === 0 ? whiteRowStyle : grayRowStyle;
                        }
                    } else if (col === difficultyColIndex) {
                        // Check if this is the difficulty column
                        const difficultyValue = ws[cellRef].v;
                        if (difficultyStyles[difficultyValue]) {
                            ws[cellRef].s = difficultyStyles[difficultyValue];
                        } else {
                            // Default style for unknown difficulty
                            ws[cellRef].s = row % 2 === 0 ? whiteRowStyle : grayRowStyle;
                        }
                    } else {
                        // Alternate row colors for non-status/difficulty columns
                        ws[cellRef].s = row % 2 === 0 ? whiteRowStyle : grayRowStyle;
                    }
                }
            }
        }

        // Set row height for header
        ws['!rows'] = [{ hpx: 30 }];

        // Add worksheet to workbook
        if (xlsxUtils.book_append_sheet) {
            xlsxUtils.book_append_sheet(wb, ws, 'Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ø§Ù„Ø£Ø³Ø¦Ù„Ø©');
        } else {
            wb.SheetNames.push('Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ø§Ù„Ø£Ø³Ø¦Ù„Ø©');
            wb.Sheets['Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ø§Ù„Ø£Ø³Ø¦Ù„Ø©'] = ws;
        }

        // Generate filename and save (browser-compatible approach)
        const fileName = `Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª_Ø§Ù„Ø£Ø³Ø¦Ù„Ø©_${new Date().toISOString().split('T')[0]}.xlsx`;
        
        console.log('[Excel Export] Starting export process...');
        console.log('[Excel Export] Workbook structure:', { 
            sheetNames: wb.SheetNames, 
            hasSheets: !!wb.Sheets,
            sheetCount: Object.keys(wb.Sheets || {}).length
        });
        console.log('[Excel Export] Worksheet structure:', {
            hasRef: !!ws['!ref'],
            ref: ws['!ref'],
            hasCols: !!ws['!cols'],
            hasRows: !!ws['!rows']
        });
        console.log('[Excel Export] XLSX library capabilities:', {
            hasWrite: !!(XLSX && XLSX.write),
            writeType: typeof XLSX.write,
            hasWriteFile: !!(XLSX && XLSX.writeFile),
            writeFileType: typeof XLSX.writeFile
        });
        
        // Write workbook to binary string and trigger download
        if (XLSX.writeFile && typeof XLSX.writeFile === 'function') {
            console.log('[Excel Export] Trying XLSX.writeFile...');
            try {
                XLSX.writeFile(wb, fileName);
                console.log('[Excel Export] âœ… writeFile succeeded');
            } catch (writeErr) {
                console.warn('[Excel Export] âš ï¸ writeFile failed:', writeErr.message);
                console.log('[Excel Export] Trying fallback with XLSX.write...');
                
                // Try different output types
                const types = ['binary', 'base64', 'buffer'];
                let success = false;
                
                for (const outputType of types) {
                    try {
                        console.log(`[Excel Export] Attempting type: ${outputType}`);
                        const wbout = XLSX.write(wb, { bookType: 'xlsx', type: outputType });
                        console.log(`[Excel Export] Write succeeded with type ${outputType}, output length:`, wbout.length || wbout.byteLength);
                        
                        let blob;
                        if (outputType === 'binary') {
                            const buf = new ArrayBuffer(wbout.length);
                            const view = new Uint8Array(buf);
                            for (let i = 0; i < wbout.length; i++) {
                                view[i] = wbout.charCodeAt(i) & 0xFF;
                            }
                            blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                        } else if (outputType === 'base64') {
                            const binStr = atob(wbout);
                            const buf = new ArrayBuffer(binStr.length);
                            const view = new Uint8Array(buf);
                            for (let i = 0; i < binStr.length; i++) {
                                view[i] = binStr.charCodeAt(i) & 0xFF;
                            }
                            blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                        } else {
                            blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                        }
                        
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = fileName;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        console.log(`[Excel Export] âœ… Download triggered with type ${outputType}`);
                        success = true;
                        break;
                    } catch (typeErr) {
                        console.warn(`[Excel Export] âš ï¸ Type ${outputType} failed:`, typeErr.message);
                    }
                }
                
                if (!success) {
                    throw new Error('All write methods failed');
                }
            }
        } else if (XLSX.write) {
            console.log('[Excel Export] writeFile not available, using XLSX.write directly...');
            
            // Try different output types
            const types = ['binary', 'base64', 'buffer'];
            let success = false;
            
            for (const outputType of types) {
                try {
                    console.log(`[Excel Export] Attempting type: ${outputType}`);
                    const wbout = XLSX.write(wb, { bookType: 'xlsx', type: outputType });
                    console.log(`[Excel Export] Write succeeded with type ${outputType}`);
                    
                    let blob;
                    if (outputType === 'binary') {
                        const buf = new ArrayBuffer(wbout.length);
                        const view = new Uint8Array(buf);
                        for (let i = 0; i < wbout.length; i++) {
                            view[i] = wbout.charCodeAt(i) & 0xFF;
                        }
                        blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    } else if (outputType === 'base64') {
                        const binStr = atob(wbout);
                        const buf = new ArrayBuffer(binStr.length);
                        const view = new Uint8Array(buf);
                        for (let i = 0; i < binStr.length; i++) {
                            view[i] = binStr.charCodeAt(i) & 0xFF;
                        }
                        blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    } else {
                        blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    }
                    
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    console.log(`[Excel Export] âœ… Download triggered with type ${outputType}`);
                    success = true;
                    break;
                } catch (typeErr) {
                    console.warn(`[Excel Export] âš ï¸ Type ${outputType} failed:`, typeErr.message);
                }
            }
            
            if (!success) {
                throw new Error('All write methods failed');
            }
        }

        showToast(`ØªÙ… ØªØµØ¯ÙŠØ± ${filteredSuggestions.length} Ø§Ù‚ØªØ±Ø§Ø­ Ø¨Ù†Ø¬Ø§Ø­! âœ…`, 'success');

    } catch (error) {
        console.error('Error exporting to Excel:', error);
        showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØµØ¯ÙŠØ± Ø¥Ù„Ù‰ Excel', 'error');
    }
}

// Ø¬Ø¹Ù„ Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø© ÙÙŠ onclick Ù…ØªØ§Ø­Ø© Ø¹Ø§Ù„Ù…ÙŠØ§Ù‹ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ¬Ù…ÙŠØ¹ Ø¯Ø§Ø®Ù„ IIFE
// Ø¨Ø³Ø¨Ø¨ Ø£Ù† bundler ÙŠÙ„Ù ÙƒÙ„ Ø§Ù„Ù…Ù„ÙØ§Øª Ø¯Ø§Ø®Ù„ (function(window){ ... }) ÙÙ„Ø§ ØªØµØ¨Ø­ Ù‡Ø°Ù‡ Ø§Ù„Ø¯ÙˆØ§Ù„ Ø¹Ù„Ù‰ Ø§Ù„ÙƒØ§Ø¦Ù† window ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
// Ù„Ø°Ù„Ùƒ Ù†ÙØµØ¯Ø±Ù‡Ø§ ØµØ±Ø§Ø­Ø© Ù„ÙŠØ¹Ù…Ù„ Ø§Ù„Ù€ onclick Ø¯Ø§Ø®Ù„ Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª
window.openEvaluationModal = openEvaluationModal;
window.deleteSuggestion = deleteSuggestion;
window.copyApprovedQuestions = copyApprovedQuestions;
window.exportToExcel = exportToExcel;
// Show this debug log only when running in development or for admin users
try {
    const isDev = (typeof window !== 'undefined' && (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'));
    const cachedProfile = localStorage.getItem('userProfile');
    const role = cachedProfile ? (JSON.parse(cachedProfile).role) : null;
    const isAdmin = role === 'admin' || role === 'super_admin';
    if (isDev || isAdmin) {
        // console.log('[AdminSuggest] Global functions exposed');
    }
} catch (_) { /* noop */ }


// == main.js ==
// 1. Global variables
let searchTimeout;
let currentUserProfile = null; // NEW: To store the current user's profile with role
window.onlineUsers = new Map(); // NEW: Global map to track online users
window.appContent = null; // NEW: Make appContent globally accessible
let winnerRouletteFallbackInitialized = false; // Ensure we only wire the roulette page once when the module fails

// --- NEW: Global Error Catcher ---
// This will catch any unhandled errors on the page and send them to the backend for logging.
window.onerror = function(message, source, lineno, colno, error) {
    const errorData = {
        message: message,
        source: source,
        lineno: lineno,
        colno: colno,
        error: error ? { message: error.message, stack: error.stack } : null,
        url: window.location.href,
    };

    // Use sendBeacon for reliability, especially during page unloads/redirects.
    const blob = new Blob([JSON.stringify(errorData)], { type: 'application/json' });
    navigator.sendBeacon('/api/log-error', blob);
};

// --- Use the shared utility for authenticated API calls ---
window.authedFetch = window.utils.authedFetch;

// Helper function to update the visual status indicator
function updateStatus(status, message) {
    const statusElement = document.getElementById('connection-status');
    if (!statusElement) return;
    statusElement.className = 'status-bar'; // Reset classes
    const lastCheckTime = document.getElementById('last-check-time'); // Ø¥ØµÙ„Ø§Ø­: ØªØ¹Ø±ÙŠÙ Ø§Ù„Ù…ØªØºÙŠØ±
    statusElement.classList.add('status-' + status);

    // Update timestamp
    const time = new Date().toLocaleTimeString('ar-EG');
    lastCheckTime.textContent = `Ø¢Ø®Ø± ÙØ­Øµ: ${time}`;
}


// NEW: Helper function to format numbers with commas
function formatNumber(num) {
    if (num === null || num === undefined) return '0';
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

/**
 * NEW: Global helper to update a single countdown timer element.
 * @param {HTMLElement} el The element containing the data-end-date attribute.
 */
function updateCountdownTimer(el) {
    const endDateStr = el.dataset.endDate;
    if (!endDateStr) {
        el.innerHTML = ''; // Clear if no date
        return;
    }

    const endDate = new Date(endDateStr);
    const diffTime = endDate.getTime() - Date.now();

    if (diffTime <= 0) {
        el.innerHTML = `<i class="fas fa-hourglass-end"></i> <span>ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...</span>`;
        el.classList.add('expired');
    } else {
        const days = Math.floor(diffTime / (1000 * 60 * 60 * 24));
        const hours = Math.floor((diffTime % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((diffTime % (1000 * 60 * 60)) / (1000 * 60));

        let parts = [];
        if (days > 0) parts.push(`${days} ÙŠÙˆÙ…`);
        if (hours > 0) parts.push(`${hours} Ø³Ø§Ø¹Ø©`);
        if (minutes > 0 && days === 0) parts.push(`${minutes} Ø¯Ù‚ÙŠÙ‚Ø©`); // Show minutes only if less than a day

        if (parts.length === 0 && diffTime > 0) {
            parts.push('Ø£Ù‚Ù„ Ù…Ù† Ø¯Ù‚ÙŠÙ‚Ø©');
        }
        el.innerHTML = `<i class="fas fa-hourglass-half"></i> <span>Ù…ØªØ¨Ù‚ÙŠ: ${parts.join(' Ùˆ ')}</span>`;
    }
}

// NEW: Function to fetch and store the current user's profile
async function fetchUserProfile() {
    try {
        // Use the /me endpoint to get the current user's profile
        const response = await authedFetch('/api/auth/me');
        if (!response.ok) {
            // If token is invalid/expired, server will return 401
            throw new Error(`Authentication check failed with status: ${response.status}`);
        }
        currentUserProfile = await response.json();
        localStorage.setItem('userProfile', JSON.stringify(currentUserProfile)); // Cache the profile
        return currentUserProfile;
    } catch (error) {
        // --- ØªØ¹Ø¯ÙŠÙ„: Ø¥Ø¶Ø§ÙØ© Ø³Ø¬Ù„ ÙˆØ§Ø¶Ø­ Ù„Ø³Ø¨Ø¨ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙˆØ¬ÙŠÙ‡ ---
        console.error(`%c[AUTH-FAIL] Could not fetch user profile. Reason: ${error.message}`, 'color: red; font-weight: bold;');
        return null;
    }
}

// --- NEW: Function to update UI elements after successful login ---
function updateUIAfterLogin(user) {
    if (!user) return;

    const settingsMenu = document.getElementById('settings-menu');
    const userNameDisplay = document.getElementById('user-name');
    const userEmailDisplay = document.getElementById('user-email');
    const userAvatar = document.getElementById('user-avatar');
    const usersNavItem = document.getElementById('nav-users');
    const activityLogNavItem = document.getElementById('nav-activity-log');

    if (settingsMenu) settingsMenu.style.display = 'block';
    if (userNameDisplay) userNameDisplay.textContent = user.full_name;
    if (userEmailDisplay) userEmailDisplay.textContent = user.email;
    if (userAvatar) {
        userAvatar.src = user.avatar_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(user.full_name)}&background=random`;
    }

    // --- MODIFICATION: Show activity log link only to admins and super admins ---
    if (activityLogNavItem) {
        const canViewLogs = user.role === 'super_admin' || user.role === 'admin';
        activityLogNavItem.style.display = canViewLogs ? 'block' : 'none';
    }

    // Show admin-only links if the user is a super_admin or admin
    // --- MODIFICATION: Allow admins to see the users link as well ---
    if (usersNavItem && (user.role === 'super_admin' || user.role === 'admin')) {
        usersNavItem.style.display = 'block';
    }

    // NEW: Show Question Suggestions links for all users
    // Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (Ù…ÙˆØ¸ÙØŒ Ø£Ø¯Ù…Ù†ØŒ Ø³ÙˆØ¨Ø± Ø£Ø¯Ù…Ù†) ÙŠÙ…ÙƒÙ†Ù‡Ù… Ø±Ø¤ÙŠØ© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª
    const navQuestionsDropdownContainer = document.getElementById('nav-questions-dropdown-container');
    const navAdminQuestionSuggestions = document.getElementById('nav-admin-question-suggestions');
    
    if (navQuestionsDropdownContainer) {
        navQuestionsDropdownContainer.style.display = 'block'; // Show dropdown for all users
    }
    
    if (navAdminQuestionSuggestions) {
        navAdminQuestionSuggestions.style.display = 'block'; // Show for all authenticated users
    }

    // NEW: Show Tasks & Calendar dropdown for all users (employees, admins, and super admins)
    const navTasksCalendarDropdownContainer = document.getElementById('nav-tasks-calendar-dropdown-container');
    if (navTasksCalendarDropdownContainer) {
        navTasksCalendarDropdownContainer.style.display = 'block'; // Show for all authenticated users
    }

    // Load global unread suggestions counter for all roles (Super Admin & Employees)
    if (currentUserProfile) {
        loadGlobalUnreadCount();
        // Live polling every 30 seconds
        if (!window._globalUnreadInterval) {
            window._globalUnreadInterval = setInterval(loadGlobalUnreadCount, 30000);
        }
    }
}
// NEW: Router function to handle page navigation based on URL hash
async function handleRouting() {
    showLoader(); // Ø¥Ø¶Ø§ÙØ©: Ø¥Ø¸Ù‡Ø§Ø± Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ ÙÙŠ Ø¨Ø¯Ø§ÙŠØ© ÙƒÙ„ Ø¹Ù…Ù„ÙŠØ© ØªÙ†Ù‚Ù„
    // Scroll to the top of the page on every navigation
    window.scrollTo(0, 0);

    const hash = window.location.hash || '#home'; // Default to home
    const mainElement = document.querySelector('main');
    window.appContent = document.getElementById('app-content'); // Assign to global
    mainElement.classList.add('page-loading');

    // Reset layout classes
    mainElement.classList.remove('full-width');
    appContent.classList.remove('full-height-content');

    let renderFunction;
    let navElement;

    // Basic routing
    const routes = {
        '#home': { func: renderHomePage, nav: 'nav-home' }, // This should be a class instance call in the future
        '#tasks': { 
            func: async () => {
                if (window.currentTasksPageInstance) window.currentTasksPageInstance.destroy();
                window.currentTasksPageInstance = new TasksPage(window.appContent);
                await window.currentTasksPageInstance.render();
            }, 
            nav: 'nav-tasks' 
        },
        '#add-agent': { func: renderAddAgentForm, nav: null }, // Ø¥ØµÙ„Ø§Ø­: Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…ÙÙ‚ÙˆØ¯
        '#top-agents': { func: renderTopAgentsPage, nav: 'nav-top-agents' }, // NEW: Top Agents page
        '#manage-agents': { func: renderManageAgentsPage, nav: 'nav-manage-agents', adminOnly: false },
        '#competitions/edit': { func: () => {}, nav: 'nav-manage-competitions' }, // Placeholder: Actual function is in competitions.js
        '#competitions': { func: renderCompetitionsPage, nav: 'nav-manage-competitions' },
        '#archived-competitions': { func: renderCompetitionsPage, nav: 'nav-archived-competitions' },
        '#competition-templates': { func: renderCompetitionTemplatesPage, nav: 'nav-competition-templates' },
        '#archived-templates': { func: renderArchivedTemplatesPage, nav: 'nav-competition-templates' }, // Corrected nav item
        '#users': { func: renderUsersPage, nav: 'nav-users', adminOnly: true },
        '#profile-settings': { func: renderProfileSettingsPage, nav: null }, // NEW: Profile settings page
        '#calendar': { func: renderCalendarPage, nav: 'nav-calendar' },
        '#activity-log': { func: renderActivityLogPage, nav: 'nav-activity-log' },
        '#analytics': { func: renderAnalyticsPage, nav: 'nav-analytics' },
        '#admin-suggestions': { func: renderAdminSuggestionsPage, nav: 'nav-admin-question-suggestions' },
        '#statistics': { func: renderStatisticsPage, nav: 'nav-statistics' },
        '#winner-roulette': { func: renderWinnerRoulettePage, nav: 'nav-winner-roulette' }
    };

    const routeKey = hash.split('/')[0].split('?')[0]; // Get base route e.g., #profile from #profile/123 or #competitions from #competitions/new?agentId=1
    const route = routes[routeKey] || routes['#home'];

    // Special layout for specific pages
    if (routeKey === '#winner-roulette') {
        appContent.classList.add('full-height-content');
        mainElement.classList.add('full-width');
    }

    renderFunction = route.func;
    navElement = document.getElementById(route.nav);

    // Special handling for routes with parameters
    if (hash.startsWith('#profile/')) {
        const agentId = hash.split('/')[1];
        if (agentId) {
            if (typeof renderAgentProfilePage !== 'undefined') {
                renderFunction = () => renderAgentProfilePage(agentId);
            }
            navElement = null; // No nav item is active on a profile page
        }
    } else if (hash.startsWith('#competitions/edit/')) {
        const competitionId = hash.split('/')[2];
        if (competitionId) {
            renderFunction = () => renderCompetitionEditForm(competitionId);
            navElement = document.getElementById('nav-manage-competitions');
        }
    } else {
        // If we are navigating away from a profile page, stop its countdown timer.
        if (typeof stopRenewalCountdown === 'function') {
            stopRenewalCountdown();
        }
        if (typeof stopCompetitionCountdowns === 'function') {
            stopCompetitionCountdowns();
        }
    }

    if (hash.startsWith('#profile/') || hash.startsWith('#competitions/new') || hash.startsWith('#competitions/manage') || hash === '#home' || hash === '#competition-templates' || hash === '#archived-templates' || hash === '#competitions' || hash === '#manage-agents' || hash === '#activity-log' || hash === '#archived-competitions' || hash === '#users' || hash === '#top-agents' || hash === '#analytics' || hash === '#statistics' || hash === '#winner-roulette') {
        mainElement.classList.add('full-width');
    } else if (hash === '#calendar') {
        mainElement.classList.add('full-width');
        appContent.classList.add('full-height-content');
    }

    setActiveNav(navElement);

    try {
        if (renderFunction) {
            await renderFunction();
            mainElement.classList.remove('page-loading');
        }
    } catch (err) {
        console.error("Routing error:", err);
    } finally {
        hideLoader();
    }
}

// ==========================
// Admin Suggestions Page Loader
// ==========================
async function renderAdminSuggestionsPage() {
    if (!window.appContent) {
        console.error('app-content element not found!');
        return;
    }
    try {
        const response = await fetch('/pages/admin-question-suggestions.html');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const html = await response.text();
        window.appContent.innerHTML = html;

        // Dynamically import and initialize the admin suggestions page script
        try {
            const adminModule = await import('/js/pages/admin-question-suggestions.js');
            if (adminModule && typeof adminModule.initAdminQuestionSuggestions === 'function') {
                // Ensure DOM is ready before init
                setTimeout(() => {
                    adminModule.initAdminQuestionSuggestions();
                }, 0);
            } else {
                console.warn('Admin suggestions initialization function not found, attempting fallback');
                // Fallback: if module exports default or different name
                if (adminModule && typeof adminModule.init === 'function') {
                    setTimeout(() => adminModule.init(), 0);
                }
            }
        } catch (e) {
            throw e;
        }
    } catch (error) {
        console.error('Failed to load admin suggestions page:', error);
        window.appContent.innerHTML = `<p class="error-message">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ ØµÙØ­Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª: ${error.message}</p>`;
    }
}

// --- Ø¥ØµÙ„Ø§Ø­: Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø© ---
function setActiveNav(activeElement) {
    // Ø¥Ø²Ø§Ù„Ø© 'active' Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
    document.querySelectorAll('.nav-link, .dropdown-item').forEach(link => {
        link.classList.remove('active');
    });

    if (activeElement) {
        activeElement.classList.add('active');
        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø±Ø§Ø¨Ø· Ø¯Ø§Ø®Ù„ Ù‚Ø§Ø¦Ù…Ø© Ù…Ù†Ø³Ø¯Ù„Ø©ØŒ Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø£ÙŠØ¶Ø§Ù‹
        const parentDropdown = activeElement.closest('.dropdown');
        parentDropdown?.querySelector('.dropdown-toggle')?.classList.add('active');
    }
}

async function logAgentActivity(userId, agentId, actionType, description, metadata = {}) {
    // This function will be reimplemented later using our own backend.
    // console.log(`[FRONTEND LOG] â¡ï¸ Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ³Ø¬ÙŠÙ„ Ù†Ø´Ø§Ø·: ${actionType} (Agent: ${agentId || 'N/A'})`);
    try {
        const payload = {
            user_id: userId || currentUserProfile?._id, // Default to current user if not provided
            action_type: actionType,
            description,
            metadata
        };

        // Only add agent_id to the payload if it's a valid, non-null value.
        if (agentId) {
            payload.agent_id = agentId;
        }

        const response = await authedFetch('/api/logs', {
            method: 'POST',
            body: JSON.stringify(payload)
        });
        if (!response.ok) throw new Error(`Server responded with status ${response.status}`);
        // console.log(`[FRONTEND LOG] âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†Ø´Ø§Ø· Ø¨Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰ Ø§Ù„Ø®Ø§Ø¯Ù….`);
    } catch (error) {
        console.error(`[FRONTEND LOG] âŒ ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†Ø´Ø§Ø· Ø¥Ù„Ù‰ Ø§Ù„Ø®Ø§Ø¯Ù…:`, error);
    }
}

/**
 * NEW: Verifies that the agent's stored Telegram chat ID and group name match the actual data on Telegram.
 * @param {object} agent The agent object containing telegram_chat_id and telegram_group_name.
 * @returns {Promise<{verified: boolean, message: string}>} An object indicating if verification passed.
 */
async function verifyTelegramChat(agent) {
    // NEW: Graceful degradation â€“ allow skipping Telegram verification locally or if bot disabled.
    const skipReason = [];
    if (!agent.telegram_chat_id) skipReason.push('Ù…Ø¹Ø±Ù Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© ØºÙŠØ± Ù…ØªÙˆÙØ±');
    if (!agent.telegram_group_name) skipReason.push('Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© ØºÙŠØ± Ù…ØªÙˆÙØ±');

    // If essential fields missing, warn but do NOT block competition creation.
    if (skipReason.length) {
        showToast(`ØªØ®Ø·ÙŠ ØªØ­Ù‚Ù‚ ØªÙ„Ø¬Ø±Ø§Ù…: ${skipReason.join('ØŒ ')}`,'warning');
        return { verified: true, message: 'SKIPPED_MISSING_FIELDS' };
    }

    try {
        showToast('Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ·Ø§Ø¨Ù‚ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„ØªÙ„Ø¬Ø±Ø§Ù…...','info');
        const response = await authedFetch(`/api/get-chat-info?chatId=${agent.telegram_chat_id}`);
        let data = {};
        try { data = await response.json(); } catch {}

        // If backend returns non-OK but we are in dev or bot disabled, treat as soft failure.
        if (!response.ok) {
            const msg = data.message || 'ØªØ¹Ø°Ø± Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø®Ø¯Ù…Ø© ØªÙ„Ø¬Ø±Ø§Ù…ØŒ ØªÙ… Ø§Ù„ØªØ®Ø·ÙŠ.';
            showToast(msg,'warning');
            return { verified: true, message: 'SKIPPED_BACKEND_ERROR' };
        }

        const actualGroupName = (data.title || '').trim();
        const expectedName = (agent.telegram_group_name || '').trim();
        if (actualGroupName && expectedName && actualGroupName !== expectedName) {
            // Instead of blocking, just warn and continue.
            const warnMsg = `Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ù…Ø³Ø¬Ù„ Ù„Ø§ ÙŠØ·Ø§Ø¨Ù‚ Ø§Ù„ÙØ¹Ù„ÙŠ (Ø§Ù„Ù…Ø³Ø¬Ù„: ${expectedName} / Ø§Ù„ÙØ¹Ù„ÙŠ: ${actualGroupName}) â€“ Ù…ØªØ§Ø¨Ø¹Ø© Ù…Ø¹ ØªØ­Ø°ÙŠØ±.`;
            showToast(warnMsg,'warning');
            return { verified: true, message: 'NAME_MISMATCH_WARN' };
        }
        return { verified: true, message: 'VERIFIED_OR_MATCHED' };
    } catch (error) {
        // Network / fetch error â€“ warn and continue.
        showToast(`ØªØ®Ø·ÙŠ ØªØ­Ù‚Ù‚ ØªÙ„Ø¬Ø±Ø§Ù… Ø¨Ø³Ø¨Ø¨ Ø®Ø·Ø£: ${error.message}`,'warning');
        return { verified: true, message: 'SKIPPED_EXCEPTION' };
    }
}

// 2. Function to initialize the application session
async function initializeApp() {
    updateStatus('connected', 'Ù…ØªØµÙ„ ÙˆØ¬Ø§Ù‡Ø²');
    showLoader(); // Ø¥Ø¸Ù‡Ø§Ø± Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ù‡Ù†Ø§ Ù„Ø¶Ù…Ø§Ù† ØªØºØ·ÙŠØ© Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ø£ÙˆÙ„ÙŠØ©

    // ARCHITECTURAL FIX: Wait for the central store to be ready before proceeding.
    await new Promise(resolve => {
        window.addEventListener('storeReady', resolve, { once: true });
    });

    const userProfile = await fetchUserProfile();
    if (userProfile) {
        window.addEventListener('hashchange', handleRouting);
        updateUIAfterLogin(userProfile); // FIX: Pass the fetched user profile to the UI update function
        handleRouting(); // Initial route handling
    } else {
        // User is not authenticated (no token or invalid token) â€” redirect to login
        hideLoader();
        console.warn('[AUTH] No valid user session. Redirecting to login page.');
        window.location.replace('/login.html');
    }
}

/**
 * NEW: Sets up a listener for real-time messages from the server (e.g., via WebSocket).
 */
function setupRealtimeListeners() {
    console.log('[WebSocket] Initializing Realtime Listeners...');
    const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
    const wsUrl = `${protocol}://${window.location.host}`;
    console.log(`[WebSocket] Target URL: ${wsUrl}`);

    let ws;
    let reconnectAttempts = 0;
    let maxReconnectAttempts = 5;
    let reconnectTimeout;

    function connect() {
        console.log('[WebSocket] Attempting to connect...');
        // Check if token exists before connecting
        const token = localStorage.getItem('authToken');
        if (!token) {
            console.warn('[WebSocket] Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±Ù…Ø² Ù…ØµØ§Ø¯Ù‚Ø©. ØªØ®Ø·ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„.');
            return;
        }

        try {
            ws = new WebSocket(wsUrl);
        } catch (err) {
            console.error('[WebSocket] Failed to create WebSocket instance:', err);
            return;
        }

        // Expose the active WebSocket so other modules (e.g., logout) can close it immediately
        try { window._realtimeWs = ws; } catch (e) { /* ignore in non-browser env */ }

        ws.onopen = () => {
            console.log('[WebSocket] Connection established successfully âœ“');
            reconnectAttempts = 0; // Reset counter on successful connection
            const token = localStorage.getItem('authToken');
            if (token) {
                console.log('[WebSocket] Sending auth token...');
                ws.send(JSON.stringify({ type: 'auth', token }));
            } else {
                console.warn('[WebSocket] No auth token found in localStorage');
            }
        };

        ws.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                switch (message.type) {
                    case 'auth_error':
                        // Handle authentication error from server
                        console.warn('[WebSocket] Authentication failed:', message.error);
                        if (message.error && message.error.includes('expired')) {
                            // Token expired, redirect to login
                            localStorage.removeItem('authToken');
                            localStorage.removeItem('userProfile');
                            showToast('Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø¬Ù„Ø³Ø©. ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.', 'warning');
                            setTimeout(() => {
                                window.location.replace('/login.html');
                            }, 2000);
                        }
                        return; // Don't try to reconnect
                    case 'agent_renewed':
                        showToast(`ØªÙ… ØªØ¬Ø¯ÙŠØ¯ Ø±ØµÙŠØ¯ Ø§Ù„ÙˆÙƒÙŠÙ„ ${message.data.agentName} ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹.`, 'success');
                        break;
                    case 'presence_update':
                        // message.data should be an array of online user IDs
                        if (Array.isArray(message.data)) {
                            window.onlineUsers.clear();
                            message.data.forEach(userId => window.onlineUsers.set(userId, true));
                            // Add the current user to online list
                            const currentUserId = currentUserProfile?.userId || currentUserProfile?._id;
                            if (currentUserId) {
                                window.onlineUsers.set(currentUserId, true);
                            }
                            // Dispatch a global event that the user list can listen to
                            window.dispatchEvent(new CustomEvent('presence-update'));
                            // console.log('[WebSocket] ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©:', Array.from(window.onlineUsers.keys()));
                        }
                        break;
                    
                    case 'suggestion_update':
                    case 'new_suggestion':
                        // console.log('ğŸ”” [WebSocket] Received suggestion update/new suggestion');
                        loadGlobalUnreadCount();
                        break;

                    case 'notification':
                        console.log('ğŸ”” [WebSocket] Received notification:', message);
                        if (typeof showToast === 'function') {
                            showToast(message.message, message.level || 'info');
                        } else {
                            console.error('[WebSocket] showToast function is not defined!');
                            alert(message.message); // Fallback
                        }
                        break;

                    case 'global_notification':
                        console.log('ğŸ”” [WebSocket] Received global notification:', message);
                        showToast(message.message, message.variant || 'info');
                        break;

                    case 'AUDITING_TOGGLED':
                        console.log('ğŸ”” [WebSocket] Auditing toggled:', message.data);
                        // 1. Show toast
                        const statusText = message.data.isAuditingEnabled ? 'ØªÙØ¹ÙŠÙ„' : 'Ø¥Ù„ØºØ§Ø¡ ØªÙØ¹ÙŠÙ„';
                        showToast(`Ù‚Ø§Ù… ${message.data.updatedBy} Ø¨Ù€ ${statusText} Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ Ù„Ù„ÙˆÙƒÙŠÙ„ ${message.data.agentName}`, 'info');
                        
                        // 2. Dispatch a custom event so specific pages can update their UI
                        window.dispatchEvent(new CustomEvent('agent-auditing-update', { detail: message.data }));
                        break;

                    case 'COMPETITION_CREATED':
                        console.log('ğŸ”” [WebSocket] Competition created:', message.data);
                        showToast(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„ÙˆÙƒÙŠÙ„ ${message.data.agentName} Ø¨ÙˆØ§Ø³Ø·Ø© ${message.data.createdBy}`, 'success');
                        window.dispatchEvent(new CustomEvent('competition-update', { detail: { type: 'created', ...message.data } }));
                        break;

                    case 'COMPETITION_COMPLETED':
                        console.log('ğŸ”” [WebSocket] Competition completed:', message.data);
                        showToast(`ØªÙ… Ø¥Ù†Ù‡Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„ÙˆÙƒÙŠÙ„ ${message.data.competitionName || ''} Ø¨ÙˆØ§Ø³Ø·Ø© ${message.data.completedBy}`, 'info');
                        window.dispatchEvent(new CustomEvent('competition-update', { detail: { type: 'completed', ...message.data } }));
                        break;

                    // Add other message types here
                }
            } catch (error) {
                console.error('Error processing WebSocket message:', error);
            }
        };

        ws.onclose = () => {
            console.log('[WebSocket] Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„ âœ—');
            // Remove current user from online list
            const currentUserId = currentUserProfile?.userId || currentUserProfile?._id;
            if (currentUserId) {
                window.onlineUsers.delete(currentUserId);
            }
            // Clear the global reference when socket closes
            try { if (window._realtimeWs === ws) window._realtimeWs = null; } catch (e) { /* ignore */ }
            
            // Only reconnect if we haven't exceeded max attempts
            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                console.log(`[WebSocket] Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø§ØªØµØ§Ù„ (${reconnectAttempts}/${maxReconnectAttempts}) Ø¨Ø¹Ø¯ 5 Ø«ÙˆØ§Ù†ÙŠ...`);
                reconnectTimeout = setTimeout(connect, 5000);
            } else {
                console.warn('[WebSocket] ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø± Ø¨Ø¹Ø¯ Ø¹Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø§Øª. ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø©.');
            }
        };

        ws.onerror = (error) => {
            console.error('[WebSocket] Error:', error);
            try { ws.close(); } catch (e) { /* ignore */ }
        };
    }

    // Function to stop reconnection attempts (e.g., on logout)
    window.stopWebSocketReconnect = function() {
        if (reconnectTimeout) {
            clearTimeout(reconnectTimeout);
            reconnectTimeout = null;
        }
        reconnectAttempts = maxReconnectAttempts; // Prevent future reconnects
    };

    connect();
}

// --- UI Component Functions (Moved from script.js to main.js) ---

function showLoader() {
    document.getElementById('page-loader')?.classList.add('show');
}

function hideLoader() {
    document.getElementById('page-loader')?.classList.remove('show');
}

function showConfirmationModal(message, onConfirm, options = {}) {
    const {
        title = null,
        confirmText = 'ØªØ£ÙƒÙŠØ¯',
        cancelText = 'Ø¥Ù„ØºØ§Ø¡',
        confirmClass = 'btn-primary',
        showCancel = true,
        hideCancel = undefined, // alias support
        modalClass = '',
        onRender = null,
        onCancel = null
    } = options;

    // Backward compatibility: if hideCancel is provided, it overrides showCancel
    const effectiveShowCancel = typeof hideCancel === 'boolean' ? !hideCancel : showCancel;

    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';

    const modal = document.createElement('div');
    modal.className = `modal ${modalClass}`;
    modal.innerHTML = `
        ${title ? `<h3 class="modal-title">${title}</h3>` : ''}
        <div class="modal-message">${message}</div>
        <div class="modal-actions">
            <button id="confirm-btn" class="${confirmClass}">${confirmText}</button>
            ${effectiveShowCancel ? `<button id="cancel-btn" class="btn-secondary">${cancelText}</button>` : ''}
        </div>
    `;

    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    document.getElementById('confirm-btn').onclick = async () => {
        // FIX: Support async callbacks and allow them to prevent modal closing
        if (onConfirm) {
            const result = await Promise.resolve(onConfirm());
            // If callback returns false, don't close the modal
            if (result === false) return;
        }
        overlay.remove();
    
    };
    const cancelBtn = document.getElementById('cancel-btn');
    if (cancelBtn) {
        cancelBtn.onclick = () => {
            if (onCancel) onCancel();
            overlay.remove();
        };
    }

    if (onRender) onRender(modal);
}
// Expose globally so console and other scripts can call it
try { window.showConfirmationModal = showConfirmationModal; } catch (e) { /* ignore in non-browser env */ }

// --- NEW: Dedicated function for progress modals ---
function showProgressModal(title, content) {
    const existingOverlay = document.querySelector('.modal-overlay');
    if (existingOverlay) {
        console.warn('[showProgressModal] A modal is already open. Removing it.');
        existingOverlay.remove();
    }

    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';

    const modal = document.createElement('div');
    modal.className = 'modal modal-no-actions'; // Use the class for modals without buttons
    modal.innerHTML = `
        ${title ? `<h3 class="modal-title">${title}</h3>` : ''}
        <div class="modal-message">${content}</div>
    `;

    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    console.log('[showProgressModal] Progress modal has been appended to the body.');

    return overlay; // Return the overlay so it can be closed later
}

// Fallback toast helper: ensures a visible message even if the app's showToast is absent or hidden
function showFallbackToast(message, duration = 1600) {
    try {
        // Reuse existing global showToast if it exists but also show a DOM fallback to guarantee visibility
        if (typeof showToast === 'function') showToast(message, 'info');
    } catch (e) {
        // ignore
    }

    // Ensure only one fallback toast element
    let el = document.getElementById('global-fallback-toast');
    if (!el) {
        el = document.createElement('div');
        el.id = 'global-fallback-toast';
        el.style.position = 'fixed';
        el.style.bottom = '24px';
        el.style.right = '24px';
        el.style.background = 'rgba(0,0,0,0.85)';
        el.style.color = '#fff';
        el.style.padding = '10px 14px';
        el.style.borderRadius = '8px';
        el.style.zIndex = '2147483647'; // very high so it appears above modals/overlays
        el.style.boxShadow = '0 6px 18px rgba(0,0,0,0.3)';
        el.style.fontSize = '13px';
        el.style.opacity = '0';
        el.style.transition = 'opacity 160ms ease-in-out, transform 160ms ease-in-out';
        el.style.transform = 'translateY(6px)';
        document.body.appendChild(el);
    }
    el.textContent = message;
    // show
    requestAnimationFrame(() => {
        el.style.opacity = '1';
        el.style.transform = 'translateY(0)';
    });
    // hide after duration
    clearTimeout(el._hideTimeout);
    el._hideTimeout = setTimeout(() => {
        el.style.opacity = '0';
        el.style.transform = 'translateY(6px)';
    }, duration);
}
try { window.showFallbackToast = showFallbackToast; } catch (e) { /* ignore */ }

// Centralized logout flow used by all logout triggers
function performLogoutFlow() {
    try { showFallbackToast('Ø¬Ø§Ø±ÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬...', 800); } catch (e) { /* ignore */ }

    // Close realtime socket if present and stop reconnection attempts
    try {
        if (window._realtimeWs && typeof window._realtimeWs.close === 'function') {
            window._realtimeWs.close();
            window._realtimeWs = null;
        }
        if (typeof window.stopWebSocketReconnect === 'function') {
            window.stopWebSocketReconnect();
        }
    } catch (err) {
        console.warn('Failed to close realtime socket during logout:', err);
    }

    // Fire logout API call (fire-and-forget to log activity)
    const logoutTimeout = setTimeout(() => {
        console.warn('Logout API timeout - proceeding with client-side logout');
    }, 2000);
    try {
        authedFetch('/api/auth/logout', { method: 'POST' })
            .then(() => clearTimeout(logoutTimeout))
            .catch(err => {
                console.warn('Logout API call failed:', err);
                clearTimeout(logoutTimeout);
            });
    } catch (e) { 
        clearTimeout(logoutTimeout);
    }

    // Clear auth state immediately
    localStorage.removeItem('authToken');
    localStorage.removeItem('userProfile');

    try { showFallbackToast('ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬', 900); } catch (e) { /* ignore */ }

    // Redirect right away to the login page
    setTimeout(() => window.location.replace('/login.html'), 250);
}
try { window.performLogoutFlow = performLogoutFlow; } catch (e) { /* ignore */ }

function setupAutoHidingNavbar() {
    let lastScrollTop = 0;
    const navbar = document.querySelector('.navbar');
    if (!navbar) return;

    window.addEventListener('scroll', () => {
        // We use pageYOffset for broader browser support
        let scrollTop = window.pageYOffset || document.documentElement.scrollTop;

        // Add a small threshold (e.g., 10px) to prevent hiding on minor scrolls
        if (scrollTop > lastScrollTop && scrollTop > navbar.offsetHeight) {
            // Scrolling Down
            navbar.classList.add('navbar-hidden');
        } else {
            // Scrolling Up
            navbar.classList.remove('navbar-hidden');
        }
        lastScrollTop = scrollTop <= 0 ? 0 : scrollTop; // For Mobile or negative scrolling
    }, { passive: true }); // Use passive listener for better scroll performance
}
// --- New Functions for UI Enhancements ---

// --- NEW: Function to create floating particles for the main app background ---
function createFloatingParticles() {
    const container = document.getElementById('main-animated-bg');
    if (!container) return;
    // Reduce particle count for better performance inside the app
    const numParticles = 150; 
    const colors = ['color-1', 'color-2', 'color-3'];
    for (let i = 0; i < numParticles; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        const size = Math.random() * 2 + 1; // Smaller particles
        particle.classList.add(colors[Math.floor(Math.random() * colors.length)]);
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.left = `${Math.random() * 100}%`;
        // Slower and longer animations
        particle.style.animationDelay = `${Math.random() * 30}s`;
        particle.style.animationDuration = `${Math.random() * 20 + 15}s`;
        container.appendChild(particle);
    }
}

// Apply theme from localStorage on page load
function applyInitialTheme() {
    const savedTheme = localStorage.getItem('theme');
    const themeBtn = document.getElementById('theme-toggle-btn');
    if (savedTheme === 'dark') {
        document.body.classList.add('dark-mode');
    }
}

// Setup listeners and dynamic content for the navbar
function setupNavbar() {
    // NEW: Dark Mode Toggle Logic from dropdown
    const themeToggleHandler = (e) => {
        e.preventDefault(); // Prevent navigation
        if (document.body.classList.contains('dark-mode')) {
            document.body.classList.remove('dark-mode');
            localStorage.setItem('theme', 'light');
        } else {
            document.body.classList.add('dark-mode');
            localStorage.setItem('theme', 'dark');
        }
    };
    const themeBtnDropdown = document.getElementById('theme-toggle-btn-dropdown');
    if (themeBtnDropdown) themeBtnDropdown.addEventListener('click', themeToggleHandler);

    // Logout Button Logic
    const logoutBtn = document.getElementById('logout-btn');
    if (logoutBtn) {
        logoutBtn.addEventListener('click', (e) => {
            e.preventDefault();
            showConfirmationModal(
                'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ø£Ù†Ùƒ ØªØ±ÙŠØ¯ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬ØŸ Ø³ÙŠØªÙ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¬Ù„Ø³Ø© ÙˆØ¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±.',
                () => performLogoutFlow(),
                { title: 'ØªØ£ÙƒÙŠØ¯ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬', confirmText: 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬', cancelText: 'Ø¥Ù„ØºØ§Ø¡', confirmClass: 'btn-danger' }
            );
        });
    }

    // Date Display
    const dateDisplay = document.getElementById('date-display');
    const today = new Date();
    // Using 'ar-EG' for Arabic-Egypt locale for date formatting
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    dateDisplay.textContent = today.toLocaleDateString('ar-EG', options);

    // Placeholder for search functionality
    const searchInput = document.getElementById('main-search-input');
    const mainSearchClearBtn = document.getElementById('main-search-clear');

    searchInput.addEventListener('input', () => {
        if (mainSearchClearBtn) {
            mainSearchClearBtn.style.display = searchInput.value ? 'block' : 'none';
        }

        clearTimeout(searchTimeout);
        const searchTerm = searchInput.value.trim();
        const searchResultsContainer = document.getElementById('search-results');

        if (searchTerm.length < 2) { // Don't search for less than 2 characters
            searchResultsContainer.classList.remove('visible');
            return;
        }

        searchTimeout = setTimeout(async () => {
            // TODO: Replace this with a call to our own backend search endpoint
            const response = await authedFetch(`/api/agents?search=${searchTerm}&limit=5`);
            const { data: agents, error } = await response.json();

            if (error) {
                console.error('Search error:', error);
                return;
            }

            if (agents.length > 0) {
                searchResultsContainer.innerHTML = agents.map(agent => {
                    const avatarHtml = agent.avatar_url
                        ? `<img src="${agent.avatar_url}" alt="Avatar" class="search-result-avatar">`
                        : `<div class="search-result-avatar-placeholder"><i class="fas fa-user"></i></div>`;
                    return `
                    <div class="search-result-item" data-agent-id="${agent._id}">
                        ${avatarHtml}
                        <div class="search-result-info">
                            <p class="agent-name">${agent.name}</p>
                            <p class="agent-id">#${agent.agent_id}</p>
                        </div>
                        <span class="classification-badge classification-${agent.classification.toLowerCase()}">${agent.classification}</span>
                    </div>
                `}).join('');
                searchResultsContainer.classList.add('visible');

                // Add click listeners to new items
                searchResultsContainer.querySelectorAll('.search-result-item').forEach(item => {
                    item.addEventListener('click', async () => {
                        const agentId = item.dataset.agentId;
                        // Use the router for navigation
                        window.location.hash = `profile/${agentId}`;
                        searchResultsContainer.classList.remove('visible');
                        searchInput.value = '';
                        if (mainSearchClearBtn) mainSearchClearBtn.style.display = 'none';
                    });
                });
            } else {
                searchResultsContainer.innerHTML = '<div class="search-result-item" style="cursor: default;">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬</div>';
                searchResultsContainer.classList.add('visible');
            }
        }, 300); // 300ms debounce
    });

    if (mainSearchClearBtn) {
        mainSearchClearBtn.addEventListener('click', () => {
            searchInput.value = '';
            document.getElementById('search-results').classList.remove('visible');
            mainSearchClearBtn.style.display = 'none';
            searchInput.focus();
        });
    }


    // Navigation Logic
    const navHome = document.getElementById('nav-home');
    const navTasks = document.getElementById('nav-tasks');
    const navManageAgents = document.getElementById('nav-manage-agents');
    const navTopAgents = document.getElementById('nav-top-agents'); // NEW
    const navManageCompetitions = document.getElementById('nav-manage-competitions');
    const navArchivedCompetitions = document.getElementById('nav-archived-competitions');
    const competitionsDropdown = document.getElementById('nav-competitions-dropdown');
    const navCompetitionTemplates = document.getElementById('nav-competition-templates');
    const navArchivedTemplates = document.getElementById('nav-archived-templates');
    const navCalendar = document.getElementById('nav-calendar');
    const navActivityLog = document.getElementById('nav-activity-log');
    const navUsers = document.getElementById('nav-users'); // NEW
    const navProfileSettings = document.getElementById('nav-profile-settings'); // This is a dropdown item
    const navStatistics = document.getElementById('nav-statistics');
    const navAnalytics = document.getElementById('nav-analytics'); // NEW
    const navWinnerRoulette = document.getElementById('nav-winner-roulette');

    // NEW: Tasks & Calendar Dropdown Navigation (for admins only)
    const navTasksCalendarDropdownContainer = document.getElementById('nav-tasks-calendar-dropdown-container');
    const navTasksCalendarDropdown = document.getElementById('nav-tasks-calendar-dropdown');

    if (currentUserProfile && navTasksCalendarDropdownContainer) {
        const isAdmin = currentUserProfile.role === 'admin' || currentUserProfile.role === 'super_admin';
        navTasksCalendarDropdownContainer.style.display = isAdmin ? 'block' : 'none';
    }

    if (navTasksCalendarDropdown) {
        navTasksCalendarDropdown.addEventListener('click', (e) => {
            e.preventDefault();
        });
    }

    // NEW: Question Suggestions Dropdown Navigation
    const navQuestionsDropdownContainer = document.getElementById('nav-questions-dropdown-container');
    const navQuestionsDropdown = document.getElementById('nav-questions-dropdown');
    const navAdminQuestionSuggestionsMenu = document.getElementById('nav-admin-question-suggestions');

    // Show/Hide dropdown based on role
    if (currentUserProfile && navQuestionsDropdownContainer) {
        // const isAdmin = currentUserProfile.role === 'admin' || currentUserProfile.role === 'super_admin';
        
        navQuestionsDropdownContainer.style.display = 'block'; // Show dropdown for all employees
        
        if (navAdminQuestionSuggestionsMenu) {
            navAdminQuestionSuggestionsMenu.style.display = 'block'; // Show admin link for all employees
        }
    }

    // Prevent dropdown toggle from navigating
    if (navQuestionsDropdown) {
        navQuestionsDropdown.addEventListener('click', (e) => {
            e.preventDefault();
        });
    }

    navLinks = [navHome, navTasks, navManageAgents, navTopAgents, navManageCompetitions, navArchivedCompetitions, navCompetitionTemplates, navCalendar, navUsers, navProfileSettings, navActivityLog, navAnalytics, navWinnerRoulette, document.getElementById('logout-btn')];
    
    // NEW: Navigation listeners update the hash, which triggers the router
    if (navHome) navHome.addEventListener('click', (e) => { e.preventDefault(); window.location.hash = 'home'; });
    if (navTasks) navTasks.addEventListener('click', (e) => { e.preventDefault(); window.location.hash = 'tasks'; });
    if (navTopAgents) navTopAgents.addEventListener('click', (e) => { e.preventDefault(); window.location.hash = 'top-agents'; });
    if (navManageAgents) navManageAgents.addEventListener('click', (e) => { e.preventDefault(); window.location.hash = 'manage-agents'; });
    if (navProfileSettings) navProfileSettings.addEventListener('click', (e) => { e.preventDefault(); window.location.hash = 'profile-settings'; }); // NEW
    if (navManageCompetitions) navManageCompetitions.addEventListener('click', (e) => { e.preventDefault(); window.location.hash = '#competitions'; });
    if (navArchivedCompetitions) navArchivedCompetitions.addEventListener('click', (e) => { e.preventDefault(); window.location.hash = 'archived-competitions'; });
    if (navArchivedTemplates) navArchivedTemplates.addEventListener('click', (e) => { e.preventDefault(); window.location.hash = 'archived-templates'; });
    if (navCompetitionTemplates) navCompetitionTemplates.addEventListener('click', (e) => { e.preventDefault(); window.location.hash = 'competition-templates'; });
    if (navActivityLog) navActivityLog.addEventListener('click', (e) => { e.preventDefault(); window.location.hash = 'activity-log'; });
    if (navUsers) navUsers.addEventListener('click', (e) => { e.preventDefault(); window.location.hash = 'users'; }); // NEW
    if (navAnalytics) navAnalytics.addEventListener('click', (e) => { e.preventDefault(); window.location.hash = 'analytics'; }); // NEW
    if (navWinnerRoulette) navWinnerRoulette.addEventListener('click', (e) => { e.preventDefault(); window.location.hash = 'winner-roulette'; });
    if (navStatistics) navStatistics.addEventListener('click', (e) => { e.preventDefault(); window.location.hash = 'statistics'; });

    // Hide search results when clicking outside
    document.addEventListener('click', (e) => {
        const searchContainer = e.target.closest('.search-container');
        const userDropdownContainer = e.target.closest('.nav-item.dropdown');

        if (!searchContainer) {
            document.getElementById('search-results').classList.remove('visible');
        }

    });    

    // NEW: Prevent settings dropdown toggle from navigating
    const settingsToggle = document.getElementById('nav-settings-dropdown');
    if (settingsToggle) {
        settingsToggle.addEventListener('click', (e) => {
            e.preventDefault(); // ÙŠÙ…Ù†Ø¹ Ø§Ù„Ø±Ø§Ø¨Ø· Ù…Ù† ØªØºÙŠÙŠØ± Ø§Ù„Ù€ hash ÙˆØ§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        });
    }
}

function renderAddUserForm() {
    const isSuperAdmin = currentUserProfile && currentUserProfile.role === 'super_admin';

    const formHtml = `
        <form id="add-user-form" class="styled-form">
            <div class="form-group">
                <label for="full_name">Ø§Ù„Ø§Ø³Ù… Ø§Ù„ÙƒØ§Ù…Ù„</label>
                <input type="text" id="full_name" name="full_name" required>
            </div>
            <div class="form-group">
                <label for="email">Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ</label>
                <input type="email" id="email" name="email" required>
            </div>
            <div class="form-group">
                <label for="password">ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±</label>
                <input type="password" id="password" name="password" required>
            </div>
            ${isSuperAdmin ? `
                <div class="form-group">
                    <label for="role">Ø§Ù„Ø¯ÙˆØ±</label>
                    <select id="role" name="role"><option value="employee">Ù…ÙˆØ¸Ù</option><option value="admin">Ù…Ø³Ø¤ÙˆÙ„</option></select>
                </div>
            ` : '<input type="hidden" id="role" name="role" value="employee">'}
        </form>
    `;

    showConfirmationModal(formHtml, () => {
        const form = document.getElementById('add-user-form');
        const formData = new FormData(form);
        const data = Object.fromEntries(formData.entries());

        // Handle user creation logic here
        console.log('Creating user with data:', data);

    }, {
        title: 'Ø¥Ø¶Ø§ÙØ© Ù…ÙˆØ¸Ù Ø¬Ø¯ÙŠØ¯',
        confirmText: 'Ø¥Ù†Ø´Ø§Ø¡',
        cancelText: 'Ø¥Ù„ØºØ§Ø¡'
    });
}

async function renderStatisticsPage() {
    if (!window.appContent) {
        console.error("app-content element not found!");
        return;
    }
    try {
        const response = await fetch('/pages/statistics.html');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const html = await response.text();
        window.appContent.innerHTML = html;
        // Dynamically import and initialize the page's script
            const statsModule = await import('/js/pages/statistics.js');
        if (statsModule && typeof statsModule.init === 'function') {
            statsModule.init();
        } else {
            console.warn('Statistics initialization function not found.');
        }
    } catch (error) {
        console.error("Failed to load statistics page:", error);
        window.appContent.innerHTML = `<p class="error-message">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ ØµÙØ­Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª: ${error.message}</p>`;
    }
}

async function renderAnalyticsPage() {
    if (!window.appContent) {
        console.error("app-content element not found!");
        return;
    }
    try {
        const response = await fetch('/pages/analytics.html');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const html = await response.text();
        window.appContent.innerHTML = html;
        // Dynamically import and initialize the analytics page script
        try {
            const analyticsModule = await import('/js/pages/analytics.js');
            if (analyticsModule && typeof analyticsModule.init === 'function') {
                // Defer initialization to ensure DOM is ready
                setTimeout(() => {
                    analyticsModule.init();
                }, 0);
            } else {
                throw new Error('Analytics dashboard initialization function not found');
            }
        } catch (e) {
            // Re-throw to be caught by outer catch and displayed to the user
            throw e;
        }
    } catch (error) {
        console.error("Failed to load analytics page:", error);
        window.appContent.innerHTML = `<p class="error-message">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ ØµÙØ­Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª: ${error.message}</p>`;
    }
}

async function renderWinnerRoulettePage() {
    if (!window.appContent) {
        console.error("app-content element not found!");
        return;
    }
    // Force inline HTML to avoid blank page issues
    window.appContent.innerHTML = getWinnerRouletteInlineHTML();
    
    // Check if winner-roulette init is available (from bundled JS)
    setTimeout(() => {
        if (typeof window.winnerRouletteInit === 'function') {
            // console.log('[winner-roulette] Initializing from bundled code');
            window.winnerRouletteInit();
            winnerRouletteFallbackInitialized = true;
        } else {
            console.warn('[winner-roulette] Init function not found, using fallback');
            initWinnerRouletteFallback('init not available');
        }
    }, 100);

    // Log screen size for debugging
    /*
    console.log('Winner Roulette Page Loaded - Screen Size:', {
        innerWidth: window.innerWidth,
        innerHeight: window.innerHeight,
        outerWidth: window.outerWidth,
        outerHeight: window.outerHeight,
        appContent: window.appContent ? window.appContent.offsetWidth + 'x' + window.appContent.offsetHeight : 'not found'
    });
    */
}

function getWinnerRouletteInlineHTML(minimal = false, errMsg = '') {
        if (minimal) {
                return `<section class=\"page-section\"><h1>Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†</h1><p style='color:#f87171'>ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©: ${errMsg}</p>${baseRouletteMarkup()}</section>`;
        }
        return `<section class=\"page-section\">${baseRouletteMarkup()}</section>`;
}

function baseRouletteMarkup() {
    return `
        <section class=\"page-section\" id=\"winner-roulette-page\">
            <div class=\"page-header\">
                <h1><i class=\"fas fa-random\"></i> Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„</h1>
                <p class=\"page-subtitle\">Ø£Ø¶ÙÙ Ø£Ùˆ Ø§Ù„ØµÙÙ‚ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ† Ù…Ø¹ Ø£Ø±Ù‚Ø§Ù… Ø­Ø³Ø§Ø¨Ø§ØªÙ‡Ù… Ø«Ù… Ø¯ÙˆÙ‘Ø± Ø§Ù„Ø¹Ø¬Ù„Ø© Ù„Ø§Ø®ØªÙŠØ§Ø± ÙØ§Ø¦Ø² Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ø¨ÙƒÙ„ Ø´ÙØ§ÙÙŠØ©.</p>
                <div class=\"wr-agent-selector\">
                    <label for=\"agent-select\"><i class=\"fas fa-user-tie\"></i> Ø§Ø®ØªØ± Ø§Ù„ÙˆÙƒÙŠÙ„:</label>
                    <select id=\"agent-select\" class=\"wr-agent-dropdown\">
                        <option value=\"\">-- Ø§Ø®ØªØ± Ø§Ù„ÙˆÙƒÙŠÙ„ --</option>
                    </select>
                    <span id=\"agent-selection-status\" class=\"wr-agent-status\"></span>
                </div>
            </div>
            <div class=\"wr-layout\">
                <div class=\"wr-panel\" id=\"wr-left-panel\">
                    <div class=\"wr-panel-header\"><h3><i class=\"fas fa-list\"></i> Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†</h3></div>
                    <small>Ù…Ø«Ø§Ù„ Ù„ÙƒÙ„ Ø³Ø·Ø±: <code>Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø«Ù„Ø§Ø«ÙŠ â€” 3191848</code></small>
                    <textarea id=\"participants-input\" class=\"wr-textarea\" placeholder=\"1- Ø§Ø¨ØªØ³Ø§Ù… Ù‚Ø§Ø³Ù… Ù‡Ø§Ù†ÙŠ â€” 3191848\n2- Ø±Ø§Ù…ÙŠ Ø¹Ø¨Ø¯ Ø§Ù„Ø¨Ø§Ø³Ø· â€” 3219692\n3- Ø§ÙˆØ§Ø¨ Ø®Ø§Ù„Ø¯ Ø³Ù„Ø§Ù… â€” 3232334\n4- Ø­Ø³ÙŠÙ† Ø®Ø§Ù„Ø¯ Ø¹ÙˆØ¯Ø© â€” 3257071\n5- Ø­Ù†ÙŠÙ† Ø¹Ù…Ø§Ø¯ Ù…Ø·Ø± â€” 3240004\n6- Ø´ÙŠØ±ÙŠÙ† Ø¹Ø¨Ø¯ Ø§Ù„Ù„Ù‡ Ø³Ø¹ÙˆØ¯ â€” 3076887\n7- Ø¹Ù„ÙŠ Ù…Ø­Ù…Ø¯ Ù†Ø§ØµØ± â€” 3235758\n8- Ø¹Ù…Ø± Ù…Ø¬Ù…Ù„ Ù‚Ø§Ø³Ù… â€” 3245457\"></textarea>
                    <h4 class=\"wr-section-title\">Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙˆÙ†</h4>
                    <div class=\"wr-tools-row\">
                        <input id=\"participants-search\" type=\"text\" class=\"wr-search-input\" placeholder=\"Ø¨Ø­Ø«...\" />
                        <div class=\"wr-counts\">
                          <span>Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: <strong id=\"participants-count-total\">0</strong></span>
                          <span>Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: <strong id=\"participants-count-remaining\">0</strong></span>
                          <span>Ø§Ù„ÙØ§Ø¦Ø²ÙˆÙ†: <strong id=\"winners-count\">0</strong></span>
                        </div>
                        <button id=\"refresh-participants\" class=\"wr-btn wr-btn-primary wr-btn-small\"><i class=\"fas fa-sync-alt\"></i> ØªØ­Ø¯ÙŠØ«</button>
                        <button id=\"reset-winners\" class=\"wr-btn wr-btn-secondary wr-btn-small\"><i class=\"fas fa-trash\"></i> Ù…Ø³Ø­ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†</button>
                    </div>
                    <div id=\"participants-list\" class=\"wr-scroll-box\"></div>
                </div>
                <div class=\"wr-panel\" id=\"wr-right-panel\">
                    <div class=\"wr-panel-header\"><h3><i class=\"fas fa-sync-alt\"></i> Ø¹Ø¬Ù„Ø© Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±</h3></div>
                    <div id=\"agent-info-box\" class=\"wr-agent-info-box\" style=\"display:none;\">
                        <div class=\"wr-agent-info-header\"><i class=\"fas fa-user-tie\"></i> Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„</div>
                        <div class=\"wr-agent-info-row\"><strong>Ø§Ù„Ø§Ø³Ù…:</strong> <span id=\"agent-info-name\">â€”</span></div>
                        <div class=\"wr-agent-info-row\"><strong>Ø±Ù‚Ù… Ø§Ù„ÙˆÙƒØ§Ù„Ø©:</strong> <span id=\"agent-info-id\">â€”</span></div>
                        <div class=\"wr-agent-info-divider\"></div>
                        <div class=\"wr-agent-info-header\"><i class=\"fas fa-trophy\"></i> Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„Ù†Ø´Ø·Ø©</div>
                        <div id=\"agent-competition-info\">
                            <div class=\"wr-agent-info-empty\">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù†Ø´Ø·Ø©</div>
                        </div>
                    </div>
                    <div class=\"wr-settings-grid\">
                        <div class=\"wr-setting\"><label>Ø¥Ø³ØªØ¨Ø¹Ø§Ø¯ Ø¨Ø¹Ø¯ Ø§Ù„ÙÙˆØ²</label><div class=\"wr-checkbox-row\"><input type=\"checkbox\" id=\"exclude-winner\" checked><span style=\"font-size:.7rem;color:var(--wr-text-dim);\">Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø§Ø³Ù…</span></div></div>
                        <div class=\"wr-setting\"><label>Ø¹Ø¯Ø¯ Ø§Ø®ØªÙŠØ§Ø±Ø§Øª</label><input type=\"number\" id=\"batch-count\" min=\"1\" value=\"1\"></div>
                    </div>
                    <div class=\"wr-wheel-wrapper\">
                        <div class=\"wr-pointer\"></div>
                        <canvas id=\"winner-roulette-wheel\"></canvas>
                        <div class=\"wr-actions-row\">
                            <button id=\"auto-pick-btn\" class=\"wr-btn wr-btn-secondary wr-btn-large\"><i class=\"fas fa-forward\"></i> Ù…ØªØªØ§Ù„ÙŠ</button>
                        </div>
                    </div>
                    <small style=\"text-align:center;color:var(--wr-text-dim);\">Ø§Ø®ØªÙŠØ§Ø± Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ø¯ÙˆÙ† ØªØ­ÙŠØ².</small>
                </div>
            </div>
            <div class=\"wr-winners-section\">
                <div class=\"wr-winners-header\">
                    <h3><i class=\"fas fa-trophy\"></i> Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†</h3>
                    <div class=\"wr-winners-actions\">
                        <button id=\"export-winners-bottom\" class=\"wr-btn wr-btn-success wr-btn-small\"><i class=\"fas fa-download\"></i> ØªØµØ¯ÙŠØ±</button>
                        <button id=\"reset-winners-bottom\" class=\"wr-btn wr-btn-secondary wr-btn-small\"><i class=\"fas fa-trash\"></i> Ù…Ø³Ø­ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†</button>
                    </div>
                </div>
                <div id=\"winners-list-bottom\" class=\"wr-winners-grid\"></div>
            </div>
        </section>
                <!-- Simplified winner modal layout to ensure email field clickable -->
                <div id="winner-modal" class="wr-celebration-modal" style="display:none;">
                  <div class="wr-celebration-content" role="dialog" aria-modal="true" aria-label="ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ÙØ§Ø¦Ø²">
                    <div class="wr-winner-name" id="celebration-winner-name">â€”</div>
                    <div class="wr-winner-account" id="celebration-winner-account">â€”</div>
                    <label for="winner-email" class="wr-label">Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ</label>
                    <input type="email" id="winner-email" class="wr-form-input" placeholder="Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù„Ù„ÙØ§Ø¦Ø²" autocomplete="email" required tabindex="0" />
                    <div id="winner-email-error" class="wr-error-msg" style="display:none;color:#f87171;font-size:.75rem;margin-top:4px;">Ø§Ù„Ø¨Ø±ÙŠØ¯ ØºÙŠØ± ØµØ§Ù„Ø­ Ø£Ùˆ ÙØ§Ø±Øº</div>
                    <div class="wr-prize-type" id="celebration-prize-type">Ù†ÙˆØ¹ Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©</div>
                    <div class="wr-prize-value" id="celebration-prize-value">â€”</div>
                    <button id="confirm-winner" class="wr-confirm-btn"><i class="fas fa-check-circle"></i> ØªØ¬Ù‡ÙŠØ² ÙØ§Ø¦Ø²</button>
                  </div>
                </div>
<canvas id=\"wr-confetti-canvas\"></canvas>`;
}

/**
 * Lightweight inline setup so the roulette page still works if the dedicated module fails to load.
 * Shows the wheel, loads agents, and renders participant chips.
 */
function initWinnerRouletteFallback(reason = '') {
    if (winnerRouletteFallbackInitialized) return;
    const canvas = document.getElementById('winner-roulette-wheel');
    const agentSelect = document.getElementById('agent-select');
    const participantsInput = document.getElementById('participants-input');
    if (!canvas || !agentSelect || !participantsInput) return;

    winnerRouletteFallbackInitialized = true;
    if (reason) console.warn(`[winner-roulette:fallback] using inline setup: ${reason}`);

    const state = { entries: [], winners: [] };
    const ctx = canvas.getContext('2d');
    const colors = ['#2563eb', '#8b5cf6', '#10b981', '#f59e0b', '#ef4444', '#06b6d4', '#ec4899', '#84cc16'];

    const updateCounts = () => {
        const totalEl = document.getElementById('participants-count-total');
        const remainingEl = document.getElementById('participants-count-remaining');
        const winnersEl = document.getElementById('winners-count');
        if (totalEl) totalEl.textContent = state.entries.length;
        if (remainingEl) remainingEl.textContent = Math.max(state.entries.length - state.winners.length, 0);
        if (winnersEl) winnersEl.textContent = state.winners.length;
    };

    const renderParticipantsList = () => {
        const listEl = document.getElementById('participants-list');
        if (!listEl) return;
        if (!state.entries.length) {
            listEl.innerHTML = '<div class="wr-agent-info-empty">Ø£Ø¶Ù Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ† Ù„ÙŠØ¸Ù‡Ø±ÙˆØ§ Ù‡Ù†Ø§</div>';
            return;
        }
        listEl.innerHTML = state.entries
            .map(e => `<div class="wr-chip"><span>${e.name}</span><small>#${e.account || '-'}</small></div>`)
            .join('');
    };

    const renderWinnersList = () => {
        const winnersEl = document.getElementById('winners-list-bottom');
        if (!winnersEl) return;
        if (!state.winners.length) {
            winnersEl.innerHTML = '<div class="wr-agent-info-empty">Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙØ§Ø¦Ø²ÙˆÙ† Ø¨Ø¹Ø¯</div>';
            return;
        }
        winnersEl.innerHTML = state.winners
            .map((w, i) => `<div class="wr-card"><div class="wr-card-title">${i + 1}- ${w.name}</div><div class="wr-card-sub">${w.account || ''}</div></div>`)
            .join('');
    };

    const drawWheel = () => {
        const width = canvas.width = 500;
        const height = canvas.height = 500;
        const center = { x: width / 2, y: height / 2 };
        const items = state.entries.length ? state.entries : [{ name: 'Ø£Ø¶Ù Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†', account: '' }];
        const slice = (Math.PI * 2) / items.length;

        ctx.clearRect(0, 0, width, height);
        ctx.save();
        ctx.translate(center.x, center.y);

        items.forEach((item, idx) => {
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.fillStyle = colors[idx % colors.length];
            ctx.arc(0, 0, 220, idx * slice, (idx + 1) * slice);
            ctx.fill();
            ctx.save();
            ctx.rotate(idx * slice + slice / 2);
            ctx.textAlign = 'right';
            ctx.fillStyle = '#fff';
            ctx.font = '16px Cairo, Arial, sans-serif';
            const label = (item.name || '').slice(0, 18) || 'Ù…Ø´Ø§Ø±Ùƒ';
            ctx.fillText(label, 200, 6);
            ctx.restore();
        });

        ctx.beginPath();
        ctx.arc(0, 0, 50, 0, Math.PI * 2);
        ctx.fillStyle = '#0f172a';
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 18px Cairo, Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('INZO', 0, 6);

        ctx.restore();
    };

    const parseParticipants = () => {
        const lines = participantsInput.value.split('\n');
        state.entries = lines
            .map(l => l.trim())
            .filter(Boolean)
            .map((line, idx) => {
                const parts = line.split('-').map(p => p.trim()).filter(Boolean);
                const name = parts.slice(0, parts.length - 1).join(' ') || line;
                const account = parts.slice(-1)[0] || '';
                return { id: `p_${idx}`, name, account };
            });
        renderParticipantsList();
        updateCounts();
    };

    participantsInput.addEventListener('input', () => {
        parseParticipants();
        drawWheel();
    });

    const updateAgentStatus = (name, agentId) => {
        const status = document.getElementById('agent-selection-status');
        if (!status) return;
        if (name && agentId) {
            status.textContent = `${name} (#${agentId})`;
            status.className = 'wr-agent-status selected';
        } else {
            status.textContent = '';
            status.className = 'wr-agent-status';
        }
    };

    agentSelect.addEventListener('change', () => {
        const selected = agentSelect.options[agentSelect.selectedIndex];
        updateAgentStatus(selected?.textContent || '', selected?.dataset.agentId || '');
    });

    const loadAgents = async () => {
        try {
            const response = await authedFetch('/api/agents?limit=1000');
            const result = await response.json();
            const agents = result.data || [];
            agents.forEach(agent => {
                const option = document.createElement('option');
                option.value = agent._id;
                option.textContent = `${agent.name} (#${agent.agent_id})`;
                option.dataset.agentId = agent.agent_id;
                agentSelect.appendChild(option);
            });
        } catch (e) {
            console.warn('[winner-roulette:fallback] Failed to load agents', e);
        }
    };

    parseParticipants();
    drawWheel();
    renderWinnersList();
    loadAgents();
}

// Main entry point when the page loads
document.addEventListener('DOMContentLoaded', () => {
    applyInitialTheme();
    setupNavbar();
    setupAutoHidingNavbar();
    initializeApp();
    // NEW: Initialize the real-time listener. This function needs to be
    // implemented with your actual WebSocket logic.
    setupRealtimeListeners();
    createFloatingParticles(); // --- NEW: Add animated background to the main app ---

    // --- NEW: Listen for browser online/offline events ---
    window.addEventListener('offline', () => {
        updateStatus('error', 'ØºÙŠØ± Ù…ØªØµÙ„. ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØªØµØ§Ù„Ùƒ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª.');
    });

    window.addEventListener('online', () => {
        updateStatus('connecting', 'ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„. Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø©...');
        // Attempt to re-initialize the session
        initializeApp();
    });
});

// Fallback: ensure logout button always opens confirmation modal.
// This adds a non-destructive listener after DOM is ready.
document.addEventListener('DOMContentLoaded', () => {
    try {
        const btn = document.getElementById('logout-btn');
        if (!btn) return;
        // Replace the node with a clone to remove any previously attached listeners
        const clone = btn.cloneNode(true);
        btn.parentNode.replaceChild(clone, btn);
        // Attach a single, authoritative handler to the cloned element
        clone.addEventListener('click', (e) => {
            if (document.querySelector('.modal-overlay')) return; // Avoid stacking modals
            e.preventDefault();
            showConfirmationModal(
                'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ø£Ù†Ùƒ ØªØ±ÙŠØ¯ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬ØŸ Ø³ÙŠØªÙ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¬Ù„Ø³Ø© ÙˆØ¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±.',
                () => performLogoutFlow(),
                { title: 'ØªØ£ÙƒÙŠØ¯ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬', confirmText: 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬', cancelText: 'Ø¥Ù„ØºØ§Ø¡', confirmClass: 'btn-danger' }
            );
        }, { passive: false });
    } catch (e) {
        console.error('Failed to attach fallback logout handler', e);
    }
});

// ==========================
// Global Unread Suggestions Counter
// ==========================
async function loadGlobalUnreadCount() {
    try {
        let endpoint = '';
        if (currentUserProfile.role === 'super_admin') {
            endpoint = '/api/question-suggestions/unread-count';
        } else {
            endpoint = '/api/question-suggestions/employee-unread-count';
        }

        const response = await window.utils.authedFetch(endpoint);

        if (!response.ok) {
            return;
        }

        const data = await response.json();

        if (data.success) {
            const unreadCount = data.data.unreadCount || 0;
            displayGlobalUnreadCount(unreadCount);
        }
    } catch (error) {
        console.error('âŒ [Global Unread Count] Error loading unread count:', error);
    }
}

function displayGlobalUnreadCount(count) {
    const globalUnreadCountElement = document.getElementById('globalUnreadCount');

    if (globalUnreadCountElement) {
        if (count > 0) {
            globalUnreadCountElement.textContent = count;
            globalUnreadCountElement.style.display = 'inline-block';
            
            // Update click handler based on role
            const badgeLink = globalUnreadCountElement.closest('a');
            if (badgeLink) {
                badgeLink.onclick = (e) => {
                    e.preventDefault();
                    if (currentUserProfile.role === 'super_admin') {
                        window.location.href = '/pages/admin-question-suggestions.html';
                    } else {
                        window.location.href = '/pages/question-suggestions.html';
                    }
                };
            }
        } else {
            globalUnreadCountElement.style.display = 'none';
        }
    }
}


})(window);
